---
title:  汇编语言_王爽_1
date: 2023-01-29 10:47:46
permalink: /pages/29f27e/
categories:
  - studynotes
  - 计算机基础
  - 汇编
tags:
  - 
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---


## [第一章 基础知识](https://blog.csdn.net/inv1796915552/article/details/109559495#-1)

【学习汇编主要是：学习汇编的编程思想，掌握机器运行的思维】
汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程。

### 1.汇编课程的研究重点

​	如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作

### 2.汇编语言的主体是汇编指令

### 3.汇编指令和机器指令的差别在于指令的表示方法上

​	汇编指令是机器指令便于记忆的书写格式

### 4.汇编语言是机器指令的助记符

### 5.汇编语言的组成

1. 汇编指令（机器码的助记符）

2. 伪指令（由编译器执行）

3. 其他符号（由编译器识别，如：+ - * /）

- 汇编语言的核心是汇编指令，它决定了汇编语言的特性



#### 6.CPU对存储器的读写

指令和数据在内存中存放

CPU要想进行数据的读写，必须和外部器件（即芯片）进行三类信息的交互
   	1. 地址信息：存储单元的地址
 	2. 控制信息：芯片的选择，读或写命令
 	3. 数据信息：读或写的数据

存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号

**CPU从3号单元中读取数据的过程（见图1.3）如下。**

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211213225403577.webp" alt="image-20211213225403577" style="zoom:67%;" />

1. CPU通过地址线将地址信息3发出。
2. CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据

3. 存储器将3号单元中的数据8通过数据线送入CPU

> 显卡、声卡也是有内存的。
>
> 汇编语言的指令：mov ax,bx  将bx寄存器内容移动到ax寄存器中。指令一般使用3个字母标识
>
> 《编码的奥秘》写CPU内部是咋实现的
>
> 汇编通篇都是讲CPU是如何调动内存并处理数据的。显存，显卡中的存储器，数据存到显存，GPU读取出来映射到屏幕，GPU速度比CPU还快



问题：如何命令计算机进行数据的读写呢？对于8086CPU

**机器码**：10100001 00000011 00000000

对应的汇编指令：MOV AX,[3]

**含义**：从3号单元读取数据送入寄存器AX



### 6. 地址总线

CPU是通过地址总线来指定存储单元的；地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211213231327331.webp" alt="image-20211213231327331" style="zoom:67%;" />

> 一般习惯用下面表示高位，上面表示低位；所以图中地址总线传到内存为1011
>
> 一根地址总线可以索引一个内存单元，1个内存单元为1字节；
>
> 一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N。这样的CPU最多可以寻找2^n^个内存单元。地址总线为8的cpu的寻址能力为2^8^



### 7. 数据总线

CPU与内存或其他器件之间的数据传送是通过数据总线来进行的，数据总线的宽度决定了CPU和外界的数据传送速度。

我们来看看不同数据总线宽度的CPU想内存中写入数据 89D8H

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211213232647284.webp" alt="image-20211213232647284" style="zoom:50%;" />

16位数据总线只需要发送一次就行

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211213232729679.webp" alt="image-20211213232729679" style="zoom:50%;" />

> 8086有16根数据线，可一次传送16位数据，所以可一次传送数据89D8H；而8088有8根数据线，一次只能传8位数据，所以向内存写入数据89D8H时需要进行两次数据传送



### 8. 控制总线

CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211213233145228.webp" alt="image-20211213233145228" style="zoom:50%;" />

> 这里的每根控制总线可能对应不同的命令，比如：1011 的第1个1代表对X的读取，第二个1代表对XX的读，0代表对X的写

前面所讲的内存读或写命令是由几根控制线综合发出的

- 其中有一根称为“读信号输出”的控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据；
- 有一根称为“写信号输出”的控制线则负责传送写信号。



### 小结(对应练习题1.1)

> 计算机中，所有的东西都是二进制。那我们怎样区分什么是数据？什么是地址？什么是指令？**将二进制信息放在不同总线就代表什么，放在数据总线代表是数据，在地址总线代表这是一个地址，在控制总线代表这是一个指令操作**

地址总线：决定CPU的寻址能力，如10根总线，找2^10^=1024个内存单元，插进来1M的内存，只能看到前面1KB的东西

数据总线：决定CPU每次传输量，越多越快

控制总线：决定CPU对其他器件的控制能力



### 9. 内存地址空间(概述)

什么是内存地址空间呢？举例来讲，一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。



### 10. 主板

在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。



### 11. 接口卡

计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制。

CPU对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。

扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以直接控制这些接口卡，从而实现CPU对外设的间接控制。

> 即，CPU控制显卡，显卡再控制显示器



### 12. 各类存储器芯片

#### 读写属性分类：

随机存储器(RAM) 和 只读存储器(ROM)

> 随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；内存
>
> 只读存储器只能读取不能写入，关机后其中的内容不丢失。操作系统的自启动程序就是写在ROM中的

#### 功能和连接上分类

随机存储器RAM

> 用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上RAM和插在扩展插槽上的RAM。

装有BIOS的ROM

> BIOS是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统
>
> 主板上的ROM中存储着主板的BIOS（通常称为系统BIOS）；显卡上的ROM中存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS。
>
> 即：不一定只有主板上才有BIOS

接口卡上的RAM

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211215165854045.webp" alt="image-20211215165854045" style="zoom:67%;" />



### 13. 内存地址空间

上述那些存储器，物理上是独立的，逻辑上却没分开

- 都与CPU的总线相连
- CPU对它们读写时通过控制总线发出内存读写命令

> 这也就是说，CPU在操控它们的时候，把它们都当作内存来对待，把它们总的看作个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。
>
> 在汇编这门课中，我们所面对的是内存地址空间。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211215170210768.webp" alt="image-20211215170210768" style="zoom:67%;" />

> 在图1.8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。
>
> **CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据**
>
> 即：CPU在显存地址空间中写入数据，数据就会被写入显存，从而被显卡输出到显示器

这些内存地址空间的分配是由厂家决定的

> 内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20，可以传送20个不同的地址信息（大小从0至2^20^-1）。即可以定位2^20^个内存单元，则8086PC的内存地址空间大小为1MB。
>
> 同理，80386CPU的地址总线宽度为32，则内存地址空间最大为4GB

**我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的内存地址空间分配情况。**

因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。

比如，我们希望向显示器输出一段信息，那么必须将这段信息写到显存中，显卡才能将它输出到显示器上。要向显存中写入数据，必须知道显存在内存地址空间中的地址

下面是8086PC机的内存地址空间分配情况

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211215171143087.webp" alt="image-20211215171143087" style="zoom:67%;" />

> 在此pc机中，向A0000-BFFFF的内存单元中写数据，就是向显存中写入数据
>
> **最终运行程序的是CPU，我们用汇编语言编程的时候，必须要从CPU的角度考虑问题。**对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。







## 第二章 寄存器

### 1. CPU概述

一个典型的CPU由**运算器、控制器、寄存器**等器件组成，这些器件靠内部总线相连

> 内部总线实现CPU内部各个器件之间的联系；
>
> 外部总线实现CPU和主板上其他器件的联系
>
> 对于一个汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制



### 2. 通用寄存器

8086CPU有14个寄存器，分别为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。

> **8086CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。**

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216102343513.webp" alt="image-20211216102343513" style="zoom:67%;" />

如图所示，向AX中存储数据：20000

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216102637316.webp" alt="image-20211216102637316" style="zoom:67%;" />

8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上，**8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用**

- AX可分为AH和AL

- BX可分为BH和BL；
- CX可分为CH和CL：

- DX可分为DH和DL。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216102820127.webp" alt="image-20211216102820127" style="zoom:67%;" />

> 如果8位寄存器想用怎么办？直接将AH置0不用，使用AL就行

AX的低8位（0位-7位）构成了AL寄存器，高8位（8位~15位）构成了AH寄存器；**AH和AL寄存器是可以独立使用的8位寄存器。**图24展示了16位寄存器及它所分成的两个8位寄存器的数据存储的情况

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216103104908.webp" alt="image-20211216103104908" style="zoom:67%;" />



### 3. 字在寄存器中的存储

出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据

- 字节：记为**byte，一个字节由8个bit组成**，可以存在8位寄存器中
- 字：记为**word，一个字由两个字节组成**，这两个字节分别称为这个字的高位字节和低位字节，如图2.5所示。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216103730005.webp" alt="image-20211216103730005" style="zoom:67%;" />

一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。

如图2.4所示，一个字型数据20000存在AX寄存器中，在AH中存储了它的高8位，在AL中存储了它的低8位。AH和AL中的数据，既可以看成是一个字型数据的高8位和低8位，这个字型数据的大小是20000；又可以看成是两个独立的字节型数据，它们的大小分别是78和32。

> 由于一个内存单元可存放8位数据，CPU中的寄存器又可存放n个8位的数据。也就是说，计算机中的数据大多是由1-N个8位数据构成的。



### 4. 几条汇编指令

![image-20211216104737652](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216104737652.webp)

> 汇编指令或寄存器名称不区分大小写

![image-20211216105043022](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216105043022.webp)



![image-20211216105055465](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216105055465.webp)

> 0000H  说明是一个字，16位，2字节
>
> 程序段中的最后一条指令 add ax,bx，在执行前ax和bx中的数据都为8226H，相加后所得的值为：1044CH，但是ax为16位寄存器，只能存放4位十六进制的数据，所以最高位的1不能在ax中保存，ax中的数据为：044CH
>
> 即在16位寄存器中，超过16位，抛弃最高位。这个抛弃的最高位1，单独保存在进位

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216105608922.webp" alt="image-20211216105608922" style="zoom:67%;" />

> 注意：l 代表的是低8位(也可以单独作为一个寄存器)，h 代表高8位
>
> 程序段中的最后一条指令add al,93H，在执行前，al中的数据为C5H，相加后所得的值为：158H，但是al为8位寄存器，只能存放两位十六进制的数据，所以最高位的1丢失，ax中的数据为：0058。（这里的丢失，指的是进位值不能在8位寄存器中保存，但是CPU并不真的丢弃这个进位值，关于这个问题，我们将在后面的课程中讨论。）
>
> 注意，此时a1是作为一个独立的8位寄存器来使用的，和ah没有关系，CPU在执行这条指令时认为ah和al是两个不相关的寄存器。不要错误地认为，诸如 add  al，93H的指令产生的进位会存储在ah中，add al，93H进行的是8位运算
>
> 即哪怕这是16位寄存器；低8位相加溢出了，也不会进位到高8位；即：add al,85H  0158H是错误的，正确：0058H

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216110641148.webp" alt="image-20211216110641148" style="zoom:67%;" />



### 5. 物理地址

CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。

CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。我们现在讨论8086CPU是如何在内部形成内存单元的物理地址的。



### 6. 16位结构的CPU

- 运算器一次最多可以处理16位的数据（8字节）
- 寄存器的最大宽度为16位
- 寄存器和运算器之间的通路为16位

> 8086是16位结构的CPU，这也就是说，在8086内部，能够一次性处理、传输、暂时存储的信息的最大长度是16位的。内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理、传输、暂时存储16位的地址



### 7. 8086CPU 给出物理地址的方法

8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。

8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。

> **<font color="red">8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</font>**

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216115141993.webp" alt="image-20211216115141993" style="zoom:67%;" />

如图2.6 所示，当8086CPU要读写内存时：

1. CPU中的相关部件提供**两个16位的地址**，一个称为**段地址**，另一个称为**偏移地址**；
2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；
3. **地址加法器将两个16位地址合成为一个20位的物理地址**；
4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路；
5. 输入输出控制电路将20位物理地址送上地址总线
6. 20位物理地址被地址总线传送到存储器。

> 地址加法器采用<font color="red">物理地址=段地址×16+偏移地址</font>的方法用段地址和偏移地址合成物理地址。

例如，8086CPU要访问地址为123C8H的内存单元，此时，地址加法器的工作过程如图27所示（图中数据皆为十六进制表示）。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216115548924.webp" alt="image-20211216115548924" style="zoom:67%;" />

> ×16，对于16进制来说是左移1位，对于2进制来说是左移4位。所以“段地址×16”更常用的说法是 左移4位

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216115948995.webp" alt="image-20211216115948995" style="zoom:67%;" />

> 1.一个数据的二进制形式左移1位，相当于该数据乘以2；
>
> 2.一个数据的二进制形式左移N位，相当于该数据乘以2的N次方
>
> 3.**地址加法器如何完成段地址×16的运算？就是将以二进制形式存放的段地址左移4位**
>
> 进一步思考，我们可看出：一个数据的十六进制形式左移1位，相当于乘以16；一个数据的十进制形式左移1位，相当于乘以10；一个X进制的数据左移1位，相当于乘以X。



### 8. “物理地址=段地址×16+偏移地址” 的本质含义

[看书](D:\xuan\带上它,便带上整个故事\typora\编程笔记\后端\编程的内功\3. 汇编\2712_汇编语言 第3版.pdf)



### 9. 段的概念

内存并没有分段，段的划分来自于CPU。由于8086用“基础地址(段地址×16)+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

如图2.9所示，我们可以认为：地址10000\~100FFH的内存单元组成一个段，该段的起始地址（基础地址）为10000H，段地址为1000H，大小为100H；

我们也可以认为地址10000H\~1007FH、10080H\~100FFH的内存单元组成两个段，它们的起始地址（基础地址）为：10000H和10080H，段地址为：1000H和1008H，大小都为80H。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216134548570.webp" alt="image-20211216134548570" style="zoom:67%;" />

> 只要能把准确地址标出来，逻辑上划分多少个段都可以，段只是我们自己为了方便理解的概念

以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。

- 段地址×16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；
- 偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB。(2^16^=64KB)

> CPU访问内存单元时，必须向内存提供内存单元的物理地址。8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。

| 物理地址 | 段地址 | 偏移地址 |
| -------- | ------ | -------- |
| 21F60H   | 2000H  | 1F60H    |
|          | 2100H  | 0F60H    |
|          | 21F0H  | 0060H    |
|          | 21F6H  | 0000H    |
|          | 1F00H  | 2F60H    |

> **CPU可以用不同的段地址和偏移地址形成同一个物理地址。只要能确保最终找到确定的物理地址就行**
>
> 比如CPU要访问2lF60H单元，则它给出的段地址SA和偏移地址EA满足SA×16+EA=21F6OH即可。

（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可定位多少个内存单元？

结论：偏移地址16位，变化范围为0-FFFFH，仅用偏移地址来寻址最多可寻64KB个内存单元。

比如给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H-1FFFFH。

> 在8086C机中，存储单元的地址用两个元素来描述，即段地址和偏移地址。
>
> “数据在21F60H内存单元中。”这句话对于8086PC机一般不这样讲，取而代之的是两种类似的说法：
>
> ①数据存在内存2000:1F60单元中；
>
> ②数据存在内存的2000H段中的1F60H单元中。
>
> 这两种描述都表示“数据在内存21F60H单元中”。可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段.



### 10. 段寄存器

8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。

段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。本章中只看一下CS。

> CS代码段，DS数据段，SS堆栈段，ES附加段



### 11. CS和IP(CPU读取指令过程)(重要)

CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，P为指令指针寄存器，从名称上我们可以看出它们和指令的关系。

在8086PC机中，任意时刻，设CS中的内容为M,IP中的内容为N，8086CPU将从内存M×16+N单元开始，读取一条指令并执行。(即CS存段地址，IP存偏移地址)

也可以这样表述：**8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。**

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216144115324.webp" alt="image-20211216144115324" style="zoom:67%;" />

图2.10说明

1. 8086当前状态：CS(段地址)为2000H，IP(偏移地址)为0000H

2. 物理内存20000H-20009H存放可执行的机器码

3. 物理内存20000H-20009H存放的机器码对应汇编指令

   地址：20000H-20002H，内容：B8 23 01，长度3Byte，对应汇编指令：mov ax,0123H

> [P10有此部分的动画](https://www.bilibili.com/video/BV1zW411n79C?p=10&spm_id_from=pageDriver)
>
> 注意一下高位和低位   一般上低下高

此时是初始状态，(CS=2000H,IP=0000H)CPU将从内存的2000H*16+0000H处开始读取指令并执行

![image-20211216144847109](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216144847109.webp)



![image-20211216144857303](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216144857303.webp)



![image-20211216144936175](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216144936175.webp)



![image-20211216145004916](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216145004916.webp)



![image-20211216145038503](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216145038503.webp)



![image-20211216145115305](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216145115305.webp)

> （读取一条指令后，IP中的值自动增加，以使CP∪可以读取下一条指令。因当前读入的指令B8 23 01长度为3个字节，所以P中的值加3。此时，CS:IP指向内存单元2000:0003。）

![image-20211216145230463](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216145230463.webp)



![image-20211216145251638](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216145251638.webp)

然后反复这个过程继续读取指令

1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；
2. IP=IP+所读取指令的长度，从而指向下一条指令;
3. 执行指令。转到步骤（1），重复这个过程。

在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH,IP=0000H，即在8086PC机刚启动时，CPU从内存  FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

> 我们可以说，CPU将CS:IP指向的内存单元中的内容看作指令，因为，在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。如果说，内存中的段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过



### 12. 修改CS、IP的指令

在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，**程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。**

> 8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令
>
> 但是，mov指令不能用于设置CS、IP的值。能够改变CS、IP的内容的指令被统称为转移指令（我们以后会深入研究）。我们现在介绍一个最简单的可以修改CS、IP的指令：jmp指令。

**同时修改CS、IP内容：jmp 段地址:偏移地址**

- jmp 2AE3:3，执行后：CS=2AE3H,IP=0003H，CPU将从2AE33H处读取指令。

- jmp 3:0B16，执行后：CS=0003H,IP=0B16H，CPU将从00B46H处读取指令。

> "jmp 段地址:偏移地址"  指令的功能为：用指令中给岀的段地址修改CS，偏移地址修改IP。

**若想只修改IP的内容：jmp  某一合法寄存器**

jmp ax(类似于 mov IP,ax)

> 注意：只是用mov语法更形象的说明功能，并不是说就有，mov IP,ax指令，实质上mov是不能对IP进行操作的

思考问题：

内存中存放的机器码和对应的汇编指令情况如图2.27所示，设CPU初始状态：CS=2000H,IP=0000H，请写出指令执行序列。思考后看分析。

![image-20211216152411884](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211216152411884.webp)

1.当前CS=2000H,IP=0000H，则CPU从内存2000H×16+0=20000H处读取指令，读入的指令是：B8 22 66（mov  ax，6622H)，读入后IP=IP+3=0003H；(mov ax,6622H)

2.指令执行后，CS=2000H,IP=0003H，则CPU从内存2000H×16+0003H = 20003H处读取指令。读入的指令是：EA 03 00 00 10(jmp 1000:0003)，读入后IP=IP+5=0008H；(jmp 1000:3)

3.指令执行后，CS=1000H,IP=0003H，则CPU从内存1000H×16+0003H=10003H处读取指令。读入的指令是：B8 00 00 (mov  ax,0000)，读入后IP=IP+3=0006H；(mov ax,0000)

4.mov bx,ax；bx=0000H，IP=0008H

5.jmp bx；IP=0000H

6.mov ax,0123H

7.第三步的执行



### 13.代码段

前面讲过，对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。

我们可以将长度为N(N≤64KB)的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。比如，将

```asm
mov ax,0000		(B8 00 00)
add ax,0123H	(05 23 01)
mov bx,ax		(8B D8)
jmp bx			(FF E3)
```

这段长度为10个字节的指令，存放在123B0H-123B9H的一组内存单元中，我们就可以认为，123B0H~123B9H这段内存是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10个字节。

> 如何使得代码段中的指令被执行呢？**CPU只认被CS:IP指向的内存单元中的内容为指令。**
>
> 所以，要让CPU执行我们放在代码段中的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。
>
> 而上面这段代码想得到执行，可设CS=123BH,IP=0000H，指向123B0H



#### 小结

1. 段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址。
2. CS存放指令的段地址，IP存放指令的偏移地址。

> 8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。

3. 8086CPU的工作过程：
   1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；
   2. IP指向下一条指令；
   3. 执行指令。(转到步骤①，重复这个过程。)

4. 8086CPU提供转移指令修改CS、IP的内容。(比如jmp)





## 第三章 寄存器(内存访问)

第二章注意了解8086CPU的逻辑机构及其一些指令，从内部了解CPU寄存器；这一章，我们从访问内存的角度了解寄存器

### 1. 内存中字的存储

CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（**一个单元存放一个字节**），则一个字要用两个地址连续的内存单元来存放，**这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。**

比如我们从0地址开始存放20000(4E20H)，这种情况如图3.1所示。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211217115000723.webp" alt="image-20211217115000723" style="zoom:50%;" />

> 问题：（1）0地址单元中存放的字节型数据是多少？20H
>
> （2）0地址字单元中存放的字型数据是多少？4E20H
>
> （3）2地址单元中存放的字节型数据是多少？12H
>
> （4）2地址字单元中存放的字型数据是多少？0012H
>
> （5）1地址字单元中存放的字型数据是多少？124EH

#### 结论

任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元。



### 2. DS和[address]\(重要)

CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086CPU中有一个**DS寄存器，通常用来存放要访问数据的段地址**。

比如我们要读取10000H单元的内容，可以用如下的程序段进行

```asm
mov bx,1000H
mov ds,bx
mov al,[0]
# 这3条指令将 10000H(1000:0)中的数据读到al中
```

#### 说明

```asm
mov al,[0]
```

mov指令，完成的传送功能：

（1）将数据直接送入寄存器；(mov ax,100H)

（2）将一个寄存器中的内容送入另一个寄存器。(mov ax,bx)

（3）**将一个内存单元中的内容送入一个寄存器中**

mov指令的格式：mov 寄存器名,内存单元地址

“[...]”表示一个内存单元，**“[…]”中的0表示内存单元的偏移地址。**但是只有偏移地址是不能定位一个内存单元的，那么内存单元的段地址是多少呢？指令执行时，**8086CPU自动取ds中的数据为内存单元的段地址。**

#### **解析(重点)**

如何用mov指令从10000H中读取数据？

1. 10000H表示位1000:0 (段地址:偏移地址)
2. 将段地址1000H放入DS
3. 用mov al,[0]完成传送（mov指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0，它的段地址默认放在ds中。指令执行时，8086CPU会自动从ds中取出。）

> **不能用 mov ds,1000H，是非法的。**因为8086CPU不支持将数据直接送入段寄存器。所以只能用一个寄存器作为中转
>
> **数据 -> 通用寄存器 ->段寄存器**

#### 问题

**写几条指令，将al中的数据送入内存单元10000H中？**

> 注意：mov bx,1000H  这是将内存单元的数据送入寄存器
>
> 从内存单元到寄存器：mov 寄存器名 内存单元地址；从寄存器到内存单元：mov 内存单元地址，寄存器名。
>
> 10000H可表示为1000:0，用ds存放段地址1000H，偏移地址是0，则mov [0],al 可完成从al到10000H的数据传送

```asm
mov bx,1000H
mov ds,bx
mov [0],al
```



### 3. 字的传送

前面我们用mov指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构，有16根数据线；所以，可以一次性传送16位的数据，也就是说可以一次性传送一个字。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。比如：

```asm
mov bx,1000H
mov ds,bx
mov ax,[0]		; 1000:0处的字型数据送入ax
mov [0],cx		# cx中的16位数据送到1000:0处
```

#### 问题

**内存中的情况如图3.2所示，写出下面的指令执行后寄存器ax,bx,cx中的值。**

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211217135507855.webp" alt="image-20211217135507855" style="zoom:50%;" />

```asm
mov ax,1000H		; ax=1000H
mov ds,ax 			; ds=1000H
mov ax,[0]			; ax=1123H ds=1000,[0]是偏移为0的内存地址 对应到图中的10000H
mov bx,[2]			; bx=6622H
mov Cx,[1]			; cx=2211H
add bx,[1]			; bx=8833H 此时10002H=33 10003H=88
add Cx,[2]			; cx=8833H
```

> 用debug操作一下：1.在内存中放入4个字节的值：e 1000:0 23 11 22 66
>
> 2.随便找一段内存，写入汇编指令；比如直接定位初始的CS:IP位置处写入汇编指令；r(查看CS:IP)，a CS:IP 回车  写入汇编指令       
>
> 不过使用CS:IP指向的内存前最好先用d看一下有无值，尽量选择内存值为0的地方



**内存中的情况如图3.3所示，写出下面的指令执行后内存中的值，思考后看分析。**

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211217140232866.webp" alt="image-20211217140232866" style="zoom:50%;" />

```asm
mov ax,1000H 		; ax=1000H
mov ds,ax			; ds=1000H
mov ax,11316 		; ax=2c34H
mov [0],ax 			; 10000H=2c34H  对应到图上的话：10000H=34 10001H=2c
mov bx,[0]			; bx=2c34H
sub bx,[2]			; bx=2c34H-1122H = 1b12H
mov [2],bx			; 10002H=1b12  10002H=12 10003H=1b
```

> 注意：这是理想的情况，如果这段内存没有被保护，就能更改，如果这段内存被保护了，就改不了



### 4. mov、add、sub指令

```asm
; mov指令的几种形式
mov 寄存器,数据			 mov aX,100H
mov 寄存器,寄存器			 mov aX,bx 
mov 寄存器,内存单元		mov ax,[0]
mov 内存单元,寄存器		mov[0],ax
mov 段寄存器,寄存器		mov ds,ax
```

根据已知指令进行推测：（设想：8086CPU内部有寄存器到段寄存器的通路，那么也应该有相反的通路。）

- **mov 段寄存器,寄存器**    =>   **mov  寄存器,段寄存器**

- **mov 内存单元,寄存器**    =>   **mov  内存单元,段寄存器**       **mov 段寄存器,内存单元**

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211217143515261.webp" alt="image-20211217143515261" style="zoom:67%;" />

> 验证使用debug验证

ad和sub指令同mov一样，都有两个操作对象。它们也可以有以下几种形式

```asm
add		寄存器,数据		  add ax,8
add		寄存器,寄存器		 add ax,bX
add		寄存器,内存单元	 add ax,[0]
add		内存单元，寄存器	add [0],ax

sub		寄存器,数据 			 sub ax,9
sub 	寄存器,寄存器 		 sub ax,bx
sub 	寄存器,内存单元 		sub ax,[0]
sub 	内存单元,寄存器 		sub [0],ax
```

> 它们可以对段寄存器进行操作吗？比如“add ds,ax”。请自行在 Debug中试验。**不可以，直接报错**



### 5. 数据段

前面讲过（参见2.8节），对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。

> 如：CS:IP指向的就是代码段    ds指向的就是数据段
>
> 如果内存单元的一组数据，被CS:IP指向，则认为这是一段指令；被DS指向，这认为这是数据段

我们可以将一组长度为N（N≤64KB）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。

比如用123B0H-123B9H这段内存空间来存放数据，我们就可以认为，123B0H~123B9H这段内存是一个数据段，它的段地址为123BH，长度为10个字节。

**如何访问数据段中的数据呢？**

> 将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作的时候，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

比如，将123B0H~123B9H的内存单元定义为数据段。现在要累加这个数据段中的前3个单元中的数据，代码如下

```asm
mov ax,123BH
mov ds,ax		; 将123BH送入ds中，作为数据段的段地址
mov al,0		; 用a1存放累加结果
add al,[0]		; 将数据段第一个单元（偏移地址为0）中的数值加到a1中
add al,[1]		; 将数据段第二个单元（偏移地址为1）中的数值加到a1中
add al,[2]		; 将数据段第三个单元（偏移地址为2）中的数值加到a1中
```

#### 问题

写几条指令，累加数据段中的前3个字型数据，思考后看分析。

```asm
mov ax,123BH
mov ds,ax			; 将123BH送入ds中，作为数据段的段地址
mov ax,0			; 用ax存放累加结果
add ax,[0]			; 将数据段第一个字（偏移地址为0）加到ax中
add ax,[2]			; 将数据段第二个字（偏移地址为2）加到ax中
add ax,[4]			; 将数据段第三个字（偏移地址为4）加到ax中
```

> 注意，一个字型数据占两个单元，所以偏移地址是0、2、4。

#### 小结

（1）字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

（2）用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。

（3）[address]表示一个偏移地址为 address 的内存单元。

（4）在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。

（5）mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。

（6）可以根据自己的推测，在 Debug中实验指令的新格式。



### 6. 栈

在这里，我们对栈的研究仅限于这个角度：栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。

> 先进后出；后进先出



### 7. CPU提供的栈机制(重要)

现今的CPU中都有栈的设计，8086CPU也不例外。8086CPU提供相关的指令来以栈的方式访问内存空间。这意味着，在基于8086CPU编程的时候，可以将一段内存当作栈来使用。

**8086CPU提供入栈和出栈指令，最基本的两个是PUSH（入栈）和POP（出栈）。**

**比如，push ax表示将寄存器ax中的数据送入栈中，pop  ax表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。**

下面举例说明，我们可以将10000H~1000FH这段内存当作栈来使用。

![image-20211217171135974](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211217171135974.webp)

```asm
; 指令如下
mov ax,0123H	; ax=0123H
push ax			; 将ax中的数据压栈 即0123H压栈
mov bx,2266H	; bx=2266H
push bx			; 将bx压栈，即2266H压栈
mov cx,1122H	; cx=1122H
push cx			; 将cx压栈，即1122H压栈
pop ax			; 将出栈栈顶元素送入ax  此时ax=1122H
pop bx			; 栈顶元素送入bx bx=2266H
pop cx			; 栈顶元素送入cx cx=0123H
; 可看到，通过栈的方式，将AX与CX寄存器中的数据进行了交换
```

> 注意，字型数据用两个单元存放，高地址单元存放高8位，低地址单元存放低8位。

#### 问题

1.我们将10000\~1000FH这段内存当作栈来使用。但是，一个重要的问题是，**CPU如何知道10000H~1000FH这段空间被当作栈来使用？**

2.push、pop在执行的时候，必须知道哪个单元是栈顶单元，可是，如何知道呢？

> 这不禁让我们想起另外一个讨论过的问题，就是，CPU如何知道当前要执行的指令所在的位置？我们现在知道答案，那就是CS、IP中存放着当前指令的段地址和偏移地址。
>
> 现在的问题是：CPU如何知道栈顶的位置？显然，也应该有相应的寄存器来存放栈顶的地址，8086CPU中，有两个寄存器，**段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。**
>
> **任意时刻，SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。**



**入栈：push ax**的执行过程，分为两步：

1. SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

**出栈：pop ax**的执行过程：

1. 先将SS:SP(栈顶)指向的元素弹出到寄存器AX
2. SP=SP+2，SS:SP指向栈顶元素

![image-20211217173546594](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211217173546594.webp)

> 从图中我们可以看出，8086CPU中，入栈时，栈顶从高地址向低地址方向增长

#### 问题

如果将10000H~1000FH这段空间当作栈，初始状态栈是空的，此时，SS=1000H，SP=？思考后看分析。

分析：**SP=0010H**，如图3.11所示

![image-20211217173948597](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211217173948597.webp)

> 任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就**不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2**，栈最底部字单元的地址为1000EH，所以栈空时，SP=0010H。
>
> 从栈顶弹出的元素，不会消失，只是改变了栈顶元素的索引，下次压栈时，会将其覆盖；被覆盖才算真正的消失

![image-20211218115809714](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211218115809714.webp)

> 注意，图3.12中，出栈后，SS:SP指向新的栈顶1000EH，pop操作前的栈顶元素1000CH处的2266H依然存在，但是，它已不在栈中。当再次执行push等入栈指令后SS:SP移至1000CH，并在里面写入新的数据，它将被覆盖。



### 8. 栈顶超界的问题

理论上，栈顶溢出有 向上溢出(栈空间满了还塞数据) 向下溢出(栈空间空了还取数据)

栈顶超界是危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的（毕竟一个计算机系统中并不是只有我们自己的程序在运行）。但是由于我们在入栈岀栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。

我们当然希望CPU可以帮我们解决这个问题，比如说在CPU中有记录栈顶上限和栈底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU在执行push指令的时候靠检测栈顶上限寄存器、在执行pop指令的时候靠检测栈底寄存器保证不会超界。（8086CPU没有这样的寄存器）

> 8086CPU的工作机理，它只考虑当前的情况：
>
> - 当前的栈顶在何处
> - 当前要执行的指令是哪一条。



### 9. push、pop指令

push和pop指令是可以在寄存器和内存（栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。）之间传送数据的。

**push和pop指令的格式**可以是如下形式：

```asm
push 寄存器	; 将一个寄存器中的数据入栈
pop 寄存器		; 出栈，用一个寄存器接收出栈的数据

push 段寄存器	; 将一个段寄存器中的数据入栈
pop 段寄存器	; 出栈，用一个段寄存器接收出栈的数据

push 内存单元	; 将一个内存字单元处的字入栈（注意：栈操作都是以字为单位）
pop 内存单元	; 出栈，用一个内存字单元接收出栈的数据
;如：push[0] ds:0位置字数据入栈
;pop[2] 将栈顶数据放置ds:2位置
```

指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中取得。

#### 问题

**编程，将10000H~1000FH这段空间当作栈，初始状态栈是空的，将AX、BX、DS中的数据入栈。**

```asm
mov cx,1000H	
mov ss,cx		; 设置栈的段地址，ss=1000H，不能直接向段寄存器ss中送入数据，所以用cx中转。
mov sp,0010H	; 设置栈顶的偏移地址，因栈为空，所以sp=0010H。编程中要自己注意栈的大小。

push ax
push bx
push ds
```



**编程**

（1）将10000~1000FH这段空间当作栈，初始状态栈是空的

（2）设置AX=001AH,BX=001BH；

（3）将AX、BX中的数据入栈

（4）然后将AX、BX清零；

（5）从栈中恢复AX、BX原来的内容。

```asm
mov ax,1000H
mov ss,ax
mov sp,10H	; 初始化栈顶

mov ax,1aH
mov bx,1bH
push ax		; 入栈
push bx

;mov ax,0H
;mov bx,0H
sub ax,ax	; 将ax清零，也可以使用mov ax,0H(我用的就是这个)
			; sub ax,ax的机器码为2个字节
			; mov ax,0的机器猫为3个字节
sub bx,bx
pop bx		; 由于栈式后进的先出；所以要恢复，先pop到bx
pop ax
```

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211218154644353.webp" alt="image-20211218154644353" style="zoom:50%;" />

>从上面的程序我们看到，用栈来暂存以后需要恢复的寄存器中的内容时，**出栈的顺序要和入栈的顺序相反**，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。



**编程**

（1）将10000~1000FH这段空间当作栈，初始状态栈是空的

（2）设置AX=001AH,BX=001BH；

（3）利用栈，交换AX和BX中的数据。

```asm
; 初始化栈空间
mov ax,1000H
mov ss,ax
mov sp,0010H
; 初始化ax与bx
mov ax,001aH
mov bx,001bH

; 交换
push ax
push bx
pop ax
pop bx
```

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211218154940384.webp" alt="image-20211218154940384" style="zoom:67%;" />

#### 问题

如果要在10000H处写入字型数据2266H，可以用以下的代码完成

```asm
mov ax,1000H
mov ds,ax
mov ax,2266H
mov [0],ax
```

补全下面的代码，使它能够完成同样的功能：在10000H处写入字型数据2266H。

要求：不能使用“mov内存单元，寄存器”这类指令

```asm
mov ax,1000H
mov ss,ax
mov sp,2	; 一定要注意：入栈顺序：先sp-2，然后存入值

mov ax,2266H
push ax
```

> 我们来看需补全代码的最后两条指令，将ax中的2266H压入栈中，也就是说，最终应由 push ax将2266H写入10000处。问题的关键就在于：如何使  push ax访问的内存单元是10000H。
>
> 所以，要在执行 push ax之前，将SS:SP指向1000H（可以设ss=1000，sp=0002H），这样，在执行 push  ax的时候，CPU先将SP=SP-2，使得SS:SP指向10000H，再将ax中的数据送入SS:SP指向的内存单元处，即10000H处。



push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据。

与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。

执行push时，CPU的两步操作是：先改变SP，后向SS:SP处传送。执行pop时，CPU的两步操作是：先读取SS:SP处的数据，后改变SP

> 注意，push,pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0-FFFFH。
>
> 提供：SS、SP指示栈顶；改变SP后写内存的入栈指令；读内存后改变SP的出栈指令。这就是8086CPU提供的栈操作机制



#### 总结

（1）8086CPU提供了栈操作机制：**在SS、SP中存放栈顶的段地址和偏移地址；提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元**

（2）push指令的执行步骤：①SP=SP-2；②向SS:SP指向的字单元中送入数据。

（3）pop指令的执行步骤：①从SS:SP指向的字单元中读取数据；②SP=SP+2

（4）任意时刻，SS:SP指向栈顶元素。

（5）8086CPU只记录栈顶，栈空间的大小我们要自己管理

（6）用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

（7）push、pop实质上是一种内存传送指令，注意它们的灵活应用。



### 10. 栈段

前面讲过（参见2.8节），对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。

我们可以将长度为N（N≤64KB）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。比如，我们将10010H~1001FH这段长度为16字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为个栈段，段地址为1001H，大小为16字节。

将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就在执行push、pop等栈操作指令时自动地将我们定义的栈段当作栈空间来访问。

如何使得如push、pop等栈操作指令访问我们定义的栈段呢？前面我们已经讨论过，就是要将SS:SP指向我们定义的栈段。



#### 问题

**如果将10000H~1FFFH这段空间当作栈段，初始状态栈是空的，此时SS=1000H,SP=？**

分析：

如果将10000H~FFFFH这段空间当作栈段，SS=1000H，栈空间为64KB，栈最底部的字单元地址为1000:FFFE。任意时刻，SS:SP指向栈顶单元，当栈中只有一个元素的时候，SS=1000H,SP=FFFEH。栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2。

SP原来为FFFEH，加2后SP=0，所以，当栈为空的时候，SS=1000H,SP=0

> 换一个角度看，任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的地址为栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE，所以栈空时，SP=0000H.



**一个栈段最大可以设为多少？为什么？**

push、pop等指令在执行的时候只修改SP，所以栈顶的变化范围是0-FFFFH，从栈空时候的SP=0，一直压栈，直到栈满时SP=0；如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。所以一个栈段的容量最大为64KB。



#### 段的总结

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。

我们可以用一个段存放数据，将它定义为“**数据段**”；我们可以用一个段存放代码，将它定义为“**代码段**”；我们可以用一个段当作栈，将它定义为“**栈段**”。

我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：

- 对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问

- 对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；
- 对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。

> 段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即CS、IP，SS、SP，DS的指向





## 第四章 第一个程序

### 1. 一个源程序从写出到执行的过程

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211220110316825.webp" alt="image-20211220110316825" style="zoom:50%;" />

**第一步：编写汇编源程序。**

使用文本编辑器（如Edit、记事本等），用汇编语言编写汇编源程序这一步工作的结果是产生了一个存储源程序的文本文件。

**第二步：对源程序进行编译连接。**

使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。

可执行文件包含两部分内容。

- 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
- 相关的描述信息（比如，程序有多大、要占用多少内存空间等）

这一步工作的结果：产生了一个可在操作系统中运行的可执行文件。

**第三步：执行可执行文件中的程序。**

在操作系统中，执行可执行文件中的程序。

操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。



### 2. 源程序

```asm
; 伪指令
assume cs:codesg	; 使codesg代码段与cpu中的cs段寄存器关联

codesg segment		; 定义一个段，段的名称为“codesg”，这个段从此开始（从名字可看出这是代码段）

	; 汇编指令
	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	
	mov ax,4c00H
	int 21H

; 伪指令
codesg ends			; 名称为“codesg”的段到此结束

end					; 结束整个汇编
```

#### 1. 伪指令

在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。

- 汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。

- 而伪指令没有对应的机器指令，最终不被CPU所执行。

那么谁来执行伪指令呢？伪指令是由编译器来执行的指令，**编译器根据伪指令来进行相关的编译工作**。

##### 1. segment ... ends

segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。**segment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。**一个段必须有一个名称来标识，使用格式为:

```asm
段名 segment
	...
段名 ends
```

> 一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。
>
> 我们在前面的课程中所讲解的段的概念，在汇编源程序中得到了应用与体现，一个源程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到了不同的段中。
>
> 一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。



##### 2. end

**end是一个汇编程序的结束标记**，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。所以，在我们写程序的时候，如果程序写完了，要在结尾处加上伪指令end。否则，编译器在编译程序时，无法知道程序在何处结束。

> 注意，不要搞混了end和ends,**ends是和 segment成对使用的，标记一个段的结束**，ends的含义可理解为“end  segment”。我们这里讲的**end的作用是标记整个程序的结束**。



##### 3. assume

这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用segment.ends定义的段相关联。通过  assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

assume并不是一条非要深入理解不可的伪指令，以后我们编程时，记着用  **assume将有特定用途的段和相关的段寄存器关联起来**即可

> 比如，在程序中，我们用 codesg segment…，codesg ends定义了一个名为  codseg的段，在这个段中存放代码，所以这个段是一个代码段。
>
> 在程序的开头，**用 assume cs:codesg将用作代码段的 段codesg和CPU中的段寄存器cs联系起来**



#### 2. 源程序中的“程序”

**汇编源程序：伪指令(编译器处理)    汇编指令(编译为机器码)**

程序：源程序中最终由计算机执行、处理的指令或数据

用汇编语言写的源程序，包括伪指令和汇编指令。程序就是指源程序中最终由计算机执行、处理的指令或数据。

即，**将源程序文件中的所有内容称为源程序**，**将源程序中最终由计算机执行、处理的指令或数据，称为程序**。程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。这个过程如图4.2所示。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211220112535132.webp" alt="image-20211220112535132" style="zoom:67%;" />

#### 3. 标号

一个标号指代了一个地址

codesg：在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。

#### 4. 程序的结构

任务：编程运算2^3^，源程序怎样写？

1. 定义一个段
2. 写入汇编指令，实现处理任务
3. 程序结束
4. 短语段寄存器关联

```asm
assume cs:abc
abc segment
	
	mov ax,2
	mov ax,ax
	mov ax,ax
	
abc ends
end
```

#### 5. 程序的返回

**一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为：程序返回。**那么，如何返回呢？应该在程序的末尾添加返回的程序段。

```asm
; 程序返回
mov ax,4c00H
int 21H
```

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211220113555362.webp" alt="image-20211220113555362" style="zoom:67%;" />



### 3. 编辑源程序

可用 nodepad++   sublime  vscode(现在用这个)



### 4. 编译

1.进入源程序所在文件夹，然后将 link.exe  masm.exe  ml.exe，放进去，使其处于同一目录

2.cmd中   编译：masm  1.asm

> 编译后生成1.obj文件，二进制文件



### 5.连接

link 1.obj

> 连接后生成1.exe 可执行文件

然后直接 1.exe运行



### 6. 以简化的方式进行编译和连接

masm 1.asm;

> 用 ; 号简化，就不需要一步步确定了
>
> ML是masm与link的缩写：一次性编译连接：ml 1.asm

**编译和连接的作用**

- 当源程序很大时，可以将它分为多个源程序文件夹编译，每隔源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件
- 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件
- 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。

> 注意，对于连接的过程，可执行文件是我们要得到的最终结果。



### 7. 谁将可执行文件中的程序装载进入内存并使它运行？

**（1）此时，有一个正在运行的程序将1.exe中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？**

1.在DOS中直接执行1.exe时，是正在运行的  command，将1.exe中的程序加载入内存；

2.command设置CPU的CS:IP指向程序的第一条指令（即程序的入口），从而使程序得以运行；

**（2）程序运行结束后，返回到哪里？**

3.程序运行结束后，返回到 command中，CPU继续运行 command。

> 操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为shell(外壳)的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。
>
> DOS中有一个程序  command.com，这个程序在DOS中称为命令解释器，也就是DOS系统的 shell。
>
> DOS启动时，先完成其他重要的初始化工作，然后运行  command.com，command.com运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，比如：“c:\”或“c:\Windows”等，然后等待用户的输入。
>
> 用户可以输入所要执行的命令，比如: cd、dir、type等，这些命令由  command执行，command执行完这些命令后，再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。
>
> 如果用户要执行一个程序，则输入该程序的可执行文件的名称，command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序的入口。此后，command暂停运行，CPU运行程序。程序运行结束后，返回到  command中，command再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。
>
> 在DOS中，command处理各种输入：命令或要执行的程序的文件名。我们就是通过 command来进工作的。

> **汇编程序从写出到执行的过程**
>
> 到此，完成了一个汇编程序从写出到执行的全部过程。我们经历了这样一个历程：
>
> 编程 → 1.asm → 编译 → 1.obj → 连接 → 1.exe → 加载 → 内存中的程序 → 运行
>
> (Edit)					(masm)				(link)					(command)						(CPU)



### 8. 程序执行过程的跟踪

现在我们知道，在DOS中运行一个程序的时候，是由  command将程序从可执行文件中加载入内存，并使其得以执行。但是，这样我们不能逐条指令地看到程序的执行过程，因为  command的程序加载，设置CS:IP指向程序的入口的操作是连续完成的，而当CS:IP指向程序的入口，command就放弃了CPU的控制权，CPU立即开始运行程序，直至程序结束。

为了观察程序的运行过程，可以使用  Debug。Debug可以将程序加载入内存，设置CS:IP指向程序的入口，但Debug并不放弃对CPU的控制，这样，我们就可以使用Debug的相关命令来单步执行程序，査查看每一条指令的执行结果。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211220143358946.webp" alt="image-20211220143358946" style="zoom:67%;" />

在提示符后输入“debug 1.exe”，按  Enter键，Debug将程序从1.exe中加载入内存，进行相关的初始化后设置CS:IP指向程序的入口。

接下来可以用R命令看一下各个寄存器的设置情况，如图所示。

![image-20211220143455369](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211220143455369.webp)

可以看到，Debug将程序从可执行文件加载入内存后，**cx中存放的是程序的长度。**1.exe中程序的机器码共有12个字节。则1.exe加载后，cx中的内容为000CH。

> 为啥DS与CS相差了10H？段地址相差10H，代表物理地址相差了100H，翻译成10进制就是256 
>
> 这256个字节，要留给PSP

现在程序已从1.exe中装入内存，接下来査看一下它的内容，可是我们查看哪里的内容呢？程序被装入内存的什么地方？我们如何得知？

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211220143924276.webp" alt="image-20211220143924276" style="zoom:67%;" />

那么，我们的程序被装入内存的什么地方？我们如何得知？从图420中我们知道以下的信息。

（1）程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds:0；

（2）**这个内存区的前256个字节中存放的是PSP,DOS用来和程序进行通信**。从256字节处向后的空间存放的是程序。

所以，从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA×16+0 

因为PSP占256(100H)字节，所以程序的物理地址是：

SA×16+0+256 = SA×16+16×16+0 = (SA+16)×16+0 可用段地址和偏移地址表示为：SA+10H : 0



> Debug默认所有数据都用16进制表示

U命令查看其他指令；T命令单步执行程序中的每条指令，并观察结果；**到了int 21H，需要用P命令执行**

需要注意的是，在DOS中运行程序时，是 command将程序加载入内存，所以程序运行结束后返回到 command中，而在这里是  Debug将程序加载入内存，所以程序运行结束后要返回到 Debug中。

**使用Q命令退出 Debug**，将返回到 command中，因为 Debug是由 command加载运行的。在DOS中用“debug 1.exe”运行Debug对1.exe进行跟踪时，程序加载的顺序是：

command加载 Debug，Debug加载1.exe。返回的顺序是：从1.exe中的程序返回到Debug，从 Debug返回到  command。





## 第五章 [BX]和loop指令

### 1. [bx]和内存单元的描述

> mov ax,[0]		; 注意：在源程序写这个，是把0放到寄存器ax中；在debug中写，是将[0]内存单元的数据放进ax寄存器

[0]表示内存单元，它的偏移地址是0。(在debug中使用)mov ax,[0]：将一个内存单元的内容送入寄存器AX，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为0，段地址在ds中

要完整地描述一个内存单元，需要两种信息：

- ①内存单元的地址；
- ②内存单元的长度（类型）。

> 用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器 ax长度为字）指出。

**[bx]同样也表示一个内存单元，它的偏移地址在bx中**，比如下面的指令

```asm
; mov ax,[0]	; 简单点：在源程序中,这段代码编译器会识别为 mov ax,0 将0放入寄存器ax
				; 这个只能在debug时输入，debug才识别为将ds:0的数据存入ax
; 下面这个就是解决上面的问题。毕竟我们写代码不可能全用debug写
mov bx,0
mov ax,[bx]		
; 将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址在bx中，段地址在ds中。
```

**后面定义的描述性符号**

为了描述上的简洁，在以后的课程中，我们将使用一个描述性的符号“()”来表示一个寄存器或一个内存单元中的内容。比如:

- (ax)表示ax中的内容、(al)表示al中的内容；
- (20000H)表示内存20000H单元的内容
- ((ds)*16 + (bx))：段地址\*16 + bx(作为偏移地址)



我们看一下（X）的应用，比如，

（1）ax中的内容为0010H，可以这样来描述：(ax) = 0010H；

（2）2000:1000处的内容为0010H，可以这样来描述：(21000H) = 0010H

（3）对于  mov  ax,[2] 的功能，可以这样来描述：(ax) = ((ds)*16+2)

（4）对于mov [2],ax 的功能，可以这样来描述：((ds)*16+2) = (ax)

（5）对于  add ax,2 的功能，可以这样来描述：(ax) = (ax)+2

（6）对于 add ax,bx 的功能，可以这样来描述：(ax) = (ax)+(bx)

（7）对于 push ax 的功能，可以这样来描述  (sp) = (sp)-2    ((ss)*16+(sp)) = (ax)

（8）对于 pop  ax 的功能，可以这样来描述  (ax) = ((ss)*16+(sp))  (sp)=(sp)-2

> **(SS)*16 可理解为左移1位，没加括号表示地址，用括号包裹表示取值**

"(X)"所表示的数据有两种类型：①字节；②字。是哪种类型由寄存器名或具体的运算决定，比如：

(al)、(bl)、(cl) 等得到的数据为字节型；(ds)、(ax)、(bx) 等得到的数据为字型。

(al) = (20000H)，则(20000H)得到的数据为字节型；(ax) = (20000H)，则(20000H)得到的数据为字型。



**约定符号 idata 表示常量**

我们在 Debug中写过类似的指令：mov  ax,[0] ，表示将ds:0处的数据送入ax中。指令中，在“【…】”里用一个常量0表示内存单元的偏移地址。以后，我们用  idata 表示常量。比如

```properties
mov ax,[idata] 就代表 mov ax,[1] 、mov ax,[2] 、mov ax,[3] 等。

mov bx,idata 就代表 mov bx,1 、mov bx,2 、mov bx,3 等
```



### 2. [BX]

```asm
mov ax,[bx] ; 功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。
; 即：(ax)=((ds)*16+(bx)) 即左移ds值+bx作为偏移
```

```asm
mov [bx],ax	; 功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处。
; 即：((ds)*16+(bx)) = (ax)
```

#### 问题

程序和内存中的情况如图5.1所示，写出程序执行后，21000H~21007H单元中的内容。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211220163016396.webp" alt="image-20211220163016396" style="zoom: 67%;" />

> 注意：**inc bx的含义是bx中的内容加1**

```asm
; 初始化数据段
mov ax,2000H
mov ds,ax
mov bx,1000H

mov ax,[bx]		; ax=00beH

inc bx			; 1001H
inc bx			; 1002H
mov [bx],ax		; ax=00beH，将00beH移动到21002H处   
				; 2000:1002=be 2000:1003=00

inc bx			; 1003H
inc bx			; 1004H
mov [bx],ax		; ax=00beH，将00beH移动到21004H处

inc bx			; 1005H
mov [bx],al		; 21005H = be
inc bx
mov [bx],al		; 21006H = be
```

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211220164040503.webp" alt="image-20211220164040503" style="zoom:50%;" />



### 3. Loop指令

**loop指令的格式是：loop 标号**，CPU执行loop指令的时候，要进行两步操作：

- ①(cx)=(cx)-1
- ②判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。

> **通常我们用loop指令来实现循环功能，cx中存放循环次数**

**任务1：编程计算2^12^，结果存在ax中**

```asm
assume cs:codesg
codesg segment

	mov ax,2
	; 做11次add ax,ax
	add ax,ax
	
	; 程序返回
	mov ax,4c00h
	int 21h

codesg ends
end
```

用loop循环改进

```asm
assume cs:codesg
codesg segment

	mov ax,2
	mov cx,11	; 存放循环次数
	
s:	add ax,ax	; 循环标号
	loop s		; 开始循环
	
	; 程序返回
	mov ax,4c00h
	int 21h

codesg ends
end
```

#### 分析

##### 1. 标号

在汇编语言中，标号代表一个地址，上面的程序中有一个标号s。它实际上标识了一个地址，这个地址处有一条指令：add  ax,ax

##### 2. loop s

CPU执行 loop s 的时候，要进行两步操作：

1.  (cx) = (cx)-1    **循环次数-1**

2. **判断 cx 中的值，不为 0 则转至标号 s 所标识的地址处执行**（这里的指令是add ax,ax）；**如果为零则执行下一条指令**（下一条指令是 mov  ax,4cO0h）

##### 3. 3条指令

```asm
	mov cx,11
s:	add ax,ax
	loop s
```

执行 loop s时，首先要将(cx)减1，然后若(cx)不为0，则向前转至 s 处执行 add ax,ax。所以，可以利用cx来控制 add  ax,ax的执行次数。

> 可以总结出用cx和loop指令相配合实现循环功能的3个要点：
>
> 1. 在cx中存放循环次数；
> 2. loop指令中的标号所标识地址要在前面
> 3. 要循环执行的程序段，要写在标号和loop指令的中间。

```properties
格式：
	mov cx,循环次数
s:	
	循环执行的程序段
	loop s
```



#### 问题

**编程，用加法计算123*236，结果存在ax中。思考后看分析。**

```asm
assume cs:codesg
codesg segment

; 第一版
    mov ax,0		; ax置零
    mov cx,236		; 循环236次

s:  add ax,123		; 每次让ax+123
    loop s

; 第二版  改进，减少循环次数
	mov ax,0
	mov cx,123		; 循环执行123次
s:	add ax,236
	loop s
	
    ; 程序返回...

codesg ends
end
```

> 编译器默认采用10进制数，所以源程序用到了16进制数，还是加个H强调一下的好



### 4. 在 Debug中跟踪用loop指令实现的循环程序

**问题：计算 ffff:0006 单元中的数，乘以3，结果存储在dx中**

分析：

（1）运算后的结果是否会超出dx所能存储的范围？

ffff:0006单元中的数是一个字节型的数据，范围在0-255之间，则用它和3相乘结果不会大于65535，可以在dx中存放下。

（2）用循环累加来实现乘法，用哪个寄存器进行累加？

将ffff:0006单元中的数赋值给ax，用 dx 进行累加。先设 (dx)=0，然后做3次 (dx)=(dx)+(ax)

（3）ffff:6 单元是一个字节单元，ax 是一个16位寄存器，数据的长度不一样，如何赋值？

> 设ffff:0006单元中的数据是 XXH，若要ax中的值和ffff:0006单元中的相等，ax中的数据应为00XXH。所以，若实现ffff:0006单元向ax赋值，应该令 (ah)=0，(al)=(ffff6H)

```asm
assume cs:codesg
codesg segment

    ; 初始化数据栈,使 ds:bx 指向 ffff:6
    mov ax,0ffffh	; 注意：在汇编中，数据不能以字母开头
    mov ds,ax
    mov bx,0006h

    ; 将 ffff:6 的值存入ax,
    mov al,[bx] ; 因为数据为字节型 ax是字型
    mov ah,0    ; 所以需要保证 (ah)=0

    ; 准备累加达到 *3的效果
    mov dx,0
    mov cx,3    ; 循环次数
s:  add dx,ax
    loop s

    ; 程序返回...

codesg ends
end
```

> **在汇编源程序中，数据不能以字母开头**。所以要在前面加0。
>
> 比如，9138h在汇编源程序中可以直接写为“9138h”，而A00h在汇编源程序中要写为“0A00h”。



**用debug对程序的执行过程进行跟踪**

1.用debug加载test.exe，用r命令查看寄存器中的内容

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211221113113469.webp" alt="image-20211221113113469" style="zoom:67%;" />



![image-20211221113511257](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211221113511257.webp)

图5.3中 (ds)=0B2DH，所以，程序在0B3D:0处。我们看一下，(cs)=0B3DH，(IP)=0，CS:IP正指向程序的第一条指令。再用u命令看一下被  Debug加载入内存的程序，如图54所示。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211221113511257.webp" alt="image-20211221113511257" style="zoom:67%;" />

可以看到，从0B3D:0000-0B3D:001A是我们的程序，0B3D:0014处是源程序中的指令 loop s，只是此处 loop  s中的标号s已经变为一个地址0012h。如果在执行“loop 0012”时，**cx减1后不为0，“loop 0012”就把IP设置为0012h**，从而使CS:IP指向0B3D:0012处的  add dx,ax，实现转跳。



如果循环次数太多，一步一步调试很烦的，引入G命令，希望能够一次执行完，然后从CS:0012处开始跟踪。可以这样来使用g命令，**“g 0012”，它表示执行程序到当前代码段（段地址在CS中）的0012h处**。也就是说“g 0012”将使 Debug从当前的CS:IP指向的指令执行，一直到 (IP)=0012h为止。具体的情况如图5.12所示

![image-20211221114713886](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211221114713886.webp)

> G 偏移地址(段地址在CS中)    类似于高级语言中的断点效果
>
> p 直接执行完所有程序



### 5. Debug和汇编编译器masm对指令的不同处理

```asm
mov ax,[0]	; 将 ds:0 处的数据送入ax中
			; 但在源程序中，会被编译器当作指令“mov ax,0”处理
; 解决 方案一
mov bx,0
mov ax,[bx]
; 解决 方案二
mov ax,ds:[0]
```

比较一下汇编源程序中以下指令的含义。

- "mov al,[0]"，含义：(al)=0，将常量0送入al中（与 mov al,0含义相同）；
- "mov al,ds:[0]"，含义：(al)=((ds)*16+0)，将内存单元中的数据送入al中；
- "mov al,[bx]"，含义：(al)=((ds)*16+(bx))，将内存单元中的数据送入al中；
- "mov al,ds:[bx]"，含义：与 mov al,[bx] 相同



### 6. loop和[bx]的联合应用

考虑这样一个问题，**计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中。**

我们还是先分析一下

（1）运算后的结果是否会超出dx所能存储的范围？

ffff:0~ffff:b 内存单元中的数据是字节型数据，范围在0-255之间，12个这样的数据相加，结果不会大于65535，可以在dx中存放下。

（2）我们能否将 ffff:0~ffff:b 中的数据直接累加到dx中？

当然不行，因为 ffff:0~ffff:b 中的数据是8位的，不能直接加到16位寄存器dx中

（3）我们能否将 ffff:0~ffff:b 中的数据累加到dl中，并设置(dh)=0，从而实现累加到dx中？

这也不行，因为dl是8位寄存器，能容纳的数据的范围在0-255之间， ffff:0~ffff:b 中的数据也都是8位，如果仅向dl中累加12个8位数据，很有可能造成进位丢失。

> 即：dl只有8位， ffff:0~ffff:b 累积和可能超过了8位；如果直接加到 dl 会造成进位丢失；

（4）我们到底怎样将 ffff:0~ffff:b 中的8位数据，累加到16位寄存器dx中？

从上面的分析中，可以看到，这里面有两个问题：类型的匹配和结果的不超界。具体的说，就是在做加法的时候，我们有两种方法：

- (dx) = (dx) + 内存中的8位数据；
- (dl) = (dl) +内存中的8位数据。

**第一种方法中的问题是两个运算对象的类型不匹配，第二种方法中的问题是结果有可能超界。**

> 怎样解决这两个看似矛盾的问题？目前的方法（在后面的课程中我们还有别的方法）就是得用一个16位寄存器来做中介。
>
> 将内存单元中的8位数据赋值到一个16位寄存器ax中的al中，再将ax中的数据加到dx上，从而使两个运算对象的类型匹配并且结果不会超界。

```asm
assume cs:codesg
codesg segment
	mov ax,0ffffh
	mov ds,ax		; 初始化数据段
	mov dx,0		; 初始化累加器
	
	; 累加 0号内存单元数据
	mov al,ds:[0]	; 将 ds:[0] 号内存单元的字节型数据 赋值到寄存器al中
	mov ah,0		; ah置零，保证ax与 ds:[0] 字节型数据值一致
	add dx,ax		; 将ax数据累加到dx中
	; 累加 1号内存单元数据
	mov al,ds:[0]	
	mov ah,0		
	add dx,ax	
    
    ; ... 累加到 ds:[0bH]
    ; 程序返回...
    
codesg ends
end
```

> 问题：程序过于冗余，过长

**用 loop 改进**

从程序中可以看出冗余代码如下：

```asm
mov al,ds:[X]	; ds:X 指向 ffff:X单元
mov ah,0			
add dx,ax		
```

我们可以看到，只有偏移量始终在自增1的变化。变化范围为：0 ≤ X ≤ bH。

所以我们可以将偏移量放在 bx 寄存器中，不断自增bx，从而实现偏移量的自增

```asm
assume cs:codesg
codesg segment
	mov ax,0ffffh
	mov ds,ax		
	mov bx,0		; 初始化数据段 ds:bx 指向 ffff:0
	
	mov dx,0		; 初始化累加器
	mov cx,12		; 初始化循环次数，编译器默认为10进制，为啥不用变化的cx作为偏移量？因为偏移量只能用bx表示。即：只能 [bx]，不能 [cx]、[dx]等
	
	; 累加 0号内存单元数据
s:	mov al,[bx]		; 将 ds:[bx] 号内存单元的字节型数据 赋值到寄存器al中
	mov ah,0		; ah置零，保证ax与 ds:[0] 字节型数据值一致
	add dx,ax		; 将ax数据累加到dx中
	
    inc bx			; bx自增即偏移量自增
    loop s

    ; 程序返回...
codesg ends
end
```

> 为啥不用 [cx] ?因为只让用 [bx]



### 7. 段前缀

这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的 “ds:“、”cs:“、”ss:“、“es:”，在汇编语言中称为**段前缀**

（1）mov ax,ds:[bx]                   (这里的 ds 就是段前缀)  

将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址在bx中，段地址在ds中。

（2）mov ax,cs:[bx]					(段前缀：cs)  

将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址在bx中，段地址在cs中。

（3）mov ax,ss:[0]					(段前缀：ss)  

将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为0，段地址在ss中

> 如果：mov ax,[0]    默认段前缀为 ds ，不过编译器识别不出来



### 8. 一段安全的空间

在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。比如下面的指令：

```asm
mov ax,1000h
mov ds,ax
mov al,0
mov ds:[0],al	; 向内存中 1000:0 位置写入0
```

> 如果 1000:0 中存放着重要的系统数据或代码，"mov ds:[0],al"将其改写，将引发错误

```asm
; 这段汇编指令 会报错 触碰了系统数据
assume cs:codesg
codesg segment

    mov ax,0
    mov ds,ax
    mov ds:[26h],ax ; 将内存 0:26h 位置处设置为0

    mov ax,4c00h
    int 21h

codesg ends
end
```

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211221145549096.webp" alt="image-20211221145549096" style="zoom:67%;" />

> 图5.18中，我们可以看到，源程序中的“mov ds:[26h],ax” 被masm翻译为机器码“a3 26 00”，而  Debug将这个机器码解释为“mov [0026],ax”。
>
> 可见，汇编源程序中的汇编指令“mov ds:[26h],ax”和  Debug中的汇编指令“mov [0026],ax”同义。

可见，在不能确定一段内存空间中是否存放着重要的数据或代码的时候，不能随意向其中写入内容。

我们是在操作系统的环境中工作，操作系统管理所有的资源，也包括内存。如果我们需要向内存空间写入数据的话，要使用操作系统给我们分配的空间，而不应直接用地址任意指定内存单元，向里面写入。

但是，我们正在学习的是汇编语言，要通过它来获得底层的编程体验，理解计算机底层的基本工作机理。所以我们尽量直接对硬件编程，而不去理会操作系统。

> 纯dos环境(实模式)下，没有被保护，可以随意更改，但现在的系统，硬件已被操作系统利用cpu保护模式所提供的功能全面而严格的管理了

我们需要直接向内存中写入内容，可我们又不希望触碰到系统数据。所以要找到一段安全的空间供我们使用。在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用 **0:200 - 0:2ff (00200h - 002ffh)**的256个字节的空间。所以，我们使用**这段空间是安全的**。

#### 总结

（1）我们需要直接向一段内存中写入内容；

（2）这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误；

（3）DOS方式下，一般情况，0:200-0:2ff 空间中没有系统或其他程序的数据或代码；

（4）以后，我们需要直接向一段内存中写入内容时，就使用 0:200 - 0:2ff 这段空间。



### 9. 段前缀的使用

我们考虑一个问题，**将内存 ffff:0-ffff:b 单元中的数据复制到 0:200-0:20b 单元中。**

分析一下。

（1）**0:200-0:20b 单元等同于 0020:0-0020:b单元**，它们描述的是同一段内存空间。

（2）复制的过程应用循环实现，需要用一个寄存器作为中转。

（3）在循环中，源始单元 ffff:X 和目标单元 0020:X 的偏移地址 X 是变量。我们用bx来存放

（4）将0:200-0:20b用0020:0-0020:b描述，就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值0开始

```asm
assume cs:codesg
codesg segment

    ; 将 ffff:0-ffff:b 拷贝到 0020:0-0020:b
    mov bx,0        ; 偏移地址
    mov cx,12       ; 循环次数

s:  mov ax,0ffffh
    mov ds,ax       ; 定义源数据段，即将哪里的数据拷贝
    mov dl,[bx]     ; (dl) = ((ds)*16+(bx)) 将 ffff:[bx]中的数据送入dl
    
    mov ax,0020h 
    mov ds,ax       ; 定义目标数据段，即将数据拷贝到哪里
    mov [bx],dl     ; ((ds)*16+(bx)) = (dl)，将 dl 中的数据送入 0020:[bx]

    ; 开始循环
    inc bx
    loop s

    ; 程序返回
    mov ax,4c00h
    int 21h

segment ends
end
```

> 因源始单元 ffff:X 和目标单元 0020:X 相距大于64KB，在不同的64KB段里，程序5.8中，每次循环要设置两次ds。这样做是正确的，但是效率不高。
>
> 我们可以使用两个段寄存器分别存放源始单元 ffff:X 和目标单元 0020:X 的段地址

**改进**

```asm
assume cs:codesg
codesg segment
; 将 ffff:0-ffff:b 拷贝到 0020:0-0020:b
	mov ax,0ffffh
    mov ds,ax		; 定义源数据段，即，将哪里的数据拷贝
    
    mov ax,0020h 
    mov es,ax		; 定义目标数据段，即，将数据拷贝到哪里

    mov bx,0        ; 偏移地址
    mov cx,12       ; 循环次数

s:  mov dl,[bx]     ; (dl) = ((ds)*16+(bx)) 将 ffff:[bx]中的数据送入dl
    mov es:[bx],dl	; ((es)*16+(bx)) = (dl) 将 dl 中的数据送入 0020:[bx]

    ; 开始循环
    inc bx
    loop s

    ; 程序返回...
segment ends
end
```

> es：附加段
>
> 使用 es 存放目标空间 0020:0~0020:b 的段地址，用 ds 存放源始空间 ffff:0-ffff:b 的段地址。在访问内存单元的指令“mov  es:[bx],al”中，显式地用段前缀 ” es:“ 给出单元的段地址，这样就不必在循环中重复设置ds。





## 第六章 包含多个段的程序

在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间相冲突。在操作系统允许的情况下，程序可以取得任意容量的空间。

程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。在我们的课程中，不讨论第二种方法。

> 加载程序的时候为程序分配空间，我们在前面已经有所体验，比如我们的程序在加载的时候，取得了代码段中的代码的存储空间。
>
> 我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。**我们通过在源程序中定义段来进行内存空间的获取。**

**多个段的问题**

（1）在一个段中存放数据、代码、栈，我们先来体会一下不使用多个段时的情况；

（2）将数据、代码、栈放入不同的段中



### 1. 在代码段中使用数据

考虑这样一个问题，编程计算以下8个数据的和，结果存在ax寄存器中

0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h

> 我们希望用循环的方式进行累加，所以累加前，需要将这些数据存储在一组地址连续的内存单元
>
> 如何将这些数据存储在一组地址连续的内存单元中呢？我们可以用指令一个一个地将它们送入地址连续的内存单元中，可是这样又有一个问题，到哪里去找这段内存空间呢？
>
> 从规范的角度来讲，我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。我们可以在程序中，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的数据也就自然而然地获得了存储空间。

```asm
assume cs:code
code segment
	; 定义字型数据 在这里，使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节。
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	
	mov bx,0	
	mov ax,0
	mov cx,8

s:	add ax,cs:[bx]	; cs:[bx] 指向第一个数据所在的字单元
	add bx,2
	loop s
	
	; 程序返回...
code ends
end
```

> dw 定义字型数据；db 定义字节型数据

程序中的指令就要对这8个数据进行累加，可这8个数据在哪里呢？

由于它们在代码段中，程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。它们的偏移地址是多少呢？因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS:0、CS:2、CS:4、CS:6、CS:8、CS:A、CS:C、CS:E。

debug调试

![image-20211221211507678](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211221211507678.webp)

图6.1中，通过“DS=0B2D”，可知道程序从 0B3D:0000 开始存放。用u命令从 0B3D:0000 查看程序，却看到了一些让人读不懂的指令。

为什么没有看到程序中的指令呢？实际上用u命令从0B3D:0000看到的也是程序中的内容，只不过不是源程序中的汇编指令所对应的机器码，而是源程序中，在汇编指令前面，用dw定义的数据。实际上，在程序中，有一个代码段，在代码段中，前面的16个字节是用“dw”定义的数据，从第16个字节开始才是汇编指令所对应的机器码

可以用d命令更清楚地査看一下程序中前16个字节的内容，如图6.2所示。

![image-20211221212225968](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211221212225968.webp)

> 如图：从 0B3D:0010 开始，才是我们的汇编指令。从0B3D:0 10 都是我们用 "dw" 定义的数据
>
> 而此刻开始用t执行指令会把我们用 "dw"定义的数据当作指令执行，从而产生一些奇怪的结果。所以，我们需要将IP设置为 10h，从而使CS:IP真正指向我们编写的第一条汇编指令

怎么办？**在源程序中指明程序的入口所在**

```asm
assume cs:code
code segment
		dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	
start:	mov bx,0	
		mov ax,0
		mov cx,8

    s:	add ax,cs:[bx]	; cs:[bx] 指向第一个数据所在的字单元
        add bx,2
        loop s
	
		; 程序返回...
code ends
end start
```

我们在真正要执行的第一条汇编指令处，加上了标号“start”，而这个标号在伪指令end的后面出现。**end 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。**

在程序中我们用end指令指明了程序的入口在标号  start 处，也就是说，标记“mov bx,0”是程序的第一条指令。

> 指定程序入口，让cpu从程序入口开始读取，避免产生误读
>
> cpu去找的end，然后看见end后面有个start标号(实质会翻译成地址)

在单任务系统中，可执行文件中的程序执行过程如下。

（1）由其他的程序（Debug、command或其他程序）将可执行文件中的程序加载入内存

（2）设置CS:IP指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行

（3）程序运行结束后，返回到加载者。

> 现在的问题是，根据什么设置CPU的CS:IP指向程序的第一条要执行的指令？也就是说，如何知道哪一条指令是程序的第一条要执行的指令？
>
> 这一点，是由可执行文件中的描述信息指明的。我们知道可执行文件由描述信息和程序组成，程序来自于源程序中的汇编指令和定义的数据；描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息。我们在程序6.2中，用伪指令 end 描述了程序的结束和程序的入口。在编译、连接后，由 “end  start” 指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。
>
> 在程序6.2生成的可执行文件中，这个入口地址的偏移地址部分为10H。当程序被加载入内存之后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置CS:IP。这样CPU就从我们希望的地址处开始执行

归根结底，**我们若要CPU从何处开始执行程序，只要在源程序中用“end标号”指明就可以了。**

```asm
; 代码格式
assume cs:code
code segment
		...数据...
	
start:	
		...代码...
	
		; 程序返回...
code ends
end start
```



### 2. 在代码段中使用栈

利用栈，将程序中定义的数据逆序存放。

- dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h

程序运行时，定义的数据存放在 cs:0~cs:F 单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。

问题是，我们首先要有一段可当作栈的内存空间。如前所述，这段空间应该由系统来分配。可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。程序如下。

```asm
assume cs:codesg
codesg segment

		dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
		; 需要存入栈的数据 8个字
		dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		; 用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放着16个数据。在后面的程序中将这段空间当作栈来使用
		
start:	mov ax,cs
		mov ss,ax
		mov sp,30h		; 48(2*8+16*2) 设置栈顶ss:sp指向cs:30
		
		mov bx,0		; 偏移量
		mov cx,8		; 循环次数
		
	s:	push cs:[bx]	
		add bx,2
		loop s			; 以上将代码段0-15单元中的8个字型数据依次入栈
		
		; 第二个循环开始
		mov bx,0
		mov cx,8
		
	s0:	pop cs:[bx]
		add bx,2
		loop s0			; 以上依次出栈8个字型数据到代码段0-15单元中，从而达到逆序的效果
		
		; 程序返回...
codesg ends
end start
```

我们要将 cs:10-cs:2F 的内存空间当作栈来用，初始状态下栈为空，所以 ss:sp 要指向栈底，则设置 ss:sp 指向cs:30。

>在代码段中定义了16个字型数据，它们的数值都是0。我们用dw定义16个数据，即在程序中写入了16个字型数据，而程序在加载后，将用32个字节的内存空间来存放它们。
>
>这段内存空间是我们所需要的，程序将它用作栈空间。可见，我们定义这些数据的最终目的是，通过它们取得一定容量的内存空间。**所以我们在描述dw的作用时，可以说用它定义数据，也可以说用它开辟内存空间。**

dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h

可以说，定义了8个字型数据，也可以说，开辟了8个字的内存空间，这段空间中每个字单元中的数据依次是：0123h、0456h、0789h、0abch、defh、0fedh、0cbah、0987h。



### 3. 将数据、代码、栈放入不同的段(阐述源程序怎样被CPU执行)

在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做显然有两个问题：

（1）把它们放到一个段中使程序显得混乱；

（2）前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到段里面没有问题。但如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中（一个段的容量不能大于64KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样）。

所以，应该考虑**用多个段来存放数据、代码和栈。**

```asm
assume cs:code,ds:data,ss:stack		; code关联到cs段(代码段) data关联到ds段(数据段) stack关联ss段(栈段)

data segment	; 数据段开始
	; 数据段只用于存储数据
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends		; 数据段结束

stack segment	; 栈段开始
	; 栈段只用于栈空间
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	; 初始化栈空间 16个字=32字节=20h
stack ends		; 栈段结束

code segment	; 代码段开始
start:	mov ax,stack
		mov ss,ax
		mov sp,20h		; 设置栈顶ss:sp指向stack:20
		
		mov ax,data
		mov ds,ax		; ds指向data段
		mov bx,0		; ds:[bx]指向data段中的第一个单元
		
		mov cx,8
	s:	push [bx]
		add bx,2
		loop s			; 以上将data段中的0~15单元的8个字型数据依次入栈
		
		mov bx,0
		mov cx,8
	s0:	pop [bx]
		add bx,2
		loop s0			; 以上依次出栈8个字型数据到data段的0~15单元中 从而达到逆序效果
	
		; 程序返回
code ends		; 代码段结束
```

#### 说明

（1）定义多个段的方法

我们从程序中可明显地看出，定义一个段的方法和前面所讲的定义代码段的方法没有区别，只是对于不同的段，要有不同的段名。

（2）对段地址的引用

现在，程序中有多个段了，如何访问段中的数据呢？当然要通过地址，而地址是分为两部分的，即段地址和偏移地址。如何指明要访问的数据的段地址呢？在程序中，段名就相当于一个标号，它代表了段地址。

所以指令“mov  ax,data”的含义就是将名称为“data”的段的段地址送入ax。**一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了**。程序中“data”段中的数据“0abch”的地址就是：data:6。要将它送入bx中，就要用如下的代码

```asm
mov ax,data
mov ds,ax		; 注意：不能使用 mov ds,data   因为8086CPU不允许将一个数值直接送入段寄存器
				; 而 data 实际被编译器处理为一个表示段地址的数值
mov bx,ds:[6]
```

（3）“代码段”、“数据段”、“栈段”完全是我们的安排

我们定义了3个段 “code” 、”data“ 和 “stack” 。我们可以分别安排它们存放代码、数据和栈。那么我们如何让CPU按照我们的这种安排来执行这个程序呢？

① 分别对三个段命名；我们这样命名，仅仅是为了使程序便于阅读。这些名称同“start”、“s”、“s0”等标号一样，仅在源程序中存在，CPU并不知道它们。

② 我们在源程序中用伪指令 “assume  cs:code,ds:data,ss:stack” 将 cs、ds 和 ss 分别和 code、data、stack 段相连。这样做了之后，CPU是否就会将 cs 指向 code，ds 指向 data，ss 指向  stack，从而按照我们的意图来处理这些段呢？

当然不是，要知道 assume是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，CPU并不知道它们。

> assume：只要知道需要用它将自定义的段与相关寄存器相关联就行。

③ 若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是CPU要执行的内容。

CPU如何知道去执行它们？我们在源程序的最后用“end  start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令。标号”start“在”code“段中，这样CPU就将code段中的内容当作指令来执行了。我们在code段中，使用指令

```asm
mov ax,stack
mov ss,ax
mov sp,20h
```

设置ss指向 stack，设置ss:sp指向 stack:20，CPU执行这些指令后，将把 stack 段当做栈空间来用。CPU若要访问data段中的数据，则可用ds指向data段，用其他的寄存器（如bx）来存放data段中数据的偏移地址

**总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。**





## 第七章 更灵活的定位内存地址的方法

### 1. and和or指令

#### （1）and指令：逻辑与指令，按位进行与运算。

例如指令：

```asm
mov al,01100011B
and al,00111011B
; 执行后：al=00100011B
```

**通过该指令可将操作对象的相应位设为0，其他位不变。**

```asm
and al,10111111B	; 将al的第6位设为0的指令
and al,01111111B 	; 将al的第7位设为0的指令
and al,11111110B	; 将al的第0位设为0的指令
```



#### （1）or指令：逻辑或指令，按位进行或运算。

例如指令：

```asm
mov al,01100011B
or  al,00111011B
; 执行后：al=01111011B
```

**通过该指令可将操作对象的相应位设为1，其他位不变。**

```asm
and al,01000000B 	; 将al的第6位设为0的指令
and al,10000000B 	; 将al的第7位设为0的指令
and al,00000001B 	; 将al的第0位设为0的指令
```



### 2. 关于ASCII码(从键盘输入文本到屏幕展示的过程)

我们要把信息存储在计算机中，就要对其进行编码，将其转化为二进制信息进行存储。而计算机要将这些存储的信息再显示给我们看，就要再对其进行解码。只要编码和解码釆用同样的规则，我们就可以将人能理解的信息存入到计算机，再从计算机中取出。

一个文本编辑过程中，就包含着按照  ASCII 编码规则进行的编码和解码。在文本编辑过程中，我们按一下键盘的 a键，就会在屏幕上看到“a”。这是怎样一个过程呢？

我们按下键盘的 a 键，这个按键的信息被送入计算机，计算机用 ASCII 码的规则对其进行编码，将其转化为 61H 存储在内存的指定空间中；文本编辑软件从内存中取出 61H，将其送到显卡上的显存中；工作在文本模式下的显卡，用 ASCII 码的规则解释显存中的内容，61H 被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。

我们可以看到，显卡在处理文本信息的时候，是按照ASCII码的规则进行的。这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCII码，61H。如何提供？当然是写入显存中。



### 3. 以字符形式给出的数据

我们可以在汇编程序中，**用 '......' 的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码**。如下面的程序。

```asm
assume cs:code,ds:data
data segment
	db 'unIX'
	db 'foRK'
data ends

code segment
start:	mov al,'a'
		mov bl,'b'
code ends

end start
```

> db 'unIX' ：相当于 "db 75H,6EH,49H,58H"，"u" "n" "I" "X" 的ASCII码分别为 75H,6EH,49H,58H
>
> mov al,'a' ：相当于 "mov al,61H"，"a" 的ASCII码为 61H

![image-20211222142559115](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211222142559115.webp)

图7.1中，**先用r命令分析一下 data 段的地址，因“ds=0B2D”，所以程序从0B3DH段开始，data段又是程序中的第一个段，它就在程序的起始处，所以它的段地址为0B3DH。**

> 因为 ds与源程序的第一条指令相差了10h，这10h是PSP；
>
> 因为end指定了程序入口，所以CS指向的不是源程序第一条指令，源程序的第一条指令其实是开辟数据段

用 d 命令查看 data 段，Debug以十六进制数码和 ASCII 码字符的形式显示出其中的内容，从中，可以看出 data 段中的每个数据所对应的 ASCII 字符。



### 4. 大小写转换的问题(用位进行转换)

下面考虑这样一个问题，在 codesg 中填写代码，将 datasg 中的第一个字符串转化为大写，第二个字符串转化为小写。

```asm
assume cs:codesg,ds:datasg

datasg segment
	db 'BaSiC'
	db 'iNfOrMaTiOn'
datasg ends

codesg segment
start:	;
codesg ends

end start
```

> **ASCII码表中：小写字母 - 20h(32) = 大写字母**

所以在进行大小写转换时，我们必须要判断 一个字母是大写还是小写

> C语言的判断方式：if (letter >= 'a' && letter<='z')   或者将字符翻译成 十进制的写法

```asm
assume cs:codesg,ds:datasg

datasg segment
	db 'BaSiC'
	db 'iNfOrMaTiOn'
datasg ends

codesg segment
start:	mov ax,datasg
		mov ds,ax
		mov bx,0		; 定位到数据段
		
		mov cx,5		; 循环次数
	s:	mov al,[bx]		; 将每个字符取出到al中
	
		; 进行判断，如果 (al)>61H，则为小写字母的ASCII码，则：sub al,20H
		; 由于我们定义的都是字母 不是大写就是小写
		
		mov [bx],al		; 将转换后的字母重新送入原位置
		
		inc bx
		loop s
codesg ends

end start
```

> 如果想判断，则需要用到没学过的指令，所以 使用**大写字母+20H=小写字母**暂时不适用。我们需要找到新的规则
>
> 其实就是不想这么快讲新指令

```properties
A	41h		0100 0001			B	42h		0100 0010
a	61h		0110 0001			b	62h		0110 0010
```

我们应该重新观察，寻找新的规律。可以看出，**就ASCI码的二进制形式来看，除第5位（位数从 0 开始计算）外，大写字母和小写字母的其他各位都一样。大写字母 ASCII 码的第5位为0，小写字母的第5位为1**。

这样，我们就有了新的方法，**一个字母，不管它原来是大写还是小写，将它的第5位置0，它就必将变为大写字母；将它的第5位置1，它就必将变为小写字母。在这个方法中，我们不需要在处理前判断字母的大小写**。

比如：对于 “Basic” 中的“B”，按要求，它已经是大写字母了，不应进行改变，将它的第5位设为0，它还是大写字母，因为它的第5位本来就是0

用什么方法将一个数据中的某一位置0还是置1？当然是用我们刚刚学过的or和and指令。

```asm
assume cs:codesg,ds:datasg

datasg segment
	db 'BaSiC'
	db 'iNfOrMaTiOn'
datasg ends

codesg segment
start:	mov ax,datasg
		mov ds,ax
		mov bx,0		; 定位到数据段，bx指向 'BaSic'的第一个字母
		
		mov cx,5		; 循环5次，因为'BaSic'有5个字母
	s:	mov al,[bx]		; 将每个字符取出到al中
		; 进行大小写的转换
		and al,11011111B	; 将al中的ASCII码的第5位置0，转为大写字母，从0开始计数
		mov [bx],al		; 将转换后的字母重新送入原位置
		
		inc bx
		loop s
		
		mov bx,5	;设置bx=5，ds:bx指向'iNfOrMaTiOn'的第一个字母
		mov cx,11
	s0:	mov al,[bx]
		or al,00100000B		; 将al中的ASCII码的第5位置1，变成小写字母
		mov [bx],al
		inc bx
		loop s0
codesg ends

end start
```



### 5. [bx+idata]

在前面，我们用[bx]的方式来指明一个内存单元，还可以用一种更为灵活的方式来指明内存单元：**[bx+idata] 表示一个内存单元，它的偏移地址为 ()+idata(bx中的数值加上idata)**

我们看一下指令 mov ax,[bx+200] 的含义：

将一个内存单元的内容送入ax，这个内存单元的长度为2个字节（字单元），存放一个字，偏移地址为：bx中的数值加上200，段地址在ds中。即：(ax) = ((ds)*16 +(bx) +200)

该指令也可以写成如下格式（常用）：

- mov ax,[200+bx]	(不能 mov [bx],[200+bx] 这么使用)
- mov ax,200[bx]
- mov ax,[bx].200

#### 问题

用Debug查看内存：结果：2000:1000   BE 00 06 00 00 00 ...

写出程序指向后，ax bx cx 中的内容

```asm
mov ax,2000h	; ax=2000h
mov ds,ax
mov bx,1000h	; bx=1000h ds:bx指向了 2000:1000

mov ax,[bx]		; ax=00beh
mov cx,[bx+1]	; cx=0600h
add cx,[bx+2]	; cx=0606h ds:[bx+2]=0006h
```



### 6. 用 [bx+idata] 的方式进行数组的处理

有了 [bx+ idata] 这种表示内存单元的方式，我们就可以用更高级的结构来看待所要处理的数据。我们通过下面的问题来理解这一点。

在 codesg中填写代码，将 datasg中定义的第一个字符串转化为大写，第二个字符串转化为小写。

```asm
assume cs:codesg,ds:datasg
; 原来的办法
datasg segment
	db 'BaSiC'
	db 'MinIX'
datasg ends

codesg segment
start:	mov ax,datasg
		mov ds,ax
		mov bx,0		; 定位到数据段，bx指向 'BaSic'的第一个字母
		
		mov cx,5		; 循环5次，因为'BaSic'有5个字母
	s:	mov al,[bx]		; 将每个字符取出到al中
		; 进行大小写的转换
		and al,11011111B	; 将al中的ASCII码的第5位置0，转为大写字母，从0开始计数
		mov [bx],al		; 将转换后的字母重新送入原位置
		
		inc bx
		loop s
		
		mov bx,5	;设置bx=5，ds:bx指向'iNfOrMaTiOn'的第一个字母
		mov cx,5
	s0:	mov al,[bx]
		or al,00100000B		; 将al中的ASCII码的第5位置1，变成小写字母
		mov [bx],al
		inc bx
		loop s0
codesg ends

end start
```

现在，我们有了 [bx+data] 的方式，就可以用更简化的方法来完成上面的程序。

观察 datasg 段中的两个字符串，一个的起始地址为0，另一个的起始地址为5。我们可以将这两个字符串看作两个数组，一个从0地址开始存放，另一个从5开始存放。

那么我们可以用 [0+bx] 和 [5+bx] 的方式在同一个循环中定位这两个字符串中的字符。在这里，0 和 5 给定了两个字符串的起始偏移地址，bx 中给岀了从起始偏移地址开始的相对地址。这两个字符串在内存中的起始地址是不一样的，但是，它们中的每一个字符，从起始地址开始的相对地址的变化是相同的。改进的程序如下。

```asm
codesg segment
start:	mov ax,datasg
		mov ds,ax
		mov bx,0		; 定位到数据段，bx指向 'BaSic'的第一个字母
		
		mov cx,5		; 循环5次，因为'BaSic'有5个字母
	s:	mov al,[bx]		; 定位第一个字符串中的字符
		; 或 mov al,0[bx]
		and al,11011111B	; 将al中的ASCII码的第5位置0，转为大写字母，从0开始计数
		mov [bx],al		; 将转换后的字母重新送入原位置
		
		mov al,[5+bx]	; 定位第二个字符串中的字符
		; 或 mov al,5[bx]
		or al,00100000B		; 将al中的ASCII码的第5位置1，变成小写字母
		mov [5+bx],al
		
		inc bx
		loop s
codesg ends
```

如果用高级语言，比如C语言来描述上面的程序，大致是这样的：

```c
char a[5] = "BaSiC";
char a[5] = "MinIX";
int i=0;
do{
    a[i] = a[i] & 0xDF;
    b[i] = b[i] | 0x20;
    i++
}while(i < 5);
```

> 对比一下：C语言：a[i], b[i]    	汇编语言：0[bx], 5[bx]



### 7. SI 和 DI

si 和di 是8086CPU中和 bx 功能相近的寄存器，**si 和 di 不能够分成两个8位寄存器来使用**。下面的3组指令实现了相同的功能。

1. mov bx,0						mov bx,0

   mov ax,[bx]					mov ax,[bx+123]

2. mov si,0						  mov si,0

   mov ax,[si]					  mov ax,[si+123]

3. mov di,0						  mov di,0

   mov ax,[di]					  mov ax,[di+123]

#### 问题

用 si 和 di 实现将字符串 'welcome to masm！' 复制到它后面的数据区中。

我们编写的程序大都是进行数据的处理，而数据在内存中存放，所以我们在处理数据之前首先要搞清楚数据存储在什么地方，也就是说数据的内存地址。

现在我们要对  datasg 段中的数据进行复制，先来看一下要复制的数据在什么地方，datasg:0，这是要进行复制的数据的地址。那么复制到哪里去呢？它后面的数据区。“welcome  to  masm！”从偏移地址0开始存放，长度为16个字节，所以，它后面的数据区的偏移地址为16，就是字符串 "................." 存放的空间。

清楚了地址之后，我们就可以进行处理了。我们用 ds:si 指向要复制的源始字符串，用 ds:di 指向复制的目的空间，然后用一个循环来完成复制。代码段如下。

```asm
assume cs:codesg,ds:datasg

datasg segment
	db 'welcome to masm！'
	db '.................'
datasg ends

codesg segment
start:	mov ax,datasg	; 指向数据段
		mov ds,ax		
		mov si,0		; 源
		mov di,16		; 目的地 编译器默认为10进制
		
		mov cx,8	; 用16位寄存器进行内存单元之间的数据传送，一次复制2个字节，所以只需循环8次。
	s:	mov ax,[si]
		mov [di],ax
		add si,2
		add di,2
		loop s
codesg ends
end start
```

简化：我们可以利用 [bx(si或di) + idata] 的方式，来使程序变得简洁。

```asm
codesg segment
start:	mov ax,datasg	; 指向数据段
		mov ds,ax		
		mov si,0		; 数组下标
		
		mov cx,8	; 用16位寄存器进行内存单元之间的数据传送，一次复制2个字节，所以只需循环8次。
	s:	mov ax,0[si]
		mov 16[si],ax
		add si,2
		loop s
codesg ends
```



### 8. [bx+si] 和 [bx+di]

在前面，我们用 [bx(si或di)] 和 [bx(si或di) + idata] 的方式来指明一个内存单元，我们还可以用更为灵活的方式:[bx+si] 和 [bx+di] 

[bx+si] 和 [bx+di] 的含义相似，我们以 [bx+si] 为例进行讲解.

 **[bx+si] 表示一个内存单元，它的偏移地址为 (bx)+(si) ，即 bx 中的数值加上 si 中的数值**

> mov ax,[bx+si] ：将一个内存单元的内容送入ax，这个内存单元长度2字节(一个字)，偏移地址为 (ds)+(si)，段地址在 ds 中。(ax) = ((ds)*16 +(bx) +(si))
>
> **该指令也可以写成如下格式（常用）：mov ax,[bx]\[si]**

#### 问题

用Debug查看内存：结果：2000:1000   BE 00 06 00 00 00 ...

写出程序指向后，ax bx cx 中的内容

```asm
mov ax,2000h	; ax=2000h
mov ds,ax
mov bx,1000h	; bx=1000h ds:bx指向了 2000:1000

mov si,0		; si=0
mov ax,[bx+si]	; ax = (bx+si) = 2000:1000 = 00be
inc si			; si=1

mov cx,[bx+si]	; cx =(2001) 0600h
inc si			; si=2
mov di,si		; di=2
add cx,[bx+di]	; cx=0606h, ds:[bx+di]=0006h
```



### 9. [bx+si+idata] 和 [bx+di+idata]\(结果跟书有点不匹配)

[bx+si+idata] 和 [bx+di+ idata] 的含义相似，我们以 [bx+si+ idata] 为例进行讲解。

[bx+si+ idata] 表示一个内存单元，它的偏移地址为 (bx) +(si)+idata。

> 指令 mov ax,[bx+si+idata] : 将一个内存单元的内容送入ax，这个内存单元长度2字节(一个字)，偏移地址为 (ds)+(si)+idata，段地址在 ds 中。(ax) = ((ds)*16 +(bx) +(si) +idata)
>
> 该指令也可以写成如下格式（常用）：
>
> - mov ax,[bx+200+si]
> - mov ax,[200+bx+si]
> - mov ax,200[bx]\[si]
> - mov ax,[bx].200[si]
> - mov ax,[bx]\[si].200

#### 问题

用Debug查看内存：结果：2000:1000   BE 00 06 00 6A 22 ...

写出程序指向后，ax bx cx 中的内容

```asm
mov ax,2000h	; ax=2000h
mov ds,ax
mov bx,1000h	; bx=1000h ds:bx指向了 2000:1000

; 0	 1  2  3
; BE 00 06 00
mov si,0			; si=0
mov ax,[bx+2+si]	; ax=(bx+si+2) = 2000:1002 = 0006h  当定位到2位置取字型，2位置是低位3位置是高位
inc si				; si=1

mov cx,[bx+2+si]	; cx = 2000:1003 = 6A00h
inc si				; si=2
mov di,si			; di=2
add bx,[bx+2+di]	; bx=(bx+2+di)=(2004)=2000:2004=226Ah
```



### 10. 不同的寻址方式的灵活应用

如果我们比较一下前面用到的几种定位内存地址的方法（可称为寻址方式），就可以发现：

- （1）[idata] 用一个常量来表示地址，可用于直接定位一个内存单元
- （2）[bx] 用一个变量来表示内存地址，可用于间接定位一个内存单元；
- （3）[bx+  idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；
- （4）[bx+si] 用两个变量表示地址；
- （5）[bx+  si + idata] 用两个变量和一个常量表示地址。

#### 问题

编程，将 datasg 段中每个单词的头一个字母改为大写字母。

```asm
assume cs:codesg,ds:datasg

datasg segment
	db '1. file			'
	db '2. edit			'
	db '3. search		'
	db '4. view			'
	db '5. options		'
	db '6. help			'
datasg ends

codesg segment
start:	mov ax,datasg
		mov ds,ax
		
		mov bx,0
		mov cx,6
		
	s:	mov al,[bx+3]	; 因为每个字母都是一个字节
		and al,11011111b	; 将5号位置置0，转大写
		mov [bx+3],al	; 将大写字母重新写回
		
		add bx,10h		; 跳到下一行，因为每行大小为16字节
		loop s
codesg ends

end start
```

> 在  datas中定义了6个字符串，每个长度为16个字节（注意，为了直观，每个字符串的后面都加上了空格符，以使它们的长度刚好为16个字节）。因为它们是连续存放的，可以将这6个字符串看成一个6行16列的二维数组。
>
> 按照要求，需要修改每一个单词的第一个字母，即二维数组的每一行的第4列（相对于行首的偏移地址为3）

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211222164559125.webp" alt="image-20211222164559125" style="zoom: 67%;" />

我们需要进行6次循环，用一个变量R定位行，用常量3定位列。处理的过程如下

```properties
	R = 第一行的地址
	mov cx,6	; 循环次数
s:	改变R行，3列的字母为大写
	R = 下一行的地址
	loop s
```

我们用bx作变量，定位每行的起始地址，用3定位要修改的列，用 [bx+ idata] 的方式来对目标单元进行寻址。



#### 问题

编程，将 datas段中每个单词改为大写字母

```asm
assume cs:codesg,ds:datasg

datasg segment
	db 'ibm			'
	db 'dec			'
	db 'dos			'
	db 'vax			'
datasg ends

codesg segment
start:	mov ax,datasg
		mov ds,ax
		
		mov bx,0	; 行
		mov cx,4
		
	s0:	mov si,0	; 列
		mov cx,3	; 问题：子循环中的cx 会替代外层循环的cx 且cx会一直减少。相当于外层定义的cx没起作用
		
	s:	mov al,[bx+si]	; 第 bx 行 第 si 列
		and al,11011111b	; 将5号位置置0，转大写
		mov [bx+si],al	; 将大写字母重新写回
		inc si		; 列++
		loop s
		
		add bx,10h		; 行++ 跳到下一行，因为每行大小为16字节 
		loop s0
codesg ends

end start
```

> 在 datas中定义了4个字符串，每个长度为16个字节。因为它们是连续存放的，我们可以将这4个字符串看成一个4行16列的二维数组。
>
> 按照要求，我们需要修改每一个单词，即二维数组的每一行的前3列。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211222165609551.webp" alt="image-20211222165609551" style="zoom:67%;" />

我们需要进行 4×3 次的二重循环，用变量 R 定位行，变量 C 定位列。外层循环按行来进行，内层按列来进行。

首先用 R 定位第 1 行，然后循环修改 R 行的前 3 列；然后再用 R 定位到下一行，再次循环修改 R 行的前 3 列......，如此重复直到所有的数据修改完毕。处理的过程大致如下

```asm
	R = 第一行的地址
	mov cx,4
s0:	C = 第一列的地址
	mov cx,3
s:	改变R行，C列的字母为大写
	C = 下一列的地址
	loop s
	R = 下一行的地址
	loop s0
```

我们用 bx 来作变量，定位每行的起始地址，用 si 定位要修改的列，用 [bx+si] 的方式来对目标单元进行寻址，

#### 问题

仔细阅读上面的程序，看看有什么问题？

问题在于 cx 的使用，我们进行二重循环，却只用了一个循环计数器，造成在进行内层循环的时候，覆盖了外层循环的循环计数值。多用一个计数器又不可能，因为loop指令默认 cx 为循环计数器。怎么办呢？

> 我们应该在每次开始内层循环的时候，将外层循环的cx中的数值保存起来，在执行外层循环的loop指令前，再恢复外层循环的cx数值。可以用寄存器dx来临时保存cx中的数值，改进的程序如下。

```asm
codesg segment
start:	mov ax,datasg
		mov ds,ax
		
		mov bx,0	; 行
		mov cx,4
		
	s0:	mov dx,cx	; 将外层循环的cx值保存在dx中
		mov si,0	; 列
		mov cx,3	; 问题：子循环中的cx 会替代外层循环的cx 且cx会一直减少。相当于外层定义的cx没起作用
		
	s:	mov al,[bx+si]	; 第 bx 行 第 si 列
		and al,11011111b	; 将5号位置置0，转大写
		mov [bx+si],al	; 将大写字母重新写回
		inc si		; 列++
		loop s
		
		add bx,10h		; 行++ 跳到下一行，因为每行大小为16字节 
		mov cx,dx		; 用dx中存放的外层循环的计数值恢复cx
		loop s0
codesg ends
```

如果，这些寄存器全部已经被使用了，这个 cx 如何保存？我们在这里讨论的问题是，程序中经常需要进行数据的暂存，怎样做将更为合理。

显然，我们不能选择寄存器(因为CPU中寄存器个数是有限的)，那么可以使用的就是内存了。**可以考虑将需要暂存的数据放到内存单元中，需要使用的时候，再从内存单元中恢复**。这样我们就需要开辟一段内存空间。再次改进的程序如下。

```asm
assume cs:codesg,ds:datasg

datasg segment
	db 'ibm			'
	db 'dec			'
	db 'dos			'
	db 'vax			'
	dw	0	; 定义一个字，用来暂存cx
datasg ends

codesg segment
start:	mov ax,datasg
		mov ds,ax
		
		mov bx,0	; 行
		mov cx,4
		
	s0:	mov ds:[40h],cx	; 将外层循环的cx值保存在 datasg:40H单元中
		mov si,0	; 列
		mov cx,3	; 问题：子循环中的cx 会替代外层循环的cx 且cx会一直减少。相当于外层定义的cx没起作用
		
	s:	mov al,[bx+si]	; 第 bx 行 第 si 列
		and al,11011111b	; 将5号位置置0，转大写
		mov [bx+si],al	; 将大写字母重新写回
		inc si		; 列++
		loop s
		
		add bx,10h		; 行++ 跳到下一行，因为每行大小为16字节 
		mov cx,ds:[40h]	; 用 datasg：40H单元中的值恢复cx
		loop s0
codesg ends

end start
```

上面的程序中，用内存单元来保存数据，可是上面的做法却有些麻烦，因为如果需要保存多个数据的时候，你必须要记住数据放到了哪个单元中，这样程序容易混乱。

我们使用内存来暂存数据，我们用怎样的结构来保存这些数据，而使得我们的程序更加清晰。**一般来说，在需要暂存数据的时候，我们都应该使用栈**。下面，再次改进我们的程序。

```asm
assume cs:codesg,ds:datasg,ss:stacksg

datasg segment
	db 'ibm			'
	db 'dec			'
	db 'dos			'
	db 'vax			'
datasg ends

stacksg segment		; 定义一个段，用来做栈段，容量为16个字节
	dw 0,0,0,0,0,0,0,0
stacksg ends

codesg segment
start:	mov ax,datasg
		mov ds,ax
		
		mov ax,stacksg
		mov ss,ax
		mov sp,16
		
		mov bx,0	; 行
		mov cx,4
		
	s0:	push cx		; 将外层循环的cx值压栈
		mov si,0	; 列
		mov cx,3	; 问题：子循环中的cx 会替代外层循环的cx 且cx会一直减少。相当于外层定义的cx没起作用
		
	s:	mov al,[bx+si]	; 第 bx 行 第 si 列
		and al,11011111b	; 将5号位置置0，转大写
		mov [bx+si],al	; 将大写字母重新写回
		inc si		; 列++
		loop s
		
		add bx,10h		; 行++ 跳到下一行，因为每行大小为16字节 
		pop cx			; 从栈顶弹出原cx的值，恢复cx
		loop s0
codesg ends

end start
```

#### 问题

编程，将 datasg 段中每个单词的前4个字母改为大写字母。

```asm
assume cs:codesg,ss:stacksg,ds:datasg

stacksg segment
	dw 0,0,0,0,0,0,0,0
stacksg ends

datasg segment	; 注意：一定要以空格补齐16个字节的位置 不然结果可能与预想的不对
	db '1. display      '
	db '2. brows        '
	db '3. replace      '
	db '4. modify       '
datasg ends

codesg segment
		; 初始栈段
start:	mov ax,stacksg
		mov ss,ax
		mov sp,16	; 编译器默认10进制 定义的栈大小为16字节
		; 初始数据段
		mov ax,datasg
		mov ds,ax
		mov bx,0	; 定位到第0行
		
		mov ax,0	; 清空ax
		mov cx,4
		; 使用双重循环 第一重循环定位要改的行 第二重循环定位要改的列
		; 保存一下外层循环的cx
	s0:	push cx
		
		mov cx,4	; 列循环4次，因为只需要改单词的前4个字母
		mov si,0	; 列索引
		; 先定位到要改的把
	s:	mov al,[bx+si+3]	; 因为3号位置才是单词的首字母
		and al,11011111b	; 变大写
		mov [bx+si+3],al	; 将变为大写的字母 重新写回去
		inc si
		loop s
		
		add bx,10h			; bx需要指向下一行
		pop cx				; 取出外层循环次数 恢复到cx
		loop s0
codesg ends

end start
```

我们可以将 datasg 看作是一个 4行16列的二维数组，据题意，我们需要修改每个单词的前4个字母，即二维数组的每一行的3~6列

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211222220134354.webp" alt="image-20211222220134354" style="zoom:67%;" />

我们需要进行 4×4 次的二重循环，用变量 R 定位行，常量 3 定位每行要修改的起始列，变量 C 定位相对于起始列的要修改的列。

外层循环按行来进行，内层按列来进行。我们首先用 R 定位第1行，循环修改 R 行的 3+C(0≤C≤3) 列；然后再用 R 定位到下行，再次循环修改 R 行的 3+C(0≤C≤3) 列如此重复直到所有的数据修改完毕。

```asm
	R = 第一行的地址
	mov cx,4
s0:	C = 第一个要修改的列相对于起始列的地址
	mov cx,4
s:	改变 R 行，3+C 列的字母为大写
	C = 下一个要修改的列相对于起始列的地址
	loop s
	R = 下一行的地址
	loop s0
```

我们用 bx 来作变量，定位每行的起始地址，用 si 定位要修改的列，用 [bx+3+si] 的方式来对目标单元进行寻址。

**debug检验**

首先，段空间开始的位置于：原始ds+100h(psp=100h)，这里原始ds=203d，所以段空间开始于 204d。用d命令查看一下

![image-20211222222402760](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211222222402760.webp)

结果

![image-20211222223545981](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211222223545981.webp)

> 注意：初始化数据段时，一定要保证是16个字节，补位给补上；不然结果可能不是预期的





## 第八章 数据处理的两个基本问题

计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中

（1）处理的数据在什么地方？

（2）要处理的数据有多长？

我们定义的描述性符号：reg 和 sreg 。

为了描述上的简洁，在以后的课程中，我们将使用两个描述性的符号**reg来表示一个寄存器，用sreg表示一个段寄存器。**

reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di

sreg的集合包括：ds、ss、cs、es。

### 1. bx、si、di和bp

（1）在8086PU中，只有这4个寄存器可以用在“[...]”中来进行内存单元的寻址。比如下面的指令都是正确的

```asm
mov ax, bx 
mov ax, [bx+si]
mov ax, [bx+di]
mov ax, [bp]
mov ax, [bp+si]
mov ax, [bp+di]
```

而下面的指令是错误的：

```asm
mov ax,[cx]	; 错误
mov ax,[ax]	; 错误
mov ax,[dx]	; 错误
mov ax,[ds]	; 错误
```

（2）在 [...] 中，这4个寄存器可以**单个出现**，或只能以**4种组合出现**：bx 和 si、bx和di、bp和si、bp和di。比如下面的指令是正确的

```asm
mov ax, [bx]
mov ax, [si]
mov ax, [di]
mov ax, [bp]
mov ax, [bx+si]
mov ax, [bx+di]
mov ax, [bp+si]
mov ax, [bp+di] 
mov ax, [bx+si+idata] 
mov ax, [bx+di+idata] 
mov ax, [bp+si+idata] 
mov ax, [bp+di+idata]
```

下面的指令是错误的：

```asm
mov ax,[bx+bp]	; 错误
mov ax,[si+di]	; 错误
```

（3）只要在 [...] 中使用寄存器 bp，而指令中没有显性地给出段地址，段地址就默认在 ss 中。比如下面的指令。

```asm
mov ax,[bp] 			; 含义: (ax)=((ss)*16+(bp))
mov ax,[bp+idata] 		; 含义: (ax)=((ss)*16+(bp)+ idata)
mov ax,[bp+si] 			; 含义: (ax)=((ss)*16+(bp)+(si))
mov ax,[bp+si+idata]	; 含义: FX:(ax)=((ss)*16+(bp)+(si)+idata)
```



### 2. 机器指令处理的数据在什么地方

绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：**读取、写入、运算**。在机器指令这一层来讲，并不关心数据的值是多少，而关心**指令执行前一刻，它将要处理的数据所在的位置**。指令在执行前，所要处理的数据可以在3个地方：**CPU内部、内存、端口**（端口将在后面的课程中进行讨论），比如表8.1中所列的指令。

![image-20211222232813181](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211222232813181.webp)



### 3. 汇编语言中数据位置的表达

在汇编语言中如何表达数据的位置？汇编语言中用3个概念来表达数据的位置。

#### （1）立即数（idata）

对于直接包含在机器指令中的数据（**执行前在CPU的指令缓冲器中**），在汇编语言中称为：立即数（idata），在汇编指令中直接给出

```asm
mov ax,1
add bx,2000h
or  bx,00010000b
mov al,'a'
```

#### （2）寄存器

**指令要处理的数据在寄存器中**，在汇编指令中给出相应的寄存器名。

```asm
mov ax, bx 
mov as, ax 
push bx 
mov ds:[0],bx 
push ds 
mov ss,ax 
mov sp, ax
```

#### （3）段地址(SA)和偏移地址(EA)

**指令要处理的数据在内存中**，在汇编指令中可用 [X] 的格式给出 EA，SA 在某个段寄存器中。



存放段地址的寄存器可以是默认的，比如：

```asm
mov ax, [0]
mov ax, [di]
mov ax, [bx+8]
mov ax, [bx+si]
mov ax, [bx+si+8]
```

等指令，段地址默认在 ds 中；

```asm
mov ax, [bp]
mov ax, [bp+8]
mov ax, [bp+si]
mov ax, [bp+si+8]
```

等指令，段地址默认在 ss 中。



存放段地址的寄存器也可以是显性给出的，比如以下的指令。

```asm
mov ax,ds:[bp]  	; 含义:(ax)=((ds)*16+(bp))
mov ax,es:[bx] 		; 含义:(ax)=((es)*16+(bx))
mov ax,ss:[bx+si]   ; 含义:(ax)=((ss)*16+(bx)+(si))
mov ax,cs:[bx+si+8] ; 含义:(ax)=((cs)*16+(bx)+(si)+8)
```



### 4. 寻址方式

当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种**定位内存单元的方法一般被称为寻址方式。**

8086CPU有多种寻址方式，我们在前面的课程中都已经用到了，这里进行一下总结，如表8.2所列。

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	<!-- 制作表格 -->
	<table>
		<caption>表8.2 寻址方式小结</caption>
		<thead>
			<tr>
				<th>寻址方式</th>
				<th>含义</th>
				<th>名称</th>
				<th>常用格式举例</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td><font color="red">[idata]</font></td>
				<td>EA=idata;SA=(ds)</td>
				<td>直接寻址</td>
				<td>[idata]</td>
			</tr>
		</tbody>
	</table>
</body>
</html>

> 直接截图吧，因为 typora 的表格好像不能合并，不过可以用插入html代码制作表格，从而实现表格各种骚操作的效果。不过太多了，我还是直接截图吧。以上绘制表格只是演示尝试

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211223095102143.webp" alt="image-20211223095102143" style="zoom:80%;" />



### 5. 指令要处理的数据有多长

8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。

**（1）通过寄存器名指明要处理的数据的尺寸。**

例如，下面的指令中，寄存器指明了指令进行的是字操作。

```asm
mov ax, 1		; 将字节型数据1送入ax
mov bx, ds:[0]	; 将 ds:[0] 的字型数据送入bx
mov ds, ax 
mov ds:[0],ax 	; 从ax送一个字型到 ds:[0]
inc ax 
add ax,1000
```

下面的指令中，寄存器指明了指令进行的是字节操作。

```asm
mov al,1 
mov al,bl 
mov al,ds:[0] 
mov ds:[O],al 
inc al 
add al,100
```



**（2）在没有寄存器名存在的情况下，用操作符 X ptr 指明内存单元的长度，X 在汇编指令中可以为word或byte**

例如，下面的指令中，用 word ptr指明了指令访问的内存单元是一个字单元。

```asm
mov word ptr ds:[0],1 	; 将1送入 ds:[0] 中 占居一个字的空间
inc word ptr [bx]		; 将 [bx] 自增
inc word ptr ds:[O]		; 自增 ds:[O]
add word ptr [bx],2
```

下面的指令中，用 byte ptr指明了指令访问的内存单元是一个字节单元。

```asm
mov byte ptr ds:[O],1 
inc byte ptr [bx]
inc byte ptr ds:[O]
add byte ptr [bx],2
```

**在没有寄存器参与的内存单元访问指令中，用 word ptr或 byte  ptr显性地指明所要访问的内存单元的长度是很必要的**。否则，CPU无法得知所要访问的单元是字单元，还是字节单元。假设我们用  Debug查看内存的结果如下：

2000:1000    FF FF FF FF FF FF ......

```ASM
mov ax,2000h
mov ds,ax
mov byte ptr [1000h],1
```

执行上面的代码后：内存值为：

2000:1000    01 FF FF FF FF FF ......

```asm
mov ax,2000h
mov ds,ax
mov word ptr [1000h],1
```

执行上面的代码后：内存值为：(记住 字：低位 高位)

2000:1000    01 00 FF FF FF FF ......

> 这是因为 mov byte ptr [1000h],1 访问的是地址为 ds:1000H 的字节单元，修改的是 ds:1000h 单元的内容；而 mov word  ptr [1000h],1 访问的是地址为 ds:1000 的字单元，修改的是 ds:1000H 和 ds:1001H 两个单元的内容。



（3）其他方法

有些指令默认了访问的是字单元还是字节单元，比如，push [1000H] 就不用指明访问的是字单元还是字节单元，因为**push指令只进行字操作**。



### 6. 寻址方式的综合应用

下面我们通过一个问题来进一步讨论一下各种寻址方式的作用。

```properties
关于DEC公司的一条记录(1982年) 如下。
公司名称：DEC
总裁姓名：Ken Olsen
排	名：137
收	入：40（40亿美元）
著名产品：PDP（小型机）
```

这些数据在内存中以图8.1所示的方式存放。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211223103000854.webp" alt="image-20211223103000854" style="zoom:67%;" />

> 可以看到，这些数据被存放在 seg 段中从偏移地址 60H 起始的位置，从 seg:60 起始以 ASCII 字符的形式存储了 3 个字节的公司名称；从 seg:60+3 起始以 ASCII 字符的形式存储了 9 个字节的总裁姓名；从 seg:60+0C 起始存放了一个字型数据，总裁在富翁榜上的排名；从 seg:60+0E 起始存放了一个字型数据，公司的收入；从 seg:60+10h 起始以 ASCII 字符的形式存储了 3 个字节的产品名称。

以上是该公司1982年的情况，到了1988年DEC公司的信息有了如下变化

```properties
（1）Ken Olsen在富翁榜上的排名已升至38位
（2）DEC的收入增加了70亿美元
（3）该公司的著名产品已变为VAX系列计算机。
```

我们提出的任务是，编程修改内存中的过时数据。首先，我们应该分析一下要修改的数据。

要修改内容是

（1）DEC公司记录的(排名字段)

（2）DEC公司记录的(收入字段)

（3）DEC公司记录的(产品字段)的（第一个字符）、（第二个字符）、（第三个字符）



从要修改的内容，我们就可以逐步地确定修改的方法。

（1）要访问的数据是DEC公司的记录，所以，首先要确定DEC公司记录的位置：R = seg:60

> 确定了公司记录的位置后，下面就进一步确定要访问的内容在记录中的位置。

（2）确定排名字段在记录中的位置：0CH。修改 R+0CH 处的数据

（3）确定收入字段在记录中的位置：0EH。修改 R+0EH 处的数据。

（4）确定产品字段在记录中的位置：10H。

> 要修改的产品字段是一个**字符串（或一个数组），需要访问字符串中的每一个字符**。所以要进一步确定每一个字符在字符串中的位置。

（7）确定第一个字符在产品字段中的位置：P=0。

（8）修改 R+10H+P 处的数据；P=P+1。重复3次

根据上面的分析，程序如下：

```asm
mov ax,seg
mov ds,ax
mov bx,60h					; 确定需要修改的位置

mov word ptr [bx+0ch],38	; 将排名字段改为 38
add word ptr [bx+0eh],70	; 将收入字段改为 70

mov si,0					; 用 si 来定位产品字符串中的字符
mov byte ptr [bx+10h+si],'V'
inc si
mov byte ptr [bx+10h+si],'A'
inc si
mov byte ptr [bx+10h+si],'X'
```

我们可以用C语言来描述这个程序，大致应该是这样的

```c
struct company {		// 定义一个公司记录的结构体
  	char companyName[3]; // 公司名称
  	char ceoName[9];	// 公司名称
  	char rank;			// 排名
  	char income;		// 收入
  	char product[3];	// 著名产品
};
// 定义一个公司记录的变量，内存中将存有一条公司的记录
struct company dec={"DEC","Ken Olsen",137,40,"PDP"};

int main(void){
    dec.rank = 38;
    dec.income = dec.income+70;
    
    int i=0;
    dec.product[i] = 'V';
    i++;
    dec.product[i] = 'A';
    i++;
    dec.product[i] = 'X';
    return 0;
}
```

我们再按照C语言的风格，用汇编语言写一下这个程序，注意和C语言相关语句的比对

```asm
mov ax,seg 
mov ds,ax 
mov bx,6oh		; 记录首址送Bx

mov word ptr [bx].0ch,38	; 将排名字段改为 38	//C: dec.rank = 38;
add word ptr [bx].0eh,70	; 将收入字段改为 70	//C: dec.income = dec.income+70;
; 产品字段改为字符串 'VAX'
mov si,0					; //C: int i=0;
mov byte ptr [bx].10h.[si],'V'	; // C: dec.product[i] = 'V';
inc si							; // C: i++
mov byte ptr [bx].10h.[si],'A'
inc si
mov byte ptr [bx].10h.[si],'X'
```

> 那这么说，以后能不能先用 c 写一遍，然后翻译成汇编？



### 7. div 指令(这个有点难记和理解)

**div 是除法指令，使用div做除法的时候应注意以下问题**			( 15 ➗ 2 = 7.....1  被除数:15  除数:2  商:7  余数:1)

（1）除数：有8位和16位两种，在一个 reg 或内存单元中。

（2）被除数：默认放在 AX 或 DX 和 AX 中，**如果除数为 8 位，被除数则为 16 位，默认在 AX 中存放；如果除数为 16 位，被除数则为 32 位，在DX和AX中存放，DX存放高 16 位，AX存放低 16 位。**

（3）结果：**如果除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；如果除数为 16 位，则 AX 存储除法操作的商，DX 存储除法操作的余数。**

> 也就是说，要保证 **被除数的存储空间是除数的两倍**

格式如下：

```asm
div reg
div 内存单元
```

现在，我们可以用多种方法来表示一个内存单元了，比如下面的例子

```asm
div byte ptr ds:[0]	; 含义: (al)=(ax)/((ds)*16 + 0)的商 
					; 	    (ah)=(ax)/((ds)*16 + 0)的余数
					
div word ptr es:[0] ; 含义: (ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商 
					; 		(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数 

div byte ptr [bx+si+8]	; 含义: (al)=(ax)/((ds)*16+(bx)+(si)+8)的商 
						; 		(ah)=(ax)/((ds)*16+(bx)+(si)+8)的余数 

div word ptr [bx+si+8]	; 含义: (ax)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的商 
						; 		(dx)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的余数
```

编程，利用除法指令计算 100001/100。

分析：被除数 100001 大于65535，不能用 ax 寄存器存放，所以只能用 dx 和 ax 两个寄存器联合存放 100001，也就是说要进行 16 位的除法。除数 100 小于 255，可以在一个 8 位寄存器中存放，但是，**因为被除数是 32 位的，除数应为 16 位**，所以要用一个 16 位寄存器来存放除数 100。

因为要分别为 dx 和 ax 赋 100001 的高 16 位值和低 16 位值，所以应先将 100001 表示为 16 进制形式：186A1H程序如下：

```asm
; 将 100001 化为16进制 => 186a1h  需要两个16位寄存器
mov dx,1		; 高16位寄存器 存储被除数的高位
mov ax,86a1h	; 低16位寄存器 存储被除数的低位
; (dx)*10000H + (ax) = 100001
mov bx,100		; 存储除数
div bx			; 开始相除 
```

> 程序执行后，(ax) = 03E8H(即 商为1000)，(dx) = 1(余数为1)。读者可自行在 Debug中实践。



编程，利用除法指令计算 1001/100。

分析：被除数 1001 可用ax寄存器存放，除数 100 可用 8 位寄存器存放，也就是说，要进行8位的除法。程序如下

```asm
mov ax,1001		; 放被除数
mov bl,100		; 放除数 因为被除数是16位寄存器 所以除数需要8位
div bl			; 开始相除
```

程序执行后，(al)=0AH(即 商为10)，(ah)=1(余数为1)。读者可自行在 Debug中实践。



### 8. 伪指令 dd

前面我们用 db 和 dw 定义字节型数据和字型数据。dd是用来定义 dword(双字 4字节)

```asm
data segment
    db 1
    dw 1
    dd 1
data ends
```

在data段中定义了3个数据：

第一个数据为 01H，在 data:0 处，占1个字节

第二个数据为 0001H，在 data:1 处，占1个字

第三个数据为 0000 0001H，在 data:3 处，占2个字。

#### 问题 8.1

用 div 计算 data 段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。

```asm
data segment
	dd 100001	; 被除数
	dw 100		; 除数
	dw 0		; 想存放商
data ends

code segemnt
start:	mov ax,data
		mov ds,ax
		
		mov ax,ds:[0]		; ds:0 字单元中的低16位存储在ax中
		mov dx,ds:[2]		; ds:2 字单元中的高16位存储在dx中
		div word ptr ds:[4]	; 用 dx:ax 中的32位数据除以 ds:4 字单元中的数据
		mov ds:[6],ax		; 将商存储在 ds:6 字单元中
code ends
```



### 9. dup

**dup** 是一个操作符，在汇编语言中同 db、dw、dd 等一样，也是由编译器识别处理的符号。它是和 db、dw、dd 等数据定义伪指令配合使用的，**用来进行数据的重复**。比如：

```asm
db 3 dup (0)	; 定义了3个字节，它们的值都是0，相当于 db 0,0,0
db 3 dup (0,1,2); 定义了9个字节，它们是0,1,2,0,1,2,0,1,2 相当于 db 0,1,2,0,1,2,0,1,2
db 3 dup ('abc','ABC')	; 定义了18个字节：abcABCabcABCabcABC 相当于 db 'abcABCabcABCabcABC'
```

可见，dup的使用格式如下

```asm
db 重复的次数 dup (重复的字节型数据)
dw 重复的次数 dup (重复的字型数据)
dd 重复的次数 dup (重复的双字型数据)
```

dup是一个十分有用的操作符，比如要定义一个容量为200个字节的栈段，如果不用dup，可以用dw 定义100个0

```asm
stack segment
	dw 0,0,0...	; 20个0
	dw 0,0,0...	; 20个0
	dw 0,0,0...	; 20个0
	dw 0,0,0...	; 20个0
	dw 0,0,0...	; 20个0
stack ends
```

当然，你可以用dd，使程序变得简短一些，但是如果要求定义更多呢？有了dup就可以轻松解决。如下：

```asm
stack segment
	db 200 dup (0)
stack ends
```





## 第九章 转移指令的原理

**可以修改IP，或同时修改CS和IP的指令统称为转移指令**。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。

8086CPU的转移行为有以下几类。

- 只修改 IP 时，称为段内转移，比如：jmp ax。
- 同时修改 CS 和 IP 时，称为段间转移，比如：jmp 1000:0

由于转移指令对的修改范围不同，段内转移又分为：短转移和近转移。

- 短转移 IP 的修改范围为 -128~127。	(8字节)

- 近转移 IP 的修改范围为 -32768~32767。(16字节)

8086CPU的转移指令分为以下几类。

- 无条件转移指令（如：jmp）

- 条件转移指令

- 循环指令（如：loop）

- 过程

- 中断

这些转移指令转移的前提条件可能不同，但转移的基本原理是相同的。我们在这一章主要通过深入学习无条件转移指令 jmp 来理解CPU执行转移指令的基本原理



### 1. 操作符 offset

**操作符 offset 在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址**。比如下面的程序：

```asm
assume cs:codesg
codesg segment

start:	mov ax,offset start	; 相当于 mov ax,0
	s:	mov ax,offset s		; 相当于 mov ax,3	

codesg ends
end start
```

在上面的程序中，offset操作符取得了标号 start 和 s 的偏移地址0和3

> mov ax,offset start 相当于指令 mov ax,0，因为 start 是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0
>
> mov ax,offset s 相当于指令 mov  ax,3，因为 s 是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3。

#### 问题 9.1

有如下程序段，添写两条指令，使该程序在运行中将 s 处的一条指令复制到 s0 处。

```asm
assume cs:code
code segment
s:	mov ax,bx		; mov ax,bx 的机器码占两个字节
	mov si, offset s
	mov di, offset s0
	mov ax,cs:[si]	; 将 cs:[si] 位置的字型数据送入ax (指令在内存也是数字 数字可以是数据也可以是指令)
	mov cs:[di],ax
s0:	nop		; nop 的机器码占一个字节
	nop
end s
```

分析：

（1）s 和 s0 处的指令所在的内存单元的地址是多少？cs:offset s 和cs:offset s0。

（2）将 s 处的指令复制到 s0 处，就是将 cs:offset s 处的数据复制到 cs:offset s0 处

（3）段地址已知在 cs 中，偏移地址 offset s和  offset s0已经送入 si 和 di 中。

（4）要复制的数据有多长？mov ax,bx 指令的长度为两个字节，即1个字



### 2. jmp 指令

**jmp 为无条件转移指令，可以只修改IP，也可以同时修改CS和P。**

jmp 指令要给出两种信息：

- 转移的目的地址
- 转移的距离（段间转移、段内短转移，段内近转移）

> 不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令。
>
> 下面的几节内容中，我们以给出目的地址的不同方法为主线，讲解 jmp 指令的主要应用格式和CPU执行转移指令的基本原理。



### 3. 依据位移进行转移的 jmp 指令

**jmp  short 标号（转到标号处执行指令）**

这种格式的 jmp 指令实现的是段内短转移，它对IP的修改范围为-128~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。

jmp指令中的“short”符号，说明指令进行的是短转移。jmp指令中的“标号”是代码段中的标号，指明了指令要转移的目的地，**转移指令结束后，CS:IP应该指向标号处的指令**。

```asm
assume cs:code
code segment

start:	mov ax,0
		jmp short s	; 执行这个指令时，直接跳到 s标号处继续向下执行
		add ax,1
	s:	inc ax
code ends
end start
```

> 上面的程序执行后，ax中的值为1，因为执行 jmp short s后，越过了 add  ax,1，IP指向了标号 s 处的 inc ax。也就是说，程序只进行了一次ax加1操作。

汇编指令 jmp short s对应的机器指令应该是什么样的呢？我们先看一下别的汇编指令和其相对应的机器指令。

```asm
汇编指令				机器指令
mov ax,0123h			b8 23 01
mov ax,ds:[0123h]		a1 23 01
push ds:[0123h]			ff 36 23 01
```

> 可以看到，在一般的汇编指令中，汇编指令中的 idata（立即数），不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指令，它必须要处理这些数据或地址。

现在我们在 Debug中将程序9.1翻译成为机器码，看到的结果如图9.1所示。

![image-20211223151854083](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211223151854083.webp)

对照汇编源程序，我们可以看到，Debug将 jmp short s中的s表示为 inc ax指令的偏移地址8，并将 jmp short  s翻译为jmp 0008，表示转移到cs:0008处。这一切似乎合理可是当我们查看 jmp short  s或是jmp 0008所对应的机器码，却发现了一些问题。

jmp 0008 (Debug中的表示)或 jmp short  s（汇编语言中的表示）所对应的机器码为EB03，注意，这个机器码中竟不包含转移的目的地址，这意味着，CPU在执行EB03的时，并不知道转移的目的地址。那么，CPU根据什么进行转移呢？它知道转移到哪里呢？

令人奇怪的是，汇编指令 jmp short  s中，明明是带有转移的目的地址（由标号s表示）的，可翻译成机器指令后，怎么目的地址就没了呢？没有了目的地址，CPU如何知道转移到哪里呢？



我们把程序9.1改写一下，变成下面这样：

```asm
assume cs:code
code segment

start:	mov ax,0
		mov bx,0
		jmp short s	; 执行这个指令时，直接跳到 s标号处继续向下执行
		add ax,1
	s:	inc ax
code ends
end start
```

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211223153027122.webp" alt="image-20211223153027122" style="zoom:67%;" />

比较一下程序9.1和9.2用 Debug査看的结果，注意，两个程序中的jmp指令都要使IP指向 inc ax 指令，但是程序1的 inc  ax指令的偏移地址为8，而程序2的 inc  ax指令的偏移地址为000BH。而两个程序的jmp翻译成的机器码，都是EB03。**这说明CPU在执行jmp指令的时候并不需要转移的目的地址**。那么也就是说，CPU不需要这个目的地址就可以实现对IP的修改。

CPU只能处理你提供给它的东西，jmp指令的机器码中不包含转移的目的地址，那么，CPU如何知道将IP改为多少呢？所以，在jmp指令的机器码中，一定包含了某种信息，使得CPU可以将它当做修改IP的依据。这种信息是什么呢？我们一步步地分析

我们先简单回忆一下CPU执行指令的过程。

> （1）从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器
>
> （2）(IP)=(IP)+所读取指令的长度，从而指向下一条指令；
>
> （3）执行指令。转到1，重复这个过程

按照这个步骤，模拟一下，程序9.2中 jmp short s指令的读取和执行过程

（1）(CS)= 0BBDH，(IP)=0006H，CS:IP指向 EB 03（jmp short  s的机器码）；

（2）读取指令码 EB 03 进入指令缓冲器；

（3）(IP)=(IP)+所读取指令的长度 = (IP)+2=0008H，CS:IP指向 add  ax,1；

（4）CPU执行指令缓冲器中的指令EB 03；

（5）指令EB 03执行后，(IP)=000BH，CS:IP指向 inc  ax。

> 从上面的过程中我们看到，CPU将指令EB03读入后，IP指向了下一条指令，即CS:0008处的 add  ax,1，接着执行EB03。
>
> 如果EB03没有对IP进行修改的话，那么，接下来CPU将执行 add ax,1，可是，CPU执行的EB03却是一条修改IP的转移指令，执行后 (IP)=000BH。
>
> CPU在执行EB03的时候是根据什么修改的IP，使其指向目标指令呢？就是根据指令码中的03。
>
> 注意，**要转移的目的地址是CS:000B，而CPU执行EB03时，当前的 (IP)=0008H，如果将当前的IP值加3，使(IP)=000BH，CS:IP就可指向目标指令。**
>
> **在转移指令EB03中并没有告诉CPU要转移的目的地址，却告诉了CPU要转移的位移，即将当前的IP向后移动3个字节**。因为程序1、2中的jmp指令转移的位移相同，都是向后3个字节，所以它们的机器码都是EB03

原来如此，在 “jmp  short 标号” 指令所对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移，是编译器根据汇编指令中的“标号”计算出来的，具体的计算方法如图9.3所示

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211223154327150.webp" alt="image-20211223154327150" style="zoom:67%;" />

**实际上，"jmp short 标号"的功能为: (IP)=(IP)+8位位移**

（1）**8位位移 = 标号处的地址 - jmp指令后的第一个字节的地址**

（2）short 指明此处的位移为8位位移；

（3）8位位移的范围为-128~127，用补码表示；

（4）**8位位移由编译程序在编译时算出**。



还有一种和“jmp short 标号”功能相近的指令格式，jmp near ptr 标号，它实现的是段内近转移。

**“jmp near ptr 标号”的功能为：(IP)=(IP)+16位位移。**

（1）16位位移 = 标号处的地址 - jmp指令后的第一个字节的地址；

（2）near ptr 指明此处的位移为16位位移，进行的是段内近转移

（3）16位位移的范围为-32768~32767，用补码表示；

（4）16位位移由编译程序在编译时算出。



### 4. 转移的目的地址在指令中的jmp指令

前面讲的jmp指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。

**“jmp far ptr 标号“实现的是段间转移，又称为远转移**。功能如下

**(CS) = 标号所在段的段地址；(IP) = 标号在段中的偏移地址。far ptr  指明了指令用标号的段地址和偏移地址修改CS和IP。**

```asm
code segment
start:	mov ax,0
		mov bx,0
		jmp far ptr s
		db 256 dup (0)
		
	s:	add ax,1
		inc ax
code ends
```

![image-20211223155330354](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211223155330354.webp)

如图94中所示，源程序中的 db 256 dup (0)，被 Debug解释为相应的若干条汇编指令。

关键是，我们要注意一下 jmp far ptr  s 所对应的机器码：EA 0B 01 BD 0B，**其中包含转移的目的地址**。“0B 01 BD 0B”是目的地址在指令中的存储顺序，高地址的 “BD 0B” 是转移的段地址；0BBDH，低地址的 “0B 01” 是偏移地址：010BH。

> 对于 “jmp X 标号” 格式的指令的深入分析请参看**附注3**。附注上写的很明确了，还是直接看书吧



### 5. 转移地址在寄存器中的 jmp 指令

指令格式：jmp 16位 reg

功能：(IP)=(16位reg)

这种指令我们在前面的内容（参见2.11节）中已经讲过，这里就不再详述



### 6. 转移地址在内存中的jmp指令

转移地址在内存中的jmp指令有两种格式：

（1）jmp word ptr 内存单元地址（段内转移）

功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。1个字=2字节=65536

内存单元地址可用寻址方式的任一格式给出。

比如，下面的指令：

```asm
mov ax,0123h
mov ds:[0],ax
jmp word ptr ds:[0]	; 执行后 (IP)=0123H
```

```asm
mov ax,0123h
mov [bx],ax
jmp word ptr [bx]	; 执行后 (IP)=0123H
```

（2）jmp dword ptr 内存单元地址（段间转移）

功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。

(CS) = (内存单元地址 + 2)				(IP) = 内存单元地址

内存单元地址可用寻址方式的任一格式给出。

比如，下面的指令

```asm
mov ax,0123h
mov ds:[0],ax			; 将ax值放入低地址 作为目标偏移地址
mov word ptr ds:[2],0	; 将0放入高地址，作为目标段地址
jmp dword ptr ds:[0]	; 执行后，(cs)=0,(ip)=0123h,cs:ip指向0000:0123h
						; cs = 内存单元地址+2后 读取到的是高地址 即0
```

```asm
mov ax,0123h
mov [bx],ax
mov word ptr [bx+2],0
jmp dword ptr [bx]		; 执行后，(cs)=0,(ip)=0123h,cs:ip指向0000:0123h
```



### 7. jcxz指令

**jcxz 指令为有条件转移指令，所有的有条件转移指令都是<font color='red'>短转移</font>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127。**

> 指令格式：**jcxz 标号（如果 (cx)=0，转移到标号处执行。）**
>
> 操作：当 (cx)=0 时，(IP)=(IP)+8位位移
>
> **8位位移 = 标号处的地址 - jcxz指令后的第一个字节的地址**
>
> 8位位移的范围为-128~127，用补码表示。8位位移由编译程序在编译时算出
>
> **当 (cx)≠0 时，什么也不做（程序向下执行）。**

我们从 jcxz 的功能中可以看出，“jcxz  标号”的功能相当于：

```c
if ((cx) == 0)
    jmp short 标号;
```



### 8. loop指令

**loop 指令为循环指令，所有的循环指令都是<font color='red'>短转移</font>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127。**

> 指令格式：**loop 标号（ (cx)=(cx)-1，如果(cx)≠0，转移到标号处执行。）**
>
> 操作：① (cx)=(cx)-1		② 如果(cx)≠0，(IP)=(IP)+8位位移
>
> **8位位移 = 标号处的地址 - loop指令后的第一个字节的地址**
>
> 8位位移的范围为-128~127，用补码表示。8位位移由编译程序在编译时算出
>
> **当 (cx)=0 时，什么也不做（程序向下执行）。**

我们从 loop 的功能中可以看出，“loop 标号”的功能相当于：

```c
do {
   jmp short 标号;
   (cx)--;
} while(cx != 0);
```



### 9. 根据位移进行转移的意义

```asm
jmp short 标号
jmp near 标号
jcxz 标号
loop 标号
```

等几种汇编指令，它们对 IP 的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。

这种设计，方便了程序段在内存中的浮动装配。

例如：

```asm
	汇编指令		机器代码
	mov cx,6 		B9 06 00 
	mov ax,10h		B8 10 00 
s:	add ax,ax 		01 C0 
	loop s 			E2 FC
```

> 这段程序装在内存中的不同位置都可正确执行，因为 loop  s 在执行时只涉及 s 的位移（-4，前移4个字节，补码表示为FCH），而不是 s 的地址。
>
> 如果 loop s 的机器码中包含的是 s 的地址，则就对程序段在内存中的偏移地址有了严格的限制，因为机器码中包含的是的 s 地址，如果 s 处的指令不在目的地址处，程序的执行就会出错。
>
> 而  loop  s 的机器码中包含的是转移的位移，就不存在这个问题了，因为，无论 s 处的指令的实际地址是多少loop 指令的转移位移是不变的。



### 10. 编译器对转移位移超界的检测

注意，**根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错**。

比如，下面的程序将引起编译错误：

```asm
assume cs:code
code segment
start:	jmp short s		; 跳转范围 -128~127
		db 128 dup (0)	; 定义了 128个0 超过了 短段内跳转范围
	s:	mov ax,0ffffh
code ends
end start
```

jmp short s 的转移范围是-128~127，IP 最多向后移动127个字节。

**注意，我们在第2章中讲到的形如 “jmp 2000:0100” 的转移指令，是在  Debug 中使用的汇编指令，汇编编译器并不认识。如果在源程序中使用，编译时也会报错。**





## 第十章 CALL和RET指令

call 和 ret 指令都是转移指令，它们都修改 IP，或同时修改 CS 和 IP。它们经常被共同用来实现子程序的设计。这一章，我们讲解 call 和 ret 指令的原理。

### 1. ret和retf

**ret 指令用栈中的数据，修改IP的内容，从而实现近转移；**

**retf 指令用栈中的数据，修改CS和IP的内容，从而实现远转移。**

> CPU执行ret指令时,进行下面两步操作: 
> ① (IP) = ((ss)*16+(sp))
> ② (sp) = (sp)+2 
>
> CPU执行 retf 指令时,进行下面4步操作
> ① (IP) = ((ss)*16+(sp))
>
> ② (sp) = (sp)+2
>
> ③ (CS) = ((ss)*16+(sp))
>
> ④ (sp) = (sp)+2

可以看出，如果我们用汇编语法来解释 ret 和 retf 指令，则：

```asm
CPU执行ret指令时，相当于进行：
pop IP

CPU执行retf指令时，相当于进行
pop IP 
pop Cs
```



下面的程序中，ret指令执行后，(IP)=0，CS:IP 指向代码段的第一条指令

```asm
assume cs:code,ss:stack
stack segment
	db 16 dup (0)
stack ends

code segment
	mov ax,4c00h
	int 21h
	
s:	mov ax,stack
	mov ss,ax
	mov sp,16	; 定位到栈顶，栈顶为空
	
	mov ax,0
	push ax		; 将0送入栈中，栈顶为0
	mov bx,0
	ret			; 将栈顶元素送入 IP，使得 IP=0   cs:ip => cs:0 从而执行第一条指令
code ends
end s
```

下面的程序中，retf 指令执行后，CS:IP指向代码段的第一条指令。

```asm
assume cs:code
stack segment
	db 16 dup (0)
stack ends

code segment
	mov ax,4c00h
	int 21h
	
s:	mov ax,stack
	mov ss,ax
	mov sp,16	; 定位到栈顶，栈顶为空
	
	mov ax,0
	push cs		; cs入栈，保存cs的值
	push ax		; 将0送入栈中，栈顶为0
	mov bx,0
	retf		; 出栈的第一个元素送入IP，出栈的第二个元素送入CS；这里 cs:ip => cs:0
code ends
end s
```



### 2. call指令

CPU 执行 call 指令时，进行两步操作：

（1）将当前的 IP 或 CS 和 IP 压入栈中

（2）转移。

**call 指令不能实现短转移**，除此之外，call 指令实现转移的方法和 jmp 指令的原理相同，下面的几个小节中，我们以给出转移目的地址的不同方法为主线，讲解 call 指令的主要应用格式。



### 3. 依据位移进行转移的ca‖指令

**call 标号（将当前的IP压栈后，转到标号处执行指令）**

CPU执行此种格式的call指令时，进行如下的操作：

> ① (sp) = (sp)-2		((ss)\*16+(sp)) = (IP)    
>
> ② (IP) = (IP)+16位位移
>
> 16位位移 = 标号处的地址 - call 指令后的第一个字节的地址
>
> 16位位移的范围为-32768~32767，用补码表示；16位位移由编译程序在编译时算出

从上面的描述中，可以看岀，如果我们用汇编语法来解释此种格式的 call 指令，则：

CPU执行“call 标号”时，相当于进行：

```asm
push IP
jmp near ptr 标号
```



### 4. 转移的目的地址在指令中的call指

前面讲的 call 指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前I的转移位移。

**“call far ptr 标号” 实现的是段间转移**

> ① (sp) = (sp)-2	((ss)\*16+(sp))=(CS)	(sp)=(sp)-2	((ss)\*16+(sp))=(IP)
>
> ② (CS) = 标号所在段的段地址		(IP) = 标号所在段中的偏移地址

从上面的描述中可以看出，如果我们用汇编语法来解释此种格式的 call 指令，则

CPU执行 “call far ptr 标号” 时，相当于进行

```asm
push CS
push IP
jmp far ptr 标号
```



### 5. 转移地址在寄存器中的call指令

指令格式：call 16位 reg

功能：

> (sp) = (sp)-2
>
> ((ss)*16+(sp)) = (IP)
>
> (IP) = (16位reg)

用汇编语法来解释此种格式的 call 指令，CPU执行 “call 16位 reg”时，相当于进行：

```asm
push ip
jmp 16位reg
```



### 6. 转移地址在内存中的call指令

转移地址在内存中的 call 指令有两种格式。

（1）call word ptr 内存单元地址

用汇编语法来解释此种格式的 call 指令，则：

CPU执行 “call word ptr 内存单元地址” 时，相当于进行：

```asm
push ip
jmp word ptr 内存单元地址
```

比如，下面的指令：

```asm
mov sp,10h
mov ax,0123h
mov ds:[0],ax
call word ptr ds:[0]
; 执行后，(ip)=0123h,(sp)=0eh
; 因为这是执行后的，并不代表栈顶元素也是0123h，事实上栈顶元素值为原ip值
```

（2）call dword ptr 内存单元地址

用汇编语法来解释此种格式的 call 指令，则

CPU执行 “call dword  ptr 内存单元地址” 时，相当于进行：

```asm
push cs
push ip
jmp dword ptr 内存单元地址
```

比如，下面的指令：

```asm
mov sp,10h
mov ax,0123h
mov ds:[0],ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
; 执行后，(cs)=0,(ip)=0123h,(sp)=0ch
```



### 7. call和ret的配合使用

前面，我们已经分别学习了 ret 和 call 指令的原理。现在来看一下，如何将它们配合使用来实现子程序的机制

#### 问题 10.1

下面程序返回前，bx中的值是多少？

```asm
assume cs:code
code segment
start:	mov ax,1
		mov cx,3
		call s		; push ip,jmp near ptr 标号  将mov bx,ax的ip入栈，跳转到s标号
		mov bx,ax	; (bx)=8
		
		mov ax,4c00h
		int 21h
		
	s:	add ax,ax	; ax=2 4 8
		loop s
		ret			; pop ip => 又回到了mov bx,ax
code ends
end start
```

> 我们来看一下CPU执行这个程序的主要过程。
>
> （1）CPU将 call s 指令的机器码读入，IP指向了 call s 后的指令 mov bx,ax ，然后CPU执行 call s 指令，将当前的IP值（指令  moy  bx,ax 的偏移地址）压栈，并将IP的值改变为标号s处的偏移地址；
>
> （2）CPU从标号 s 处开始执行指令，loop循环完毕后，(ax)=8；
>
> （3）CPU将 ret 指令的机器码读入，IP指向了 ret 指令后的内存单元，然后CPU执行 ret 指令，从栈中弹出一个值（即  call s 先前压入的 mov bx,ax 指令的偏移地址）送入IP中。则CS:IP指向指令 mov bx,ax；
>
> （4）CPU从 mov bx,ax 开始执行指令，直至完成。
>
> 程序返回前，(bx)=8。可以看出，从标号 s 到 ret 的程序段的作用是计算 2^n^，计算前，N的值由 cx 提供。

我们再来看下面的程序：

```asm
; 内存中的情况（假设程序从内存1000:0处装入）
assume cs:code
stack segment
	db 8 dup (0)	; 1000:0000	00 00 00 00 00 00 00 00
	db 8 dup (0)	; 1000:0008	00 00 00 00 00 00 00 00
stack ends

code segment
start:	mov ax,stack	; 1001:0000	b8 00 10
		mov ss,ax		; 1001:0003	8e d0
		mov sp,16		; 1001:0005	bc 10 00
		mov ax,1000		; 1001:0008	b8 e8 03
		call s			; 1001:000b	e8 05 00
		mov ax,4c00h	; 1001:000e	b8 00 4c
		int 21h			; 1001:0011	cd 21
		
		; 当主程序看见程序返回后，下面还有代码，就得考虑是否进行了函数调用
	s:	add ax,ax		; 1001:0013	03 c0
		ret				; 1001:0015	c3
code ends
end start
```

#### 图解 call与ret流程

看一下程序的主要执行过程。

（1）前3条指令执行后，栈的情况如下：

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211227170137328.webp" alt="image-20211227170137328" />

（2）call指令读入后，(IP)=000EH，CPU指令缓冲器中的代码为：E8 05 00；CPU执行E8 05 00，首先，栈中的情况变为：

![image-20211227170239955](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211227170239955.webp)

然后，(IP) = (IP)+0005 = 0013H

（3）CPU从cs:0013H处（即标号s处）开始执行。

（4）ret指令读入后 (IP)=0016H，CPU指令缓冲器中的代码为：C3，CPU执行C3，相当于进行pop IP，执行后，栈中的情况为：

![image-20211227170258760](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211227170258760.webp)

（5）CPU回到 cs:000EH 处（即call指令后面的指令处）继续执行。

> 从上面的讨论中我们发现，可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，**用 call指令转去执行**。可是执行完**子程序**后，如何让CPU接着call指令向下执行？call指令转去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可**在子程序的后面使用 ret 指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行**。

这样，我们可以利用call和ret来实现子程序的机制。子程序的框架如下

```asm
标号:
	指令
	ret
; 具有子程序的源程序的框架如下。

assume cs:code
code segment
main:	...
		...
		call fun1	; 调用子程序 fun1
		...
		...
		mov ax,4c00h
		int 21h
		
fun1:	...			; 子程序 fun1 开始
		...
		call fun2	; 调用子程序 fun2
		...
		...
		ret			; 子程序 fun1 返回
		
fun2:	...			; 子程序 fun2 开始
		...			
		ret			;  子程序 fun2 返回
code ends
end main
```



### 8. mul指令

因下面要用到，这里介绍一下 mul 指令，**mul是乘法指令**，使用 mul 做乘法的时候，注意以下两点：

（1）两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位 reg 或内存字节单元中；如果是16位，一个默认在AX中，另一个放在16位 reg 或内存字单元中

（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在 DX 中存放，低位在AX中放。

格式如下：

```asm
mul reg 
mu1 内存单元
; 内存单元可以用不同的寻址方式给出,比如
mul byte ptr ds:[0]		; 含义:(ax)=(al)*((ds)*16+0)
mul word ptr [bx+si+8] 	; 含义:(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位. 
						; (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位.
```

#### 例：

（1）计算100*10。

```asm
; 100 和 10小于255，可以做8位乘法，程序如下。
mov al,100	; 将其中一个乘数放 al 
mov bl,10 	; 将另一个乘数放 reg
mul bl		; 相乘
; 结果：(ax)=1000(03e8h)	由于是8位乘法，相乘的结果放ax
```

（2）计算100*10000

```asm
; 100小于255，可1000大于255，所以必须做16位乘法，程序如下。
mov ax,100 
mov bx,10000 
mul bx 
; 结果：(ax)=4240H (dx)=000FH		(F4240H=1000000)
```



### 9. 模块化程序设计

从上面我们看到，call 与 ret 指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。因为现实的问题比较复杂，对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法。

而 call 与 ret 指令对这种分析方法提供了程序实现上的支持。利用 call 和 ret 指令，我们可以用简捷的方法，实现多个相互联系、功能独立的子程序来解决一个复杂的问题。

下面的内容中，我们来看一下子程序设计中的相关问题和解决方法。



### 10. 参数和结果传递的问题

子程序一般都要根据提供的参数处理一定的事务，处理后，将结果(返回值)提供给调用者。其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。

比如，设计一个子程序，可以根据提供的N，来计算N的3次方

这里面就有两个问题：

（1）将参数N存储在什么地方？

（2）计算得到的数值，存储在什么地方？

很显然，可以用寄存器来存储，可以将参数放到 bx 中；因为子程序中要计算 N\*N\*N，可以使用多个 mul 指令，为了方便，可将结果放到 dx 和 ax 中。子程序如下。

```asm
; 说明: 计算 N的3次方
; 参数: (bx)=N
; 结果: (dx:ax)=N^3

cube:	mov ax,bx
		mul bx
		mul bx
		ret
```

> 注意，我们在编程的时候要注意形成良好的风格，对于程序应有详细的注释。子程序的注释信息应该包含对子程序的功能、参数和结果的说明。

用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：**调用者将参数送入参数寄存器，从结果寄存器中取到返回值；子程序从参数寄存器中取到参数，将返回值送入结果寄存器。**

编程，计算 data 段中第一组数据的3次方，结果保存在后面一组 dword 单元中

```asm
assume cs:code
data segment
	dw 1,2,3,4,5,6,7,8
	dd 0,0,0,0,0,0,0,0
data ends
; 我们可以用到已经写好的子程序，程序如下：
code segment
start:	mov ax,data
		mov ds,ax
		mov si,0	; ds:si 指向第一组 word 单元
		mov di,16	; ds:di 指向第二组 dword 单元
		
		mov cx,8
	s:	mov bx,[si]	; 从 word 单元(可以看成一个数组)中循环取值，并将参数存到bx
		call cube	; 调用cube函数进行计算，参数在bx中
		mov [di],ax	; 将ax(计算结果)存到dword数组中
		mov [di].2,dx	; 考虑到有可能是16位乘法，将高位数据也存到dword数组
		add si,2	; word数组移到下标
		add di,4	; dword数组移到下标
		loop s
		
		mov ax,4c00h	; 程序返回
		int 21h
		
cube:	mov ax,bx	; 子程序：计算参数N(这里的参数在bx中)的三次方
		mul bx
		mul bx
		ret			; 计算的结果在ax中
code ends
end start
```



### 11. 批量数据的传递

前面的例程中，子程序cube只有一个参数，放在bx中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有3个、4个或更多直至N个，该怎样存放呢？我们不可能简单地用寄存器来存放多个需要传递的数据。对于返回值，也有同样的问题。

**在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。**

下面看一个例子，设计一个子程序，功能：将一个全是字母的字符串转化为大写。

这个子程序需要知道两件事，字符串的内容和字符串的长度。因为字符串中的字母可能很多，所以不便将整个字符串中的所有字母都直接传递给子程序。但是，可以将字符串在内存中的首地址放在寄存器中传递给子程序。因为子程序中要用到循环，我们可以用loop指令，而循环的次数恰恰就是字符串的长度。出于方便的考虑，可以将字符串的长度放到cx中。

```asm
capital: and byte ptr [si],11011111b	; 将 ds:si 所指单元中的字母转化为大写
		 inc si							; ds:si 指向下一个单元 字母是1字节的 +1就行	
		 loop capital
		 ret
```

编程，将data段中的字符串转化为大写。

```asm
assume cs:code
data segment
	db 'conversation'
data ends

code:segment
start:	mov ax,data
		mov ds,ax
		mov si,0	; ds:si 指向字符串(批量数据)所在空间的首地址
		
		mov cx,12	; cx 存放字符串的长度 也是循环次数
		call capital	; 在子函数中将字母转化为大写
		mov ax,4c00h
		int 21h

capital: and byte ptr [si],11011111b	; 将 ds:si 所指单元中的字母转化为大写
		 inc si							; ds:si 指向下一个单元 字母是1字节的 +1就行	
		 loop capital
		 ret
code ends
end start
```

> 注意，除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。关于这种技术请参看附注4。



### 12. 寄存器冲突的问题

设计一个子程序，功能：将一个全是字母，以0结尾的字符串，转化为大写。

程序要处理的字符串以0作为结尾符，这个字符串可以如下定义：

```asm
db 'conversation',0
```

应用这个子程序，字符串的内容后面一定要有一个0，标记字符串的结束。子程序可以依次读取每个字符进行检测，如果不是0，就进行大写的转化；如果是0，就结束处理。由于可通过检测0而知道是否已经处理完整个字符串，所以子程序可以不需要字符串的长度作为参数。可以用 jxz 来检测0。

```asm
; 说明: 将一个全是字母,以0结尾的字符串,转化为大写
; 参数:ds:si 指向字符串的首地址
; 结果:没有返回值
capital:mov cl,[si]
		mov ch,0
		jcxz ok		; 如果(cx)=0，执行ok，子程序返回；如果不是0，向下处理
		and byte ptr [si],11011111b	; 将ds:si所指单元中的字母转化为大写
		inc si		; ds:si 指向下一个单元
		jmp short capital	; 无条件跳到capital
	ok:	ret
```

来看一下这个子程序的应用。

（1）将 data 段中字符串转化为大写

```asm
data segment
	db 'conversation',0
data ends
```

代码段中的相关程序段如下。

```asm
mov ax,data
mov ds,ax
mov si,0
call capital	; 子程序进行字符转化
```

（2）将data段中的字符串全部转化为大写。

```asm
data segment
	db 'word',0
	db 'unix',0
	db 'wind',0
	db 'good',0
data ends
```

可以看到，所有字符串的长度都是5（算上结尾符0），使用循环，重复调用子程序capital，完成对4个字符串的处理。完整的程序如下。

```asm
assume cs:code
code segment
start:	mov ax,data
		mov ds,ax
		mov bx,0	; 存偏移量 即数组行下标
		
		mov cx,4
	s:	mov si,bx	; si存数组列下标
		call capital
		add bx,5	; 跳到下一行
		loop s
		
		; 主程序返回

capital:mov cl,[si]
		mov ch,0	; 将数组字符存入cx，让下面执行cx不为0的循环
		jcxz ok		; 如果(cx)=0，执行ok，子程序返回；如果不是0，向下处理
		and byte ptr [si],11011111b	; 将ds:si所指单元中的字母转化为大写
		inc si		; ds:si 指向下一个单元
		jmp short capital	; 无条件跳到capital
	ok:	ret
	
code ends
end start
```

> 想表示，这个子程序可以复用

#### 问题 10.2

这个程序在思想上完全正确，但在细节上却有些错误，把错误找出来。

思考后看分析。

**分析：**问题在于 cx 的使用，主程序要使用cx记录循环次数，可是子程序中也使用了cx，在执行子程序的时候，cx中保存的循环计数值被改变，使得主程序的循环出错。

从上面的问题中，实际上引出了一个一般化的问题：**子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。**

那么如何来避免这种冲突呢？粗略地看，可以有以下两个方案。

（1）在编写调用子程序的程序时，注意看看子程序中有没有用到会产生冲突的寄存器，如果有，调用者使用别的寄存器

（2）在编写子程序的时候，不要使用会产生冲突的寄存器。

> 我们来分析一下上面两个方案的可行性：
>
> （1）这将给调用子程序的程序的编写造成很大的麻烦，因为必须要小心检査所调用的子程序中是否有将产生冲突的寄存器。比如说，在上面的例子中，我们在编写主程序的循环的时候就得检查子程序中是否用到了 bx和 cx，因为如果子程序中用到了这两个寄存器就会出现问题。如果采用这种方案来解决冲突的话，那么在主程序的循环中，就不能使用cx寄存器，因为子程序中已经用到。
>
> （2）这个方案是不可能实现的，因为编写子程序的时候无法知道将来的调用情况。

可见，我们上面所设想的两个方案都不可行。我们希望：

（1）编写调用子程序的程序的时候不必关心子程序到底使用了哪些寄存器

（2）编写子程序的时候不必关心调用者使用了哪些寄存器

（3）不会发生寄存器冲突。

解决这个问题的简捷方法是，**在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。可以用栈来保存寄存器中的内容。**

**以后，我们编写子程序的标准框架如下**

```properties
子程序开始:	 子程序中使用的寄存器入栈
			子程序内存
			子程序中使用的寄存器出栈
			返回(ret、retf)
```

我们改进一下子程序 capital 的设计：

```asm
capital:push cx
		push si		; 先将寄存器的值保存起来
		
change:	mov cl,[si]
		mov ch,0
		jcxz ok
		and byte ptr [si],11011111b
		inc si
		jmp short change
		
	ok:	pop si		; 子程序执行完毕，需要返回了，将寄存器中的值还原
		pop cx
		ret
; 要注意寄存器入栈和出栈的顺序。
```







