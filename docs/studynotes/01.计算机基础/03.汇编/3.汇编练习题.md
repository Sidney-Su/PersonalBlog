---
title: 汇编练习题
date: 2023-01-29 10:48:31
permalink: /pages/5ee232/
categories:
  - studynotes
  - 计算机基础
  - 汇编
tags:
  - 
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---
来自 王爽老师的 《汇编语言》第三版

[对答案](https://blog.csdn.net/qq_42777804/article/details/90512159)

## 练习

### 检测点 1

#### 检测点 1.1

##### 1.

**1个CPU的寻址能力为8KB，那么它的地址总线的宽度为？**

8KB = 8*1024B = 8\*1024\*8b

1024 = 2^10^    8 = 2^3^

2^n^>=8KB  ==>  2^n^>=8*1024  ==>  n=13

> 一个地址总线传输8bit即1B的数据，所以不用再除以8了

**答案：地址总线的宽度为13位**



##### 2.

**1KB的存储器有 <u>1024</u> 个存储单元，存储单元的编号从 <u>0</u> 到 <u>1023</u> 。**



##### 3.

**1KB的存储器可以存储 <u>8192（2</u>^13^）个bit， <u>1024</u>个Byte。**

1KB = 1024B =1024*8b   ==>  2^13^b



##### 4.

**1GB、1MB、1KB分别是多少Byte?**

1GB = 1024*1024\*1024 = 2^30^B

1MB = 1024\*1024 = 2^20^B

1KB = 1024 = 2^10^B



##### 5.

**8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为多少B?**

8根数据总线代表一次可传输一个8位二进制数据(即1个字节)

**答案：8根一次性传输1B   16根一次性传输2B   32根一次性传输4B**



##### 6.

**从内存中读取1024字节的数据，8086至少要读 <u>512</u> 次，80386至少要读 <u>256</u> 次。**

8086有16根数据总线，一次性可传16位(2字节)的数据，所以8086读取1024字节数据，至少需要512次

80386有32根数据总线，一次性传4字节，所以需要256次



##### 7.

**在存储器中，数据和程序以 二进制 形式存放。**



### 检测点 2

#### 检测点 2.1

##### 1. 

**写出每条汇编指令执行后相关寄存器中的值。**

```asm
mov ax,62627  AX= F4A3 H 

mov ah,31H   AX= 31A3 H  # 注意：高8位移动

mov al,23H   AX= 3123 H  # 注意：低8位移动

add ax,ax   AX= 6246 H 

mov bx,826CH  BX= 826C H 

mov cx,ax   CX= 6246 H 

mov ax,bx   AX= 826C H 

add ax,bx   AX= 04D8 H  # 注意：加法有溢出

mov al,bh   AX= 0482 H  # 注意：将BX的高8位移到AX的低8位

mov ah,bl   AX= 6C82 H  # 注意：将BX的低8位移到AX的高8位

add ah,ah   AX= D882 H 

add al,6    AX= D888 H  # 注意：加的是10进制的6

add al,al   AX= D810 H  # 注意：低8位相加 有溢出

mov ax,cx   AX= 6246 H
```

##### 2.

**只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。**

2^4^ = 2\*2\*2\*2 = 16    相当于把2左移3次

2*2 = 2+2

```asm
mov ax,2H    # ax=2

add ax,ax	 # ax = ax*2 = 4  相当于左移1位

add ax,ax	 # ax = 8 再左移1位

add ax,ax	 # ax = 16 第三次左移	
```

#### 检测点2.2

##### 1. 段地址题目(多看两遍)

**给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 <u>0010H</u> 到 <u>1000FH</u> 。**

物理地址：段地址×16+偏移地址；CPU的寻址范围为物理起始地址+64KB(因为偏移地址是16位的2^16^=64KB)

段地址：0001H	物理地址：0001H*16+X

X是偏移地址，由于偏移地址是16位的，2^16^ = 64KB = FFFFH，所以可以从0H偏到FFFFH

所以：寻址范围：(0001H\*16+0H) ~ (0001H\*16+FFFFH) = 00010H \~ 1000FH



##### 2.

**有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为 <u>1001H</u> ，最大为 <u>2000H</u> 。**

据题意：20000H为物理地址，偏移地址为0-FFFFH

20000H 要处于 (SA\*16+0H) - (SA\*16+FFFFH) 之间

段地址最大情况：20000H = SA*16+0H     ==>  SA=2000H

段地址最小情况：20000H = SA*16+FFFFH   ==>  SA=1001H

> 偏移地址大了，段地址不就小了么。最好算出结果了再代入算一下。



#### 检测点2.3

下面的3条指令执行后，cpu几次修改IP？都是在什么时候？最后IP中的值是多少？ 

```asm
mov ax,bx 
sub ax,ax 
jmp ax 
```

cpu一共修改4次IP，因为每次执行一条指令，都会修改一次IP

第一次：读取mov ax,bx之后

第二次：读取sub ax,ax之后 

第三次：读取jmp ax之后 

第四次：执行jmp ax修改IP 

最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H



### 实验 1 查看CPU和内存，用机器指令和汇编指令编程(书上特别详细)

#### 1. Debug的使用

Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具。使用它，可以査看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。

（2）我们用到的 Debug功能

- 用 Debug的 R 命令查看、改变CPU寄存器的内容
- 用  Debug的 D 命令查看内存中的内容
- 用 Debug的 E 命令改写内存中的内容
- 用 Debug的 U 命令将内存中的机器指令翻译成汇编指令
- 用 Debug的 T 命令执行一条机器指令

- 用 Debug的 A 命令以汇编指令的格式在内存中写入一条机器指令。

（3）用R命令查看、改变CPU寄存器的内容

![image-20211216171643943](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216171643943.webp)

改变AX寄存器的值

![image-20211216171737851](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216171737851.webp)

> 也可以用它改变CS:IP的值

（4）用 Debug的D命令查看内存中的内容。

用  Debug的D命令，可以查看内存中的内容，D命令的格式较多，这里只介绍在本次实验中用到的格式

如果我们想知道内存10000H处的内容，可以用“d 段地址:偏移地址”的格式来査看，如图所示。

![image-20211216172208740](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216172208740.webp)

也可以指定D命令的查看范围，此时采用“d 段地址:起始偏移地址  结尾偏移地址”的格式。比如要看1000:0~1000:9中的内容，可以用“d 1000:0 9”实现，如图所示。

![image-20211216172448647](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216172448647.webp)

> 这个分号是截图时生成的，在dosbox中，F1被编码成了分号

（5）用 Debug的E命令改写内存中的内容

可以使用E命令来改写内存中的内容，比如，要将内存1000:0~1000:9单元中的内容分别写为0、1、2、3、4、5、6、7、8、9，可以用“e 起始地址 数据 数据 数据 ……”的格式来进行，如图所示。

![image-20211216172738743](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216172738743.webp)

> 用d时先查看内存中有无值，然后通过e命令修改，然后再通过d查询一下

还可以提问式修改

![image-20211216173058041](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216173058041.webp)

> 先查询一下，然后使用e只指定修改哪个内存块的值，enter，会一一提示修改；修改下一个按 空格 键；修改完成退出按 enter
>
> 最后再查询一下修改后的内存

（6）用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码。

![image-20211216173432358](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216173432358.webp)

> 用E命令向内存中写入字符串

![image-20211216173545873](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216173545873.webp)

> 用U命令将内存单元中的内容翻译为汇编指令显示

（7）用 Debug的 A 命令以汇编指令的形式在内存中写入机器指令。

![image-20211216174818294](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211216174818294.webp)

> 先用d查看一下内存中的数据，然后通过a命令写入汇编指令，再次查看一下；发现汇编指令翻译成了对应的二进制；然后通过u查看汇编指令，发现查询的与我们写入的汇编指令基本一致；至于add ax,bx为啥没执行？执行CS:IP的指令需要用T



#### 2. 实验任务

**1）使用 Debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后CPU中相关寄存器中内容的变化。**

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211217105351299.webp" alt="image-20211217105351299" style="zoom:67%;" />

> 提示，可用E命令和A命令以两种方式将指令写入内存。**注意用 T 命令执行时CS:IP的指向。**
>
> 用A好一点，输入汇编指令
>
> 总结一下如何输入并执行：1.先用d 查一下当前CS:IP指向的内存是否为空(最好找个为空的位置)；
>
> 2.输入a，回车，一一输入汇编指令；
>
> 3.再用d CS:IP 查看一下是否有对应的机器码；
>
> 4.用u查看一下输入的汇编指令；
>
> 5.用r查一下寄存器及CS:IP的值；
>
> 6.执行：由于我们输入了一堆汇编指令，此时的CS:IP位置已经变化，所以我们需要定位到自己输入的第一天汇编指令的CS:IP处，然后用t命令执行



**2）将下面3条指令写入从20000开始的内存单元中，利用这3条指令计算2的8次方。**

```asm]
mov ax,1
add ax,ax
jmp 2000:0003
```

1.用r看一下，CS:IP的位置及其寄存器的值

2.如果CS:IP不对，用r进行修改   CS=2000  IP=0

3.用d CS:IP 结束范围，看一下该位置的内存值

4.用a CS:IP 从该位置写入3条汇编指令

5.r再确认一下寄存器与CS:IP

6.可能需要重新定位CS:IP到我们自己输入的第一条汇编指令处，用t一一执行；执行到ax=8就按enter结束



**3）查看内存中的内容。**

PC机主板上的ROM中写有一个生产日期，在内存 FFF00H~ FFFFFH的某几个单元中，请找到这个生产日期并试图改变它。

提示，如果读者对实验的结果感到疑惑，请仔细阅读第1章中的1.15节。

1.用d fff0:0 ff 查看一下生产日期  （我的没有全0）

2.尝试修改却改不了，因为这是ROM的内存，只读不写

> 每个进程中的寄存器的值是被保存在PCB中的，改变了这个寄存器的值不影响其他进程中的寄存器的值
>
> emmmm，不知道是Windows10的日期不在这里面还是我用的主板上的ROM没有刻录日期到FFF0:0



**4）向内存从B8100H开始的单元中填写数据，如：**

e B810:0000 01 01 02 02 03 03 04 04 

请读者先填写不同的数据，观察产生的现象；再改变填写的地址，观察产生的现象。

dos窗口的右偏上出现彩色图案，b810  显存的地址，写数据会从屏幕上显示出来。显存的编码兼容了ASCII码

提示，如果读者对实验的结果感到疑惑，请仔细阅读第1章中的1.15节。



### 检测点 3

#### 检测点 3.1

##### 1.

在 Debug中，用“d 0:0 1f”查看内存，结果如下

![image-20211217161910049](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211217161910049.webp)

**下面的程序执行前，AX=0，BX=0，写出每条汇编指令执行完后相关寄存器中的值。**

```asm
mov ax,1			; ax=1H
mov ds,ax			; ds=1H
; 因为段地址为1，这里的偏移地址为0 所以物理地址为 10
mov ax,[0000]		; ax=2662H	老是搞错 高位->低位
mov bx,[0001]		; bx=E626H
mov ax,bx			; ax=E626H
mov ax,[0000]		; ax=2662H
mov bx,[0002]		; bx=D6E6H
add ax,bx			; ax=FD48H	
add ax,[0004]		; ax=FD48H+2ECCH=2C14H	有溢出
mov ax,0			; ax=0H
mov al,[0002]		; al=E6H ax=00E6H
mov bx,0			; bx=0H
mov bl[000c]		; bl=26H bx=0026H
add al,bl			; al=0CH ax=000CH	al=al+bl 有溢出
```

> 提示，注意ds的设置



##### 2.

内存中的情况如图3.6所示

各寄存器的初始值：CS=2000H，IP=0，DS=1000H，AX=0，BX=0；

①写出CPU执行的指令序列（用汇编指令写出）

②写出CPU执行每条指令后，CS、IP和相关寄存器中的数值

③再次体会：数据和程序有区别吗？如何确定内存中的信息哪些是数据，哪些是程序？

![image-20211217164219254](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211217164219254.webp)

**初始值：CS=2000H，IP=0，DS=1000H，AX=0，BX=0；**CS*16+IP=20000H(当前读取指令的物理地址)

1. 执行 **mov ax,6622H**	ax=6622H，IP=3
2. **jmp 0ff0:0100**    0ff0H*16+0100H=10000H    IP=5
3. IP=0100H，**mov ax,2000H**      ax= 2000H    IP=103H
4. **mov ds,ax**     ds=2000H，IP=0105H
5. **mov ax,[0008]**    2000H*16+0008H=20008H    ax=C389H，IP=0108H
6. **mov ax,[0002]**    2000H*16+2=20002H   ax=EA66     IP=010BH

| 步骤   | 指令序列      | CS    | IP   | DS    | AX    | BX   |
| ------ | ------------- | ----- | ---- | ----- | ----- | ---- |
| 初始值 | 指令          | 2000H | 0    | 1000H | 0     | 0    |
| 1      | mov ax,6622H  | 2000H | 3H   | 1000H | 6622H | 0    |
| 2      | jmp 0ff0:0100 | ff0H  | 100H | 1000H | 6622H | 0    |
| 3      | mov ax,2000H  | ff0H  | 103H | 1000H | 2000H | 0    |
| 4      | mov ds,ax     | ff0H  | 105H | 2000H | 2000H | 0    |
| 5      | mov ax,[8]    | ff0H  | 108H | 2000H | c389H | 0    |
| 6      | mov ax,[2]    | ff0H  | 10bH | 2000H | ea66H | 0    |

> **CS:IP指向的信息是指令(程序)；DS+偏移指向的信息是数据**



#### 检测点 3.2

##### 1.

（1）补全下面的程序，使其可以将10000~1000FH中的8个字，逆序复制到20000H-2000FH中。逆序复制的含义如图3.17所示（图中内存里的数据均为假设）。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211220100430363.webp" alt="image-20211220100430363" style="zoom:67%;" />

```asm
; 定义数据段
mov ax,1000H
mov ds,ax

; 定义栈段
mov ax,2000H
mov ss,ax
mov sp,10H

; 将数据段的内容入栈到栈段
push [0]
push [2]
push [4]
push [6]
push [8]
push [A]
push [C]
push [E]
```

##### 2.

（2）补全下面的程序，使其可以将10000H-1000FH中的8个字，逆序复制到20000~2000FH中。

```asm
mov ax,2000H
mov ds,ax

mov ax,1000H
mov ss,ax
mov sp,0

; 将数据栈的内容出栈到栈段
pop [E]
pop [C]
pop [A]
pop [8]
pop [6]
pop [4]
pop [2]
pop [0]
```



#### 实验

```asm
; 设置数据段
mov ax,ffff
mov ds,ax
; 设置栈段
mov ax,2200
mov ss,ax

mov sp,0100		; 这个debug用t单步执行时好像不见了？？？

mov ax,[0]	; ffff:0的数据移动到ax ax=C0ea
add ax,[2]	; 将ffff:2数据加到ax c0ea+0012=c0fc
mov bx,[4]	; bx=30f0
add bx,[6]	; 将ffff:6数据加到bx 30f0+2f31=6021

; 我之前跑到 2200:0100去查了，结果查不到
push ax		; ss=2200 sp=00fe 修改的内存单元的地址是：2200:00fe，内容为c0fc
push bx		; sp=00fc 修改的内存单元的地址是：2200:00fc，内容为6021
pop ax		; ax=6021 sp=00fe
pop bx		; bx=c0fc sp=0100

push [4]	; ss=2200 sp=00fe 修改的内存单元的地址是：2200:00fe，内容为30f0
push [6]	; sp=00fc 修改的内存单元的地址是：2200:00fc，内容为2f31
```

### 检测点 4

#### 实验

**（1）将下面的程序保存为t1.asm文件，将其生成可执行文件 t1.exe**

```asm
assume cs:codesg
codesg segment

	; 初始化栈段
	mov ax,2000H
	mov ss,ax
	mov sp,0
	add sp,10		; ax=2000H,ss=2000H,sp=000A
	
	pop ax			; ax=0H sp=0c	每出栈一次，之前的元素从0变成了有值
	pop bx			; ax=0H bx=0H sp=000E
	push ax			; sp=c	每入栈一次将有值变成了0
	push bx			; sp=a
	pop ax			; 出栈，原始值又变回来了 不在是0，但是栈顶还是0
	pop bx

codesg ends
end
```

（2）用 Debug跟踪t1.exe的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容。

（3）PSP的头两个字节是CD20，用 Debug加载t1.exe，查看PSP的内容。





### 检测点 5

#### 检测点 5.1

##### 1.

（1）编程，向内存 0:200-0:23F 依次传送数据0~63(3FH)。

```asm
assume cs:codesg

codesg segment

    ; 编程，向内存 0:200-0:23F 依次传送数据0~63(3FH)。
    ; 0:200 => 0020:0
    mov ax,0
    mov ds,ax
    mov bx,200H
    mov cx,64       ; 循环64次

s:  mov [bx],ax

    inc bx
    inc ax
    loop s
    
    mov ax,4c00h
    int 21h

segment ends

end
```

> 检查：1.先单步跑一遍循环，进行初始化；
>
> 2.一次循环后使用命令：d 0:200   查看内存值是否在变化；
>
> 3.使用u命令查看当前汇编指令，查到“mov ax,4c00h”的地址（比如：204D:0011）
>
> 4.使用命令  g 204D:0011  让汇编程序直接执行到程序返回
>
> 5.再次查看   d 0:200  查看是否有 0-3F 的数据

（2）编程，向内存0:200~0:23F依次传送数据0-63（3FH），程序中只能使用9条指令，9条指令中包括“mov  ax,4c00h”和“int 2lh”。

```asm
assume cs:code

code segment
    mov ax,0000H
    mov ds,ax
    mov bx,200H 	; 数据段与偏移量
    
    mov cx,64		; 循环次数
    
s: 	mov [bx],bl		; 因为bx是不断自增的量，0-63(3F)不超过256，所以bl会处于这段值
    inc bx
    loop s  
    
    mov ax,4c00h
    int 21h
code ends

end
```

（3）下面的程序的功能是将“mov  ax,4co0h”之前的指令复制到内存0:200处，补全程序。上机调试，跟踪运行结果。

```asm
assume cs:codesg
codesg segment
;向内存0:200~0:23f依次传送数据0~63(3fh)
;分析0000:0200~00000:023f
    mov ax,cs		; 运行到此指令时，cs:ip指向这里；而我们需要将程序指令赋值到 0:200-0:23f 所以需要将cs段寄存器内容移到ds段寄存器中
    				; 只是我没想到，两个段寄存器不能直接移动。mov ds,cs 会报错
    mov ds,ax		
    
    mov ax,0020h	; 0:200 => 0020:0
    mov es,ax		; 目标段寄存器
    
    mov bx,0		; 偏移量
    mov cx,17h		; debug 后 -u 查看到mov ax,4c00h 开始的offset是17(16进制)，所以应该是mov cx,17h.不要少了h,不然就是10进制了。
    				; cx本来存储的是整个程序的大小，减去两条程序返回的指令(共5字节)
    				; 通过调试：cx=1C   1C-5 = 17h
    
s:  mov al,[bx]
	mov es:[bx],al

    inc bx
    loop s
    
    mov ax,4c00h
    int 21h

segment ends
end
```

> 提示：
>
> （1）复制的是什么？从哪里到哪里？赋值的是程序指令，从cs:ip开始到 “mov ax,4c00h”
>
> （2）复制的是什么？有多少个字节？你如何知道要复制的字节的数量？cx中存储程序的字节数



### 检测点 6

#### 检测点 6.1

##### 1.

下面的程序实现依次用内存0:0-0:15单元中的内容改写程序中的数据，完成程序

```asm
assume cs:codesg
codesg segment
		; 用内存 0:0-0:15 依次替代下面定义的数据
		dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h	; 定义数据
		
start:	mov ax,0
		mov ds,ax
		mov bx,0		; 让数据段指向 0:[bx]
		
		mov cx,8
	s:	mov ax,[bx]		; 将 ds:[bx] 数据存入ax
		mov cs:[bx],ax	; 将ax(内存0-15单元)替代cs:0-15单元(程序中的数据)
		add bx,2
		loop s
		
		; 程序返回...
codesg ends
end start
```

##### 2.

（2）下面的程序实现依次用内存0:0-0:15单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置在程序内。完成程序

```asm
assume cs:codesg
codesg segment
		; 用内存 0:0-0:15 依次替代下面定义的数据  用栈实现
		dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h	; 定义数据
		dw 0,0,0,0,0,0,0,0,0,0	; 定义栈空间
		
start:	mov ax,cs		; 或 mov ax,codesg
		mov ss,ax
		mov sp,24h		; 或 mov sp,36(2*8+2*10) 让栈段指向我们定义的栈空间区域
		
		mov ax,0
		mov ds,ax
		mov bx,0		; ds数据段指向0:0-0:15
		
		mov cx,8
	s:	push [bx]		; 入栈
		pop cs:[bx]		; 出栈
		add bx,2
		loop s
		
		; 程序返回...
codesg ends
end start
```

#### 实验5

1）将下面的程序编译、连接，用 Debug加载、跟踪，然后回答问题。

```asm
assume cs:code,ds:data,ss:stack

data segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
    dw 0,0,0,0,0,0,0,0
stack ends

code segment
start:  mov ax,stack
        mov ss,ax
        mov sp,16       ; ss指向栈顶

        mov ax,data
        mov ds,ax       ; ds指向数据区域

        push ds:[0]     ; 入栈 0123h
        push ds:[2]     ; 入栈 0456h
        pop ds:[2]      ; 出栈 0456h 到ds:[2]
        pop ds:[0]      ; 出栈 0123h 到ds:[0]

        mov ax,4c00h
        int 21h
code ends

end start
```

①CPU执行程序，程序返回前，data段中的数据为多少？

> data：0123h,0456h,0789h,0abch,0defh,0cbah,0987h   data里的数据并没有发生变化

②CPU执行程序，程序返回前，cs= <u>204F</u> 、ss= <u>204E</u> 、ds= <u>204D</u> 

③设程序加载后，code段的段地址为X，则data段的段地址为 <u>X-2</u>，stack段的段地址为 <u>X-1</u>

> 大概因为先分配的data段，后分配stack段，最后执行code段？



（2）将下面的程序编译、连接，用 Debug加载、跟踪，然后回答问题。

```asm
assume cs:code,ds:data,ss:stack
; 
data segment
    dw 0123h,0456h
data ends

stack segment
    dw 0,0
stack ends

code segment
start:  mov ax,stack
        mov ss,ax
        mov sp,16       

        mov ax,data
        mov ds,ax       ; ds指向数据区域

        push ds:[0]     ; 入栈 0123h
        push ds:[2]     ; 入栈 0456h
        pop ds:[2]      ; 出栈 0456h 到ds:[2]
        pop ds:[0]      ; 出栈 0123h 到ds:[0]

        mov ax,4c00h
        int 21h
code ends

end start
```

和之前的程序相比，data 和stack段的数据长度变小了，那么我们来看一下内存的占用吧

![image-20211222111633075](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211222111633075.webp)

可见，CS没有发生变化，这里类似于数据对齐，**一个段的开头一定是X:0的形式**

> 204D*16+0020 = 204F0

① CPU执行程序，程序返回前，data段中的数据为多少？

> data：0123h,0456h   data里的数据并没有发生变化

② CPU执行程序，程序返回前，cs= <u>204F</u> 、ss= <u>204E</u> 、ds= <u>204D</u> 

③ 设程序加载后，code段的段地址为X，则data段的段地址为 <u>X-2</u>，stack段的段地址为 <u>X-1</u>

④ 对于如下定义的段

```asm
name segment
...
name ends
```

如果段中占用N个字节，则程序加载后，实际占有空间为 <u>16字节</u>
$$
\lceil \frac{N}{16} \rceil\times16
$$
  **(说白点就是向上凑够16个）**



（3）将下面的程序编译、连接，用 Debug加载、跟踪，然后回答问题。

```asm
assume cs:code,ds:data,ss:stack

code segment 
start:	mov ax,stack
		mov ss,ax
		mov sp,16
		
		mov ax,data
		mov ds,ax
		
		push ds:[0]
		push ds:[2]
		pop ds:[2]
		pop ds:[0]
		
		mov ax,4c00h
		int 21h
code ends

data segment
	dw 0123h,0456h
data ends

stack segment
	dw 0,0
stack ends

end start
```

① CPU执行程序，程序返回前，data段中的数据为多少？

> data：0123h,0456h   data里的数据并没有发生变化

② CPU执行程序，程序返回前，cs= <u>204D</u> 、ss= <u>2051</u> 、ds= <u>2050</u> 

> 未执行程序前：cs= <u>204D</u> 、ss= <u>204D</u> 、ds= <u>203D</u> 

③ 设程序加载后，code段的段地址为X，则data段的段地址为 <u>X+3</u>，stack段的段地址为 <u>X+4</u>

> 果然跟段的使用位置的摆放有关系



（4）如果将上面3题中的最后一条伪指令 “end start” 改为 “end”（也就是说：不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。

> 不指明程序入口，那么程序会直接从最开始运行，所以只有（3）可以正常运行



（5）程序如下，编写 code 段中的代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。

```asm
assume cs:code

; 定义三个数据段 每个数据段最少占16字节
a segment
	db 1,2,3,4,5,6,7,8
a ends
b segment
	db 1,2,3,4,5,6,7,8
b ends
c segment	
	db 0,0,0,0,0,0,0,0	; 估计想达到的效果：2，4，6...
c ends

code segment 
start:
	mov ax,a
	mov ds,ax
	
	mov cx,8
	mov bx,0
	
	; 先定位到c段 即：bx+20h 然后将ds:[bx]的值累加进去
s:	;add [bx+20h],[bx]	; add [bx+20h] c段  证明不能这样使用
	mov ax,[bx]			; 先缓存一下 ds:[0]的值
	add bx,20h			; 定位到c段 即ds:[0+20h]
	add [bx],ax			; 将 ds:[0] 加到 ds:[0+20h] 即：将a段的元素累加到c段
	
	sub bx,10h			; 定位到b段
	mov dx,[bx]			; 将b段 ds:[0+10h]的值缓存一下
	add bx,10h			; 再次定位到c段
	add [bx],dx			; 将 ds:[0+10h] 加到 ds:[0+20h] 即：将b段的元素累加到c段
	
	sub bx,20h			; 复原bx到a段
	inc bx				; 下一个元素
; 重复运算了，inc bx可以写两遍，因为题目给的数据是db，是一个字节一个数，每次循环如果用ax不用al的话，相当于直接让相邻两个字节的数分别相加，有重复运算，所以直接再补一个inc bx就好，然后cx改成4。
	loop s

code ends

end start
```

![image-20211222115437797](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211222115437797.webp)

> 如图：204d:0 是a段  204d:10 是b段  204d:20 是c段
>
> 第一步：测试，是否一次性加了两个

![image-20211222134043474](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211222134043474.webp)

> 第一次循环确实加了2个，继续向下循环时，结果不正确了；因为bx++，第二次循环，bx从1位置读2个字节，依次相加；所以不正确了
>
> 解决：要么用al进行缓存和累加，要么对bx自增两次 减少一半的循环次数

正解：

```asm
assume cs:code

; 定义三个数据段
a segment
	db 1,2,3,4,5,6,7,8
a ends
b segment
	db 1,2,3,4,5,6,7,8
b ends
c segment	
	db 0,0,0,0,0,0,0,0	; 估计想达到的效果：2，4，6...
c ends

code segment 
start:
	mov ax,a
	mov ds,ax
	
	mov cx,4			; 由于用字型累加，一次性加俩，所以循环次数需要少一半
	mov bx,0
	
	; 先定位到c段 即：bx+20h 然后将ds:[bx]的值累加进去
s:	; add [bx+20h],[bx]	; add [bx+20h] c段  证明不能这样使用
	; 可以先 mov ax,[bx]  然后 add [bx+20h],ax 这么使用
	mov ax,[bx]			; 先缓存一下 ds:[0]的值
	add bx,20h			; 定位到c段 即ds:[0+20h]
	add [bx],ax			; 将 ds:[0] 加到 ds:[0+20h] 即：将a段的元素累加到c段
	
	sub bx,10h			; 定位到b段
	mov ax,[bx]			; 将b段 ds:[0+10h]的值缓存一下
	add bx,10h			; 再次定位到c段
	add [bx],ax			; 将 ds:[0+10h] 加到 ds:[0+20h] 即：将b段的元素累加到c段
	
	sub bx,20h			; 复原bx到a段
	inc bx				
	inc bx				; bx自增两次 定位到下个字的位置
	loop s

code ends

end start
```

当学习了7.5之后，我们可以利用 [bx+idate] 的方式来访问内存，可以化简我们的程序

```asm
start:
	mov ax,a
	mov ds,ax
	
	mov cx,4
	mov bx,0
	
s:
	mov ax,ds:[bx]		; 缓存 a段值
	mov ds:20h[bx],ax	; 将a段值移入c段
	mov ax,ds:10h[bx]	; 缓存 b段值
	
	add ax,ds:20h[bx]	; 将c段值累加到ax  从而实现 a段+b段
	mov ds:20h[bx],ax	; 将 a段+b段 的结果赋值到c段
	; 不知道是否可以 add ds:20h[bx],ax  可以
	
	inc bx
	inc bx
	loop s
code ends
```



（6）程序如下，编写code段中的代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。

```asm
assume cs:code

a segment
	dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
a ends
b segment
	dw 0,0,0,0,0,0,0,0
b ends

code segment 
start:	mov ax,b
		mov ss,ax	; 栈空间
		mov sp,10h
		
		mov ax,a
		mov ds,ax
		
		mov bx,0
		mov cx,8
	s:	push [bx]
		inc bx
		inc bx	; 由于是字型的，所以要自增两次，或者直接 add bx,2
		loop s
code ends

end start
```

![image-20211222140459886](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211222140459886.webp)

> 初始情况

![image-20211222140548543](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211222140548543.webp)



### 检测点 7



### 检测点 8		综合运用

#### 检测点 8.1



#### 实验 7 寻址方式在结构化数据访问中的应用

<!-- emmm,题目还是从书里面找吧，太多了。在书的第八章的实验7 -->

1.将数据段中分散的信息，按格式摆好     [实验程序](C:\Users\xuan\Desktop\code\asm\worker09_renew.asm)

2.统一计算

```asm
assume cs:codesg,ds:data,ss:stack
; 计算21年中的人均收入(取整) 按格式保存

data segment
    ;年份
    db '1975', '1976', '1977', '1978', '1979', '1980', '1981', '1982', '1983'
    db '1984', '1985', '1986', '1987', '1988', '1989', '1990', '1991', '1992'
    db '1993', '1994', '1995'
    ;收入
    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514
    dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000
    ;员工
    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226
    dw 11542, 14430, 15257, 17800
data ends

table segment       ; 205b:0
    db 21 dup ('year sumn ne ?? ')
table ends

stack segment
	dw 8 dup(0)
stack ends

codesg segment
start:  
    ; 1. 将data段中分散的数据 按格式存到table段中
    mov ax,data
    mov ds,ax       ; 让ds指向data段
    mov ax,table
    mov es,ax       ; 让es指向table段
    ; 将ds的data段 移动到 es的table段
    mov bx,0        ; 索引
    mov cx,21        ; 有21个年份
    mov si,0

    ; 1.1 先将年份移过去
s0: mov ax,ds:[bx]      ; 这里的bx作为data段的索引
    mov es:[si+0],ax
    mov ax,ds:[bx+2]
    mov es:[si+2],ax    ; 由于年份由4个字符组成，算4字节，所以需要移动两次

    ; 不需要写空格了，因为table段中初始化就附带了空格

    add bx,4            ; 因为一次性复制了4字节，所以直接跳到下一个字符串
    add si,10h          ; 这里的si作为table段的行索引，跳到table段的下一行
    loop s0


    ; 1.2 将收入从ds移到es 因为ds已指向data段 es已指向table段
    mov bx,84           ; data索引 跳过年份 21个年份*4字节=84 
    ;mov si,0           ; 重新定位到table段的行索引
    mov si,5            ; 改进 定位到table段的列索引，这里为table段第0行第5列
    mov cx,21
s1: mov ax,ds:[bx]
    ;mov es:[si+5],ax   ; 当si=0时，这里需要手动跳到第5列
    mov es:[si],ax      ; si在上面已经定位到了第5列
    mov ax,ds:[bx]+2
    ;mov es:[si+2+5],ax ; 收入占了4字节，所以也需要移动两次
    mov es:[si+2],ax    ; 

    add bx,4
    add si,10h
    loop s1


    ; 1.3 将雇员数从ds移到es
    mov bx,168          ; data索引 跳过年份+收入 =84*2=168
    mov si,0Ah          ; 重新定位到table段的行索引 注意：编译器默认10进制 汇编不支持字母开头
    mov cx,21
s2: mov ax,ds:[bx]
    mov es:[si],ax  ; 人员只占2字节，所以只需要移动一次就行.

    add bx,2
    add si,10h
    loop s2

; 上面已经将data段的内容全部移到了table段，接下来需要在table段中计算人均
    ; 2.计算人均
    ; 2.1 定位到table中的收入，定位到table中的人员，定位到table中人均收入的内存空间
    mov bx,0        ; 作为行索引，收入的下标为5 人员的下标为0ah(不懂看书)
    mov si,5        ; 作为列索引，定位到收入的下标
    mov di,0Ah      ; 作为列索引，定位到人员的下标
    mov cx,21

    ; 2.2 收入/人员  是16位的除法，需要用dx+ax存被除数
s3: mov ax,es:[bx+si]     ; ax存低位，es始终在table段
    mov dx,es:[bx+si+2]   ; dx存高位
    ; 至于除数 直接用内存空间吧，没得地方放了
    div word ptr es:[bx+di]
    mov es:[bx+0dh],ax      ; 除完后 商在ax中，所以要将商送入指定位置

    add bx,10h      ; 跳到table的下一行,其实就bx变化了，si和di都可以使用常数代替
    loop s3

    ; 程序返回
    mov ax,4c00h
    int 21h

codesg ends

end start
```

运行结果如下：

![image-20211224101919290](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211224101919290.webp)



### 检测点 9		跳转指令

#### 检测点 9.1		jmp指令

##### 1. 参考9.6 课本

```asm
assume cs:code
data segment
	;?
	dw 2 dup (0)	; 相当于 dw 0,0
data ends

code segment
start:	mov ax,data
		mov ds,ax		
		mov bx,0		; 使 ds:bx 指向code段的0索引
		jmp word ptr [bx+1]	; 从1索引读取字型作为 jmp的跳转地址
		; 如果 data中全是0，那么 ds:[bx+1]=0 ,则 jmp word ptr 0，执行后 (ip)=0h
		; 首先，一个段必先从 段地址:0 开始，也就是说，程序开始前，cs:ip => cs:0 指向程序的第一条指令
		; 这里通过jmp 跳转重新修改ip的值，设0，也就继续指向了程序的第一条指令
code ends
end start
```

若要使程序中的 jmp 指令执行后，CS:IP指向程序的笫一条指令，在data段中应该定义哪些数据？

> 答案① db 3 dup (0)		答案②dw 2 dup (0)		答案③dd 0
>
> jmp word  ptr [bx+1] 为段内转移，要 cs:ip 指向程序的第一条指令，应设置 ds:[bx+1] 的字单元（2个字节）存放数据应为0，则 (ip)=ds:[bx+1]=0 
>
> 简单来说就是，只要 ds:[bx+1] 起始地址的两个字节为0就可以了
>
> **段内转移：只修改 ip 的值**

##### 2.

```asm
assume cs:code
data segment
	dd 12345678H
data ends

code segment
start:	mov ax,data
		mov ds,ax		
		mov bx,0		; 使 ds:bx 指向code段的0索引
		; ;或mov[b×].word_ptr0;或mov[bx],offset startmov[bx+21,cs Pimov[bx+ 2],cs;Mov[bx+2],seg code
		mov [bx],word ptr 0		; 只输入0不行，0只是字节型的，段间转，存低地址，即(ip的指向)
        						; 或 mov [bx],bx  或 mov [bx],offset start
		mov [bx+2],cs			; 如果是段间转移，这里放的是高地址 即目标段地址(cs的指向)
								; 我们将旧cs地址设置过去，那么下次指向段间jmp时，不就取到原cs了么
								; 或 mov [bx+2],seg code
								
		jmp dword ptr ds:[0]	; 通过上面的设置，jmp将 cs:ip => cs:0 从而指向第一条指令
code ends
end start
```

补全程序，使jmp指令执行后，CS:IP指向程序的第一条指令。

**解析**

> 段间转移，同时修改 cs:ip        (cs) = 内存单元地址+2    (ip)=内存单元地址
>
> jmp dword ptr  ds: [0] 为段间转移，(cs)=(内存单元地址+2)、(ip)=(内存单元地址)。指执行段间转后，cs:ip的指向
>
> 要 cs:ip 指向程序的第一条指令，第一条程序地址 cs:0，应设置CS:IP指向cs:0
>
> 程序中的 mov bx,bx 这条指令，是将ip设置为0
>
> mov [bx+2],cs，将 cs 这个段地址放入内存单元执行后，cs应该不变，只调整ip为0
>
> 从而实现：cs:ip => cs:0

##### 3.

用 Debug查看内存，结果如下：	2000:1000    BE 00 06 00 00 00 ...

cpu执行指令后，(cs)=0006H，(ip)=00beH

```asm
mov ax,2000h
mov es,ax
jmp dword ptr es:[1000h]	; 读取双字 0006 00be
```

另外，此题目的检测目的就是将内存中的数据作为跳转的CS和IP的值来进行跳转。对于给定的一个地址A，A开始的一个字单元是 IP，A+2开始的一个字段单元是CS。也就是以A为起始地址的内存中，低字单元是IP，高字单元是CS。

> 用debug跟踪，结果不一致？看解答此题的作者[分析](https://blog.csdn.net/qq_42777804/article/details/90512159)



#### 检测点 9.2	jcxz 指令

补全编程，利用 jcxz 指令，实现在内存 2000H 段中查找第一个值为 0 的字节，找到后，将它的偏移地址存储在dx中

```asm
assume cs:code

code segment
start:	mov ax,2000h
		mov ds,ax
		mov bx,0
		
		; s标号处相当于一个循环 找到第一个值为0的
	s:	mov ch,0	; 由于是查找字节型的，必须保证cx中的高地址为0
		mov cl,[bx]	; 将2000h段中的字节数据送入 cx的低地址
		jcxz ok		; 由于cx高地址为0，当低地址为0，代表cx=0，执行此指令 使cs:ip指向ok
		inc bx
		jmp short s	; 艹，我沙雕了，将jmp看成是条件转移了，始终跳转到s标号处
		
	ok:	mov dx,bx
	; 程序返回...
code ends
end start
```



#### 检测点 9.3	loop 指令

补全编程，利用 loop 指令，实现在内存2000h段中查找第一个值为0的字节，找到后，将它的偏移地址存储在dx中

```asm
assume cs:code

code segment
start:	mov ax,2000h
		mov ds,ax
		mov bx,0
		
		; s标号处相当于一个循环 找到第一个值为0的
	s:	mov cl,[bx]
		mov ch,0
		inc cx		; 懂了，cl=ds:[bx]，万一cl=0了，则cx=0，执行loop时，先cx-1，再判断cx是否为0
				 ; 所以这里要始终保持cx>0，才能顺利的终止循环。不然cx=0，loop时cx先减1(cx变成FFFF)
		inc bx
		loop s
		
	ok:	dec dx,bx	; dec指令的功能和inc相反，dec bx进行的操作为：(bx)=(bx)-1，即自减
		mov dx,bx
	; 程序返回...
code ends
end start
```

#### 实验 8 分析一个奇怪的程序(有点坑)

分析下面的程序，在运行前思考：这个程序可以正确返回吗？

运行后再思考：为什么是这种结果？运行结果主要在下面标出的3个注意中产生

通过这个程序加深对相关内容的理解。

```asm
assume cs:codesg
codesg segment
	; 程序返回
	mov ax,4c00h
	int 21h
	
start:	mov ax,0
	s:	nop		; 第一个注意指令的前后，注意这里的结果！！！
		nop
		
		mov di,offset s		; di指向s的地址
		mov si,offset s2	; si指向s2的地址
		mov ax,cs:[si]
		mov cs:[di],ax		; 将s2的指令移到s中，注意这条指令！！！
		
	s0:	jmp short s			; 跳到s
		
	s1:	mov ax,0
        int 21h
        mov ax,0
	
	s2:	jmp short s1		; 跳到s1，注意这条指令！！！
		nop

codesg ends
end start
```

> 首先，程序从start开始，即cpu执行的第一条指令是  mov ax,0

将程序debug看一下翻译成的机器指令

![image-20211224135459297](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211224135459297.webp)

> 我们可以看到，mov di,offset s   被翻译成了   mov di,0008，而 mov si,offset s2 被翻译成了  mov si,0020
>
> 据我们看原码的分析是，s段，将s2开头的两个字节指令复制到了s的开头，填充nop指令

![image-20211224140507622](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211224140507622.webp)

此时准备将s2段的2个字节复制到ax，我们来看一下 F6EB 对应哪里

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211224140639094.webp" alt="image-20211224140639094" style="zoom:67%;" />

再执行

![image-20211224140822843](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211224140822843.webp)

查看一下

![image-20211224141232896](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211224141232896.webp)

可以看到，这个s段的nop被成功的替换成了，接下来就准备执行 jmp 0008（jmp short s）

然后执行  jmp  0000 ，然后又跳到了 程序返回处

> 不过我们要研究，为什么，把 jmp 0018拷贝到s段后，变成了 jmp 0000
>
> 噢噢，我知道了，主要还是看机器码。在s2段的 jmp short s1 翻译成了  EBF6   jmp 0018(其实这是编译器根据前面的机器码优化成的汇编指令展示)
>
> 8位位移 = 标号处的地址 - jmp指令后的第一个字节地址；
>
> **EBF6：如果用jmp执行，意思是 向前跳转10个字节**；(补码 F6=-10，10字节=0ah)；计算机是将 (IP)+10
>
> 即：此时的 jmp 向前跳10个字节，刚好就是s1的地址值，于是被u指令翻译成了，jmp 0018
>
> **但是，由于 s2 段的指令被复制到了s段，注意：内存中存储的没有指令，只有数据，所以这是将 s2段的数据 EBF6复制到了s段，于是u命令一翻译 204d:0008处的向前跳转10个字节，刚好就跳到了程序开头** ，于是被翻译成 jmp 0000

总结一下：**内存中存储的没有指令，只有数据(被翻译成16进制的机器码)；所以，<font color="red">复制的从来不是什么指令，而是机器码</font>，而cpu读到对应行的机器码，执行对应功能**

所以遇到这个从相对位置偏移或位移的计算要小心



#### 实验 9 根据材料编程(跟显存相关了)

编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串 “welcome to masm！”

编程所需的知识通过阅读、分析下面的材料获得。

> 80×25 彩色字符模式显示缓冲区(以下简称为显示缓冲区)的结构：
>
> 内存地址空间中，B8000H~BFFFFH 共 32KB 的空间，为 80×25 彩色字符模式的显示缓冲区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。
>
> 在80×25彩色字符模式下，显示器可以显示 25 行，每行 80 个字符，每个字符可以有 256 种属性（背景色、前景色、闪烁、高亮等组合信息）。
>
> 这样，**一个字符在显示缓冲区中就要占两个字节，分别存放字符的 ASCII 码和属性**。80×25 模式下，一屏的内容在显示缓冲区中共占 4000 个字节。(25\*80\*2=4000B)
>
> 显示缓冲区分为8页，每页 4KB(≈4000B)，显示器可以显示任意一页的内容。一般情况下，显示第 0 页的内容。也就是说**通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上**。
>
> 

```properties
在一页显示缓冲区中:
偏移 000~09F 对应显示器上的第1行（80个字符占160个字节）；
偏移 0A0~13F 对应显示器上的第2行；
偏移 140~1DF 对应显示器上的第3行；
依此类推，可知，偏移 F00~F9F 对应显示器上的第25行。
```

**在一行中，一个字符占两个字节的存储空间（一个字），低位字节存储字符的 ASCII 码，高位字节存储字符的属性。一行共有80个字符，占160个字节。**

```properties
即在一行中:
00~01 单元对应显示器上的第1列
02~03 单元对应显示器上的第2列
04~05 单元对应显示器上的第3列
依此类推，可知，9E~9F单元对应显示器上的第80列。
```



例：在显示器的0行0列显示黑低绿色的字符串 'ABCDEF' （'A' 的ASCII码值为41H，02H表示黑底绿色）

显示缓冲区里的内容为：

```asm
		   00 01 02 03 04 05 06 07 08 09 0a 0b ... 0e 0f	; 位置
b800:0000  41 02 42 02 43 02 44 02 45 02 46 02 ... .. ..	; 存放的数据
..
..
b800:00a0  .. .. .. .. .. .. .. .. .. .. .. .. ... .. ..
```

> 可以看出，**在显示缓冲区中，偶地址存放字符，奇地址存放字符的颜色属性**

一个在屏幕上显示的字符，具有前景（字符色）和背景（底色）两种颜色，字符还可以以高亮度和闪烁的方式显示。前景色、背景色、闪烁、高亮等信息被记录在属性字节中。

```asm
属性字节的格式：
	     7    6 5 4   3    2 1 0
含义  	BL   R G B   I    R G B	
	    闪烁   背景    高亮  前景
R：红色
G：绿色
B：蓝色
可以按位设置属性字节，从而配出各种不同的前景色和背景色
```

> 比如：
>
> 红底绿字，属性字节为：01000010B
>
> 红底闪烁绿字，属性字节为：11000010B；
>
> 红底高亮绿字，属性字节为：01001010B；
>
> 黑底白字，属性字节为：0000011B
>
> 白底蓝字，属性字节为：01110007B。



例：在显示器的0行0列显示红底高亮闪烁绿色的字符串 'ABCDEF'（红底高亮闪烁绿色，属性字节为: 11001010B，CAH）

显示缓冲区里的内容为：

```asm
		   00 01 02 03 04 05 06 07 08 09 0a 0b ... 0e 0f	; 位置
b800:0000  41 ca 42 ca 43 ca 44 ca 45 ca 46 ca ... .. ..	; 存放的数据
..
..
b800:00a0  .. .. .. .. .. .. .. .. .. .. .. .. ... .. ..
```

> 注意，闪烁的效果必须在全屏DOS方式下才能看到



### 检测点 10

#### 检测点 10.1

补全程序，实现从内存 1000:0000 处开始执行指令

```asm
assume cs:code
stack segment
	db 16 dup (0)
stack ends

code segment
s:	mov ax,stack
	mov ss,ax
	mov sp,16	; 定位到栈顶，栈顶为空
	
	mov ax,1000h
	push ax		
	mov ax,0	; 将0送入栈中，栈顶为0
	push ax
	retf		; 出栈的第一元素送入IP，出栈的第二元素送入CS
code ends
end s
```



#### 检测点 10.2		call指令(注意点)

下面的程序执行后，ax中的数值为多少？

```asm
内存地址	机器码			汇编指令
1000:0		b8 00 00	mov ax,0	; ax=0,ip=3
1000:3		e8 01 00	call s		; call => push ip,jmp near ptr s	所以栈顶是3还是6？
1000:6		40 			inc ax
1000:7		58			s:pop ax	; 栈顶给ax，ax=6
```

```asm
;程序：
assume cs:code
code segment

start:   mov ax,0	; 执行完这条指令：ax=0,ip=3
         call s		; 执行完这条指令：ax=0,ip=7，跳到s准备执行下条指令
         			; 由此可见，步骤：执行此指令前ip=3；读取3字节机器码,ip=6；cpu执行机器码(call指令):push ip(所以此时ip=6已入栈),jmp near ptr s(此时ip=7,通过位移找到s的位置，然后修改到ip中)
         inc ax
    s:   pop ax		; 执行完这条指令：ax=6,ip=8

code ends
end start
```

debug：

![image-20211224160949250](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211224160949250.webp)

**用 debug 进行跟踪确认，“call 标号“ 是将该指令后的第一个字节偏移地址入栈，再转到标号处执行指令。**



#### 检测点 10.3		

下面的程序执行后，ax中的数值为多少？

```asm
内存地址	机器码				汇编指令
1000:0	  b8 00 00			mov ax,0	; ax=0,ip=3
1000:3	  9a 09 00 00 10	call far ptr s	; push cs,push ip,jmp far ptr s	
											; 栈：8h(栈顶 对应ip) 1000h(对应cs)
1000:8	  	40 				inc ax
1000:9	 	58				s:pop ax	; 栈顶给ax，ax=8h
							  add ax,ax	; ax=10h
							  pop bx	; bx=1000h
							  add ax,bx	; ax=1010h
```

用 debug进行跟踪确认，“call far ptr  s” 是先将该指令后的第一个字节段地址 cs=1000 入栈，再将偏移地址 jp=8h 入栈，最后转到标号处执行指令。

出栈时，根据栈先进后出的原则，先出的为 ip=8h，后出的为 cs=1000h



#### 检测点 10.4

下面的程序执行后，ax中的数值为多少？

```asm
内存地址	机器码			汇编指令
1000:0		b8 06 00	mov ax,6	; ax=6,ip=3
1000:3		ff d0		call ax		; push ip,jmp 6(ax的值) 栈:5  ip=6,跳s
1000:5		40 			inc ax		
1000:6					mov bp,sp	; bp = sp = fffeh(因为已有元素入栈了)
						add ax,[bp]	; 这里的[bp]表取栈顶元素 ax=[6+ds:(fffeh)]=6+5=0bh
```

用debug进行跟踪确认，“call ax(16位reg)”是先将该指令后的第一个字节偏移地址ip入栈，再转到偏移地址为ax(16位reg)处执行指令。



#### 检测点 10.5

（1）下面的程序执行后，ax 中的数值为多少？（注意：用 call 指令的原理来分析，不要在 Debug 中单步跟踪来验证你的结论。对于此程序，在  Debug 中单步跟踪的结果，不能代表CPU的实际执行结果。）

```asm
assume cs:code
stack segment
     dw 8 dup (0)
stack ends

code segment
start:   mov ax,stack
         mov ss,ax
         mov sp,16		; 指向栈顶
         
         mov ds,ax		; ds也指向了栈
         mov ax,0
         call word ptr ds:[0eh]	; 先将ip入栈,然后将 ds:[0eh] 赋值给ip,
         inc ax			; ip = 11
         inc ax
         inc ax
code ends
end start
```

推算：

执行call word ptr ds:[0eh]指令时，ip=11入栈，然后ip转移到(ds:[0eh])。(ds:[0eh])=11h，而下条指令的ip也是11h，于是继续向下继续执行inc ax……最终ax=3

> 题中特别关照别用debug跟踪，跟踪结果不一定正确，但还是忍不住去试试，看是什么结果。
>
> 根据单步跟踪发现，执行call word ptr ds:[0eh]指令时，显示ds:[0eh]＝065D。
>
> ds:0000~ds:0010不是已设置成stack数据段了嘛，不是应该全都是0的嘛。
>
> 于是进行了更详细的单步跟踪，发现初始数据段中数据确实为0，但执行完mov ss,ax；mov sp,16这两条指令后，数据段中数据发生改变。这是为什么呢？中断呗~~~~

（2）下面的程序执行后，ax和bx中的数值为多少？

```asm
assume cs:codesg
stack segment
    dw 8 dup (0)
stack ends

codesg segment
start:
    mov ax,stack
    mov ss,ax
    mov sp,10h		; 指向栈顶
    mov word ptr ss:[0],offset s ; s=001ah  (ss:[0])=1ah
    mov ss:[2],cs                ; (ss:[2])=cs  cs=204eh
    
    call dword ptr ss:[0]        ; push cs,push ip,赋值cs:ip达到跳转的效果
    							; push 204eh,push 19h,新cs=(ss:[2]),新ip=(ss:[0])
    							; cs入栈,ip=19h入栈,转到cs:1ah处执行指令
    nop
    
s:  mov ax,offset s              ; ax = 1ah
    sub ax,ss:[0ch]              ; ax = 1ah-(ss:[0ch]) = 1ah-19h = 1
    mov bx,cs                    ; bx = cs = 204eh
    sub bx,ss:[0eh]              ; bx = cs-cs = 0
codesg ends
end start
```



#### 实验 10 编写子程序

在这次实验中，我们将要编写3个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法。同前面的所有实验一样，这个实验是必须独立完成的，在后面的课程中，将要用到这个实验中编写的3个子程序。

##### 1. 显示字符串

###### **问题**

显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能。我们应该提供灵活的调用接口，使调用者可以决定显示的位置（行、列）、内容和颜色。

###### **子程序描述(屏幕输出信息功能printf)**

**名称：**show_str

**功能：**在指定的位置，用指定的颜色，显示一个用 0 结束的字符串。

**参数：**(dh) = 行号(取值范围0\~24)，(dl) = 列号(取值范围0\~79)，(cl) = 颜色，ds:si 指向字符串的首地址

**返回：**无

**应用举例：**在屏幕的8行3列，用绿色显示 data 段中的字符串

```asm
assume cs:code,ds:data
data segment
	db 'Welcome to masm!',0		; 以0结尾的字符串
data ends

code segment
start:	mov dh,8	; 屏幕第8行	dh指示行
		mov dl,3	; 屏幕第3列	dl指示列
		mov cl,2	; 颜色
		
		mov ax,data
		mov ds,ax
		mov si,0	; ds:si指向字符串的首地址
		
		call show_str
		
		mov ax,4c00h
		int 21h
		
; 实现print功能。已知:ds:si是字符串，dx是输出位置，cl是颜色
; 由于是以0代表字符串结束，我们需要不断循环直到0为止，使用jxcz
; 取出当前的字符，输出到指定位置(屏幕输出)，进入下一次循环取下一个字符
show_str:
		; 先保存寄存器值
		push ax
		push bx
		push cx
		push dx
		push si
		
		; 1.先找到要将字符输出的位置 b800:0h开始.0h是第一行,10h是第二行;00~01对应显示器第1列
		;mul dh,10h	; 写法错误 定位到显存中的行 dh*10h 显存中行下标
		mov ah,0
		mov al,dh	; 保证ax中存放一个乘数
		mov dh,10h	; al=dl dl=10h
		mul dh		; 实现 dh*10h  结果在ax中  这是行索引
		
		;mul dl,2	; 写法错误 定位到显存中的列 2*(dl-1) 显存中列下标
		add ax,0b800h	; 移动到对应的显存中的指定行，这里用的add 所以ax已经移动到了显存的指定行下标
		mov es,ax
		sub dl,1
		mov al,dl
		mov dl,2	; al = (dl-1) dl=2
		mul dl		; 2*(dl-1) 结果在ax中  这是列索引
		
		mov bx,ax	; 现在的ax是已解析成显存对应行列的数据
excute: mov al,ds:[si]	; 取出字符放入al ds:[si]是当前字符
		mov ah,cl		; 设置颜色到ah
		
		mov cl,al		; 也将字符存入cx中，当前字符为0 就直接退出
		mov ch,0
		jcxz ok
		
		mov es:[bx],ax	; 将ax输出到显存的行列下标 
		inc si
		jmp short excute
		
	ok:	; 寄存器出栈
		pop si
		pop dx
		pop cx
		pop bx
		pop ax
		ret
		
code ends
end start
```

**提示**

（1）子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，首先要分析一下屏幕上的行列位置和显存地址的对应关系

（2）注意保存子程序中用到的相关寄存器；

（3）这个子程序的内部处理和显存的结构密切相关，但是向外提供了与显存结构无关的接口。通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。在实验中，注意体会这种设计思想。



##### 2. 解决除法溢出的问题

###### **问题**

前面讲过，div指令可以做除法。当进行8位除法的时候，用al存储结果的商，ah存储结果的余数；进行16位除法的时候，用ax存储结果的商，dx存储结果的余数。可是，现在有一个问题，如果结果的商大于al或ax所能存储的最大值，那么将如何？

比如，下面的程序段：

```asm
mov bh,1
mov ax,1000
div bh
; 进行的是8位除法，结果的商为1000，而1000在al中放不下。
```

又比如，下面的程序段：

```asm
mov ax,1000h
mov dx,1
mov bx,1
div bx
```

进行的是16位除法，结果的商为11000H，而11000H在ax中存放不下

我们在用 div 指令做除法的时候，很可能发生上面的情况：结果的商过大，超出了寄存器所能存储的范围。当CPU执行 dⅳ 等除法指令的时候，如果发生这样的情况，将引发 CPU 的一个内部错误，这个错误被称为：**除法溢出**。我们可以通过特殊的程序来处理这个错误，但在这里我们不讨论这个错误的处理，这是后面的课程中要涉及的内容。下面我们仅仅来看一下除法溢出发生时的一些现象，如图10.1所示

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211228142644548.webp" alt="image-20211228142644548" style="zoom:67%;" />

好了，我们已经清楚了问题的所在：用 div 指令做除法的时候可能产生除法溢岀。由于有这样的问题，在进行除法运算的时候要注意除数和被除数的值，比如 1000000/10 就不能用 div 指令来计算。那么怎么办呢？我们用下面的子程序  divdw 解决。



###### **子程序描述(无除法溢出运算)**

**名称：**divdw

**功能：**进行不会产生溢出的除法运算，被除数为 dword 型，除数为 word 型，结果为 dword 型。

**参数：**(ax) = dword型数据的低16位，(dx) = dword型数据的高16位，(cx) = 除数

**返回：**(dx)=结果的高16位，(ax)=结果的低16位，(cx)=余数

**应用举例：**计算 1000000/10 (f4240h/0ah)

```asm
mov ax,4240h
mov dx,000fh	; 被除数的高位
mov cx,0ah		; 除数
call divdw
; 结果：(dx)=0001h，(ax)=86a0h，(cx)=0
```

**提示**

给出一个公式：

X：被除数，范围：[0,ffffffff]

N：除数，范围：[0,ffff]

H：X高16位，范围：[0,ffff]

L：X低16位，范围：[0,ffff]

int()：描述性运算符，取商，比如：int(38/10)=3

rem()：描述性运算符，取余数，比如：rem(38/10)=8

**公式：X/N = int(H/N)\*65536 + [rem(H/N)\*65536+L]/N**

这个公式将可能产生溢出的除法运算：X/N，转变为多个不会产生溢出的除法运算。公式中，等号右边的所有除法运算都可以用div指令来做，肯定不会导致除法溢出。

> （关于这个公式的推导，有兴趣的读者请参看附注5。）

```asm
assume cs:code
code segment
start:	mov ax,4240h
        mov dx,000fh	; 被除数的高位
        mov cx,0ah		; 除数
		call divdw
		
		mov ax,004ch
		int 21h
		
; 公式：X/N = int(H/N)*65536 + [rem(H/N)*65536+L]/N
		; H:高16位,dx中  L:低16位,ax中  N:除数,cx中
divdw:  
		push bx
		
		; H/N => dx/cx 除数可能是8或16位，所以被除数暂定16位，dx是被除数高16位 ax是被除数低16位
		mov bx,ax	; 现在bx是原被除数的低16位
		mov ax,dx
		mov dx,0	; 现在 dx,ax是被除数
		div cx		; 相除 现在 al是商，ah是余数
					; 会采用16位除法，ax=商 dx=余数  因为除数在cx中，cx是2字节(16位)
		
		push ax		; 将商放栈中 
		; 商*65536 + (余数*65536+L)/N
		; 商*65536 相当于把商从16位移到了高16位 因为 65536=10000h
		; 如果16位除法，dx=余数，如果dx认为是高16位，就相当于是做了 余数*65536
		mov ax,bx	; (余数*65536+L) 现在ax是L dx是余数*65536
		div cx		; (余数*65536+L)/N  ax=商 dx=余数
		mov cx,dx	; 保存一下 (余数*65536+L)/N 的余数
		pop dx		; 如果把dx认为是高16位，就相当于做了 *65536的操作，这里把第一次相除的商移到了dx
					; 商*65536
		; 也就是现在算出结果：
		; (dx)=相除后高16位，(ax)=相除后低16位，(cx)=相除后的余数
		
		pop bx
		ret
		
code ends
end start
```

![image-20211228153431988](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211228153431988.webp)



##### 3. 数值显示

###### **问题**

编程，将 data 段中的数据以十进制的形式显示出来。

```asm
data segment
	dw 123,12666,1,8,3,38
data ends
```

**这些数据在内存中都是二进制信息，标记了数值的大小。要把它们显示到屏幕上，成为我们能够读懂的信息，需要进行信息的转化**。

比如，数值12666，在机器中存储为二进制信息：0011000101111010B(317AH)，计算机可以理解它。**而要在显示器上读到可以理解的数值12666，我们看到的应该是<font color="red">一串字符：“12666”</font>**。由于显卡遵循的是  ASCII编码，为了让我们能在显示器上看到这串字符，它在机器中应以ASCII码的形式存储为：

3H、32H、36H、36H、36H（字符“0”~“9”对应的ASCII码为30H-39H）。(这里只代表 12666以字符串的形式显示)

通过上面的分析可以看到，在概念世界中，有一个抽象的数据12666，它表示了一个数值的大小。在现实世界中它可以有多种表示形式，可以在电子机器中以高低电平（二进制）的形式存储，也可以在纸上、黑板上、屏幕上以人类的语言“12666”来书写。现在，我们面临的问题就是，要将同一抽象的数据，从一种表示形式转化为另一种表示形式。

> 可见，要将数据用十进制形式显示到屏幕上，要进行两步工作：
>
> （1）**将用二进制信息存储的数据转变为十进制形式的字符串；**
>
> （2）显示十进制形式的字符串。
>
> 第二步我们在本次实验的第一个子程序中已经实现，在这里只要调用一下 show_str 即可。我们来讨论第一步，因为将二进制信息转变为十进制形式的字符串也是经常要用到的功能，我们应该为它编写一个通用的子程序

###### **子程序描述(数据转字符串输出到屏幕)**

**名称：**dtoc

**功能：**将 word 型数据转变为表示十进制数的字符串，字符串以 0 为结尾符。

**参数：**(ax) = word型数据；ds:si 指向字符串的首地址

**返回：**无

**应用举例：**编程，将数据 12666 以十进制的形式在屏幕的 8 行 3 列，用绿色显示出来。在显示时我们调用本次实验中的第一个子程序 show_str

```asm
assume cs:code
data segment
	db 10 dup (0)
data ends

code segment
start:	mov ax,12666	; 计算机内部会转化成二进制，而展示时以16进制展示，我们的目的，拿到这个值，以10进制方式输出到屏幕上
		mov bx,data
		mov ds,bx
		mov si,0		; 定位到data段
		call dtoc		; 转存十进制形式的字符串格式
		
		; 调用输出的子程序 代码在本实验的第一个子程序
		mov dh,8
		mov dl,3
		mov cl,2
		call show_str	
		
		mov ax,004ch
		int 21h
		
; 转10进制，再转字符串
dtoc:	push dx	; ax是具体值 12666
		push si	; si对应索引
		push cx
		; 循环取出ax的各个位
        push bx
        
        mov cx,0
        push cx		; 将寄存器与十进制的各个位隔开
       	; 循环取各个位
        mov bx,10	; 将bx设置为10 准备循环除10取各个位
    s:	mov dx,0	; 16位除法 高位在dx 低位在ax
        div bx		; 除以10
        push dx		; 将余数入栈，余数就是 十进制的各个位
        mov cx,ax
        jcxz s1		; 如果商为0，就跳出循环
        jmp s

	; 将各个位转化为字符
    s1:
        pop cx
        ; 判断循环条件 循环条件在栈中 这如何判断呢？我想的办法是中间插个0 如果cx=0跳到s2
        jcxz s2
        add cx,30h		; 将十进制转化为字符
        mov ds:[si],cx	; 将字符存到data段中
        inc si
        jmp s1
        

		; 在字符串的最后写入结束符号0
    s2: add si,1
        mov ax,0
        mov ds:[si],ax

        pop bx
        pop cx
        pop si
        pop dx
        ret
code ends
end start
```

**提示**

下面我们对这个问题进行一下简单地分析。

（1）要得到字符串“12666”，就是要得到一列表示该字符串的 ASCII码：3lH、32H、36H、36H、36H。

**十进制数码字符对应的 ASCII码 = 十进制数码值 + 30H。**(30h=48  48=>'0')

要得到表示十进制数的字符串，先求十进制数每位的值(即先转10进制，再将每位转化为字符)

例：对于 12666，先求得每位的值：1、2、6、6、6。再将这些数分别加上 30H，便得到了表示 12666 的ASCII码串：31H、32H、36H、36H、36H。

（2）那么，怎样得到每位的值呢？采用下面的方法：

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211228155611579.webp" alt="image-20211228155611579" style="zoom:67%;" />

> 除10取余。可见，除以10，共除5次，记下每次的余数，就得到了每位的值。

（3）综合以上分析，可得出处理过程如下：

用 12666 除以10，循环5次，记下每次的余数；将每次的余数分别加 30H，便得到了表示十进制数的ASCII码串。如下：

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211228155839141.webp" alt="image-20211228155839141" style="zoom:80%;" />

（4）对第③步的质疑。

在已知数据是 12666 的情况下，知道进行5次循环。可在实际问题中，数据的值是多少程序员并不知道，也就是说，程序员不能事先确定循环次数。

**只要是除到商为0，各位的值就已经全部求出**。可以使用 jcxz 指令来实现相关的功能。

**运行结果：**

![image-20211228164800130](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211228164800130.webp)

![image-20211228164830420](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211228164830420.webp)



### 课程设计 1

任务：将实验7中的 Power idea公司的数据按照图10.2所示的格式在屏幕上显示出来。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211228165110777.webp" alt="image-20211228165110777" style="zoom:67%;" />

在这个程序中，要用到我们前面学到的几乎所有的知识，注意选择适当的寻址方式和相关子程序的设计和应用。

另外，要注意，因为程序要显示的薮据有些已经大于65535，应该编写一个新的数据到字符串转化的子程序，完成  dword 型数据到字符串的转化，说明如下。

**名称：**dtoc

**功能：**将 dword 型数转变为表示十进制数的字符串，字符串以 0 为结尾符

**参数：**(ax)=dword 型数据的低16位，(dx)=dword型数据的高16位，ds:si指向字符串的首地址

**返回：**无

在这个子程序中要注意除法溢出的问题，可以用我们在实验10 中设计的子程序 divdw 来解决。



#### 清屏功能

清屏：若要显示这些数据，不希望被之前的信息所影响，所以先把屏幕清理；

```asm
assume cs:code
stack segment
    dw 16 dup(0)
stack ends

code segment
        start:
            mov ax,stack
            mov ss,ax
            mov sp,16       ; ss:sp 指向栈顶

            mov ax,0b800h   ; 显存地址
            mov es,ax       ; 现在es指向显存地址

            push bp     ; 保留现场，虽然没什么用，但是要养成习惯
            push cx

            mov bp,0    ; 行索引
            mov cx,22   ; 一共有22行需要清屏
        s1:
            mov si,0    ; 列索引
            push cx     ; 内层循环次数
            mov cx,80   ; 每一行有80个字符
        s2:
            ; 列循环，清除显存中的每个字符
            mov byte ptr es:[bp+si],0   ; 空字符 清空显存中显示的字符
            mov byte ptr es:[bp+si+1],7 ; 属性 颜色 7 => 0000 0111 => 0不闪烁 背景000(黑色) 0不高亮 前景111(白色)
            add si,2    ; 因为显存中一个字符占两字节
            loop s2
            add bp,160  ; 跳到下一行 
            pop cx      ; 恢复外层循环次数
            loop s1

            ; 恢复现场
            pop cx
            pop bp

            mov ax,4c00h                ;不要忘了正常退出
            int 21h
code ends
end start
```

写成函数的形式：

```asm
assume cs:code

stack segment
    dw 16 dup(0)

code segment
start:
    main:
            mov ax,stack
            mov ss,ax
            mov sp,16

            mov ax,0b800h
            mov es,ax
            call sub1

            mov ax,4c00h                ;不要忘了正常退出
            int 21h

    sub1:	; 清屏函数
            push bp     ;保留现场，虽然没什么用，但是要养成习惯
            push cx
            
            mov bp,0    ;行
            mov cx,22   ;一共有22行需要清屏
        s1:
            mov si,0
            push cx
            mov cx,80   ;每一行有80个字符
        s2:
            mov byte ptr es:[bp+si],0   ;空字符
            mov byte ptr es:[bp+si+1],7 ;属性
            add si,2
            loop s2
            add bp,160
            pop cx
            loop s1
            
            pop cx
            pop bp
            ret

code ends
end start
```



#### 对于字符串的显示程序：

```asm
assume cs:code
stack segment
    dw 16 dup (0)
stack ends

data segment
  db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
  db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
  db '1993','1994','1995'
data ends

code segment
start:
    main:
            mov ax,stack
            mov ss,ax
            mov sp,16       ; ss:sp 指向栈顶

            mov ax,data
            mov ds,ax       ; ds 指向data段

            mov ax,0b800h   ; 显示段
            mov es,ax       ; es 指向显存空间

            mov bx,0        ; data段的下标
            mov bp,160      ; 行 一行有80个字符 显存一字符占2字节
            add bp,160      ; 说明已经跳到了第3行(我是从1开始计显存行数)
            mov cx,21
        s1: ; 行循环
            mov si,0        ; 列索引，对应显存中的列下标
            push cx         ; 外层循环次数
            mov cx,4
        s2: ; 列循环
            call show_year  ; 显示字符到屏幕上
            add si,2        ; 显存一字符两字节 列+2
            inc bx          ; 指向data段的下一个字符
            loop s2

            add bp,160      ; 显存跳到下一行
            pop cx          ; 恢复外层循环的次数
            loop s1

            mov ax,4c00h
            int 21h

    show_year:  ; 在屏幕上输出 bx下标的字符
            push ax     ; 保存现场
            mov al,[bx] ; 将data段的 bx下标处的索引存入al
            mov es:[bp+si],al   ; 将al中的字符存入显存，就可以在屏幕上显示出来了
            mov byte ptr es:[bp+si+1],02h   ; 注意这里要用byte ptr   指定字符显示的颜色
            pop ax      ; 恢复现场
            ret
code ends
end start
```



#### 课程设计

**一）首先将实验七的程序改写下，变成一个子程序，方便主程序的调用。to_table**

```asm
assume cs:code 

data1 segment  
    db '1975','1976','1977','1978','1979','1980','1981','1982','1983'  
    db '1984','1985','1986','1987','1988','1989','1990','1991','1992'  
    db '1993','1994','1995' 
    ;以上是表示21年的21个字符串

    dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514  
    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000  
    ;以上是表示21年 公司总收入的21个dword型数据

    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226  
    dw 11542,14430,15257,17800
    ;以上是表示21公司雇员人数的21个Word型数据。
data1 ends  

table segment  
    db 21 dup ('year summ ne ?? ')  
table ends

code segment

start: 
        ; 初始化2个数据段,并将ds:bx指向data1，es:si指向table
        mov ax,data1
        mov ds,ax
        mov ax,table
        mov es,ax

        ; 将data1段的数据，按格式存入table段
        call to_table           ;调用子程序
       
        mov ax, 4c00H
        int 21H

; -----------------------------------
; to_table:
; 功能：将data1中的数据整理并写入table段中
; 入口参数：data1内存段、table内存段
; 返回值：无
to_table:
        ; 保护寄存器变量
        push ax
        push ds
        push es
        push bx
        push si
        push di
        push cx
        ; 将to_table中需要使用的寄存器变量都保存起来。

        ; 初始化偏址变量
        mov bx,0
        mov si,0
        mov di,0

        mov cx,21               ; 初始化计数器 一共有21个数据
    s66:; 将data按一定格式赋值到table中
        ; 写入年份
        mov ax,0[bx]		; 说明bx是data段的索引(下标)
        mov es:0[si],ax		; es指向table段,si是table段的索引
        mov ax,2[bx]
        mov es:2[si],ax		; 由于年份是4个字节，所以写两次

        ; 写入空格 初始化时已经一一匹配了空格，这里可以不写空格
        mov al,20H
        mov es:4[si],al

        ; 写入收入
        mov ax,84[bx]		; bx指向data的收入，将收入写入到table
        mov es:5[si],ax
        mov ax,86[bx]
        mov es:7[si],ax

        ; 写入空格
        mov al,20H
        mov es:9[si],al

        ; 雇员数
        mov ax,168[di]		; bx指向data的雇员，将雇员写入到table
        mov es:10[si],ax

        ; 写入空格
        mov al,20H
        mov es:12[si],al

        ; 除法后写入人均收入	收入/雇员 16位除法
        mov ax,[bx+84]		; 收入的低位
        mov dx,[bx+86]		; 收入的高位

        ; 没有办法，用个bp变量吧
        mov bp,[di+168]		; 除数
        div bp
        mov es:13[si],ax	; 写入人均收入

        ;写入空格
        mov al,20H
        mov es:15[si],al

        ;bx、si、di变量的递增
        add bx,4		; data段下标，指向下一个4字节空间
        add si,16		; table段下标，指向下一行
        add di,2		; data段下标，指向下一个2字节空间
        loop s66

        ;恢复寄存器变量，并返回主调程序
        pop cx
        pop di
        pop si
        pop bx
        pop es
        pop ds
        pop ax
        ret

; -----------------------------------
code ends
end start
```

> （1）需要注意子程序中的标号的使用：尽量选用有意义的标号名（虽然机器不认这东东，但编译器识别它）；在一个程序中（有许多子程序），标号应该不重名，否则编译器会报错！标号，最好使用英语及组合名。
>
> （2）这个子程序经过编译连接后，我们使用debug验证下它是否正确。
>
> （3）注意程序运行后，将公司的数据（data1内存段）和table段内存（已经整理好的数据）都写入到了相应的内存中去了。
>
> （4）再次强调下，**在调用子程序过程中，凡是涉及到破坏（或改变）寄存器变量的行为，我们都应该在子程序中通过栈进行保护**。

 **二）由于要用到divdw这个子程序，我们稍微改动下，因为调用它的程序有个寄存器变量有冲突。汇编代码如下：（测试状态）**

```asm
assume cs:code
code segment

start:    ;实现47F4240H/7B4H
          ;入口参数赋值
      mov ax, 4240H
      mov dx, 47FH
      mov cx, 7B4H
      call divdw

      mov ax, 4c00H
      int 21H

; -----------------------------------
; 子程序名称：divdw
; 功能：实现32位的除法，被除数存储在2个16位的寄存器中，除数存储在1个16位寄存器中；余数存储在另一个16位寄存器中。解决div除法溢出的问题。
; 入口参数：被除数的（ax）低16位，（dx）高16位，除数：（cx）。
; 返回值：结果的商：（ax）低16位，（dx）高16位，余数：（bp）。
; -----------------------------------

divdw:;子程序开始  X/N = int(H/N)*65536 + [rem(H/N)*65536+L]/N
      push ax             ;将被除数低16位先压栈保存。
      mov ax, dx          ;（ax）=（dx）
      mov dx, 0000H       ; 据公式，将原32位数的高位与除法相除
      					  ; dx,ax就是原32位数的高位，作为被除数

      div cx              ; 被除数dx+ax（组合），除数cx。16位除法 商:ax,余数:dx
      mov bx, ax          ; 将H/N结果的商先保存在bx中，(ax)=(bx)=0001H (dx)=0005H

      pop ax              ;将L值(原32位数低位)弹栈到ax
      div cx              ;此时(dx)=0005H，(ax)=4240H,组合成54240H
      					  ; dx是余数，dx作为高位就相当于*65536了，把L值存入ax就相当于+L了
      					  ; (余数*65536+L)/N.结果：ax=商，dx=余数
      mov cx, dx          ;返回值(cx)等于最终结果的余数 将最后的余数存入cx
      mov dx, bx          ;最终结果高16位值=(bx) 上步的商作为高位，dx作为高位就相当于*65536了
      ret
; -----------------------------------
code ends
end start
```

> 子程序测试结果：没有问题。此时注意，调用这个子程序时，需要3个入口参数。

**三）改写dtoc为ddtoc子程序。**

程序分析：

​    1）程序的目的：是将一个存储在dx（高16位）+ax（低16位的）的数值组合后的十进制数值，以字符串形式，并末尾为0；按照顺序写入到data内存段中。

​    2）这个子程序也适用于16位的字符转换，当然，你把16位存储ax中，(dx)=0000H。

​    3）它的原理也是将这个32位的数值除以10，求它的余数；王爽老师希望我们使用jcxz指令用于判断商是否为0？在代码中，怎样判断商为0？如果高16位和低16位的值相加为0，那么这个数肯定是0。应该是这样了。

​    4）在程序运行过程中，要注意保存和及时恢复ax和dx的值，因为它们是divdw的入口参数。

​    5）注意栈空间的使用,因为程序就使用了一个栈空间结构，它的栈帧值在头脑中要有个清楚的认识，先进后出，后进先出，栈帧都是16位的空间单元。

​    6）继续熟悉调用子程序时，入口参数的意义；返回值；程序的目的。

```asm
assume cs:code
data segment
   db 10 dup (0)
data ends

code segment
start:  ; 程序测试：47F4240H==75448896，只是测试
       ; ds:si指向data段
       mov ax, data
       mov ds, ax
       mov si, 0
       
       ; 入口参数赋值
       mov ax, 4240H
       mov dx, 047FH
       call ddtoc          ;调用子程序
       
       mov ax, 4c00H
       int 21H
; -----
; 子程序名称：ddtoc
; 功能：将一个32位数字转换成字符串，并写入data段中。
; 入口参数：ax(低16位）, dx（高16位）
; 返回值：无
; -----
dtoc:      ; 保护寄存器变量值，因为下面的变量子程序都用到。
           push ax
           push cx
           push bx
           push si
           push bp
           push dx
           
           mov si, 0       ; 偏移地址置零 作为字符串计数
   change: mov cx, 10      ; 设置除数cx=10
           mov bx, 0       ; divdw中导致bx变化，故清零
           mov bp, 0       ; 余数bp=0
           call divdw      ; 将（dx+ax）/cx求余数bp
           				   ; 返回结果：ax商的低16位 dx商的高16位 dp余数
           
           ; 如果商不为0 则继续循环取各个数
           push ax         ; 将ax和dx压栈保护 即:将商入栈
           push dx
           add ax, dx      ;（dx）+（ax）整个的商的值 对哦，要搞清楚哪两个数相加会等于0(要么全0 要么一正一负)
           mov cx, ax      ; 将商赋值给cx，判断整个的商是否为0？
           pop dx          ; 将ax和dx弹栈恢复
           pop ax
           jcxz last       ; 判断cx是否为0？
           
           add bp, 30H     ; 将数字转换成ASCII码
           push bp         ; 将字符的ASCII值压栈保存
           inc si
           jmp short change
           
   last:   ; 最后一次也要转换并压栈
           add bp, 30H     ; 将数字转换成ASCII码
           push bp         ; 将字符的ASCII值压栈保存
           inc si
           ; 将栈中数据倒序写入内存data段中
           mov cx, si      ; si=数字的字符个数，设置循环次数
           mov si, 0
   write:  pop ds:[si]
           inc si
           loop write
           mov byte ptr ds:[si], 0 ; 以0作为字符串结尾。
   ; 恢复寄存器，并返回主调程序。
           pop dx
           pop bp
           pop si
           pop bx
           pop cx
           pop ax
           ret
; -----------
; 子程序名称：divdw
; 功能：实现32位的除法，被除数存储在2个16位的寄存器中，除数存储在1个16位寄存器中；余数存储在另一个16位寄存器中。解决div除法溢出的问题。
; 入口参数：被除数的（ax）低16位，（dx）高16位，除数：（cx）。
; 返回值：结果的商：（ax）低16位，（dx）高16位，余数：（bp）。
; -----------
divdw:                      ; 子程序开始
       push ax             ; 将被除数低16位先压栈保存。
       mov ax, dx          ; （ax）=（dx）
       mov dx, 0000H       ;
       div cx              ; 被除数dx+ax（组合），除数cx。
       mov bx, ax          ; 将H/N结果的商先保存在bx中，（bx）=0001H
       pop ax              ; 将L值弹栈到ax
       div cx              ; 此时（dx）=0005H，（ax）=4240H,组合成54240H
       mov bp, dx          ; 返回值（cx）等于最终结果的余数
       mov dx, bx          ; 最终结果高16位值=（bx）
       ret
;------------
code ends
end start
```

**四）考察show_str子程序：**

**子程序功能：**将 ds:si 指向的内存段中的字符串写入到显存中，并设置相应的字符显示属性。

**入口参数：**dh：屏幕输出开始的行数；dl：屏幕输出开始所在的列数；cl：颜色及字符属性。

**返回值：**无

这个子程序目前没有什么问题，就是将字符串显示在屏幕上。

**五）编写清屏程序：cls。**

要满足课程设计1的要求（根据书中的显示结果），我们发现dos或命令提示符窗口没有乱七八糟的显示字符，这提示我们程序首先运用了清屏的功能。这个功能将来我们可能要重复使用，故将其编写成一个子程序。

```asm
;----------
; 程序名称：cls
; 程序功能：dos或命令提示符窗口清屏，满黑显示
; 入口参数：无
; 返回值：无
----------
cls:       push cx
           push di
           push si             ; 将子程序用到的寄存器变量入栈保存
           
           mov ax, 0b800H		; 显存空间
           mov es, ax          ; 设置es:di指向显示缓冲区内存段
           mov cx, 80*24       ; 设置循环次数，屏幕是24行80列，这注意
           mov di, 0
           
scr_cls:   mov byte ptr es:[di+0], ' ' ; 第一个字节写入空格，
           mov byte ptr es:[di+1], 0   ; 第二个字节写入字符属性0（代表黑色无底）
           inc di
           inc di                      ; 显存中一个字符占两字节，所以索引需要+2
           loop scr_cls
           ; 恢复寄存器
           pop si
           pop di
           pop cx
           ret
```

讲解：我们发现80*24编译器可以理解。我们在debug中，内存的显示形式是16个字节一行（也就是10H），其实它就是一个线性的空间，一维的，为了我们好理解，才显示成二维或三维形式。

**六）编写主程序，并调用子程序。**

所有的关于课程设计1的问题都妥善解决了，下面我们要考虑怎样显示在屏幕上了。

直接在主程序中写代码显示；

​    我们开始实施方案，大体程序的框架是：

```asm
数据段开始
   ……
数据段结束

code segment
main:
    ; 调用子程序to_table生成table数据段，包括入口参数初始化
    call to_table
    ; 调用cls子程序，清屏
    call cls
    ; 将table段中内容，按照显示格式写入到data中
    ……（其中使用ddtoc和show_str、divdw子程序。）
    ; 调用show_str子程序将data段字符串显示。
    call show_str
    
    mov 4c00H
    int 21H
;-----------to_table 将data段格式化到table段
to_table:
    …
    ret
;-----------cls子程序，清屏
cls:
    …
    ret
;-----------在屏幕上显示字符串
show_str:
    …
    ret
;-----------将数字转化为字符串
ddtoc:
    …
    ret
;-----------无溢出除法
divdw:
    …
    ret
code ends
end main
```

​    其他的子程序都准备好了。我们开始编写最后一个主程序：



**程序分析：**

​    1）我们从table段内存中发现，第一个数据是字符串，其他的都是数字存储的。

​    2）屏幕显示：按照我们理解，每一行

​    第一列数据（年份）：数据前面有2个空格，年份是4个字符显示，共需要6个字符的占位。

​    实现过程：直接将其复制到data段中，并结尾加0；调用show_str显示

​    第二列（总收入）：前面有8个空格（大约吧，其实我们没数），然后是总收入从左到右显示（需要8个字符占位），共需要16个字符的占位。

​    实现过程：将数据共32位读出后，调用ddtoc，将其转换成字符串，写入data段中，并结尾加0；调用show_str显示

​    第三列（公司总人数）：前面有XXXX（XXXX代表我们没数，看源程序）个空格，（需要6个字符占位），共需要XXXX个字符占位。

​    实现过程：将数据共16位，读出，调用ddtoc，将其转换成字符串，写入data段中，并结尾加0；调用show_str显示。这里注意。我都调用了32位的转换字符串的子程序。

​    第四列（平均收入）：前面有XXXX个空格，（需要4个字符占位），共需要12个字符占位。

​    具体的每列的显示，在主程序中可以调节。

```asm
assume cs:code
data1 segment
   db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
   db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
   db '1993','1994','1995'
   ;以上是表示21年的21个字符串

   dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
   dd 45980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
   ;以上是表示21年 公司总收入的21个dword型数据

   dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
   dw 11542,14430,15257,17800
   ;以上是表示21公司雇员人数的21个Word型数据。
data1 ends

table segment
   db 21 dup ('year summ ne ?? ')
table ends

data segment
   db 10 dup (0)
data ends

code segment
start:
       ; 初始化2个数据段,并将ds指向data1，es指向table
       mov ax,data1
       mov ds,ax
       mov ax,table
       mov es,ax
       ; 将数据创建生成table段
       call to_table           ; 调用子程序 将data1格式化到table
       call cls                ; 清屏
       ; 初始化2个数据段，es:bx继续指向table，ds:si指向data段。
       mov ax, table
       mov es, ax
       mov bx, 0
       mov ax, data
       mov ds, ax
       mov si, 0
       
       mov cx, 21          ; 一共显示21行，初始化cx计数器
       mov dh, 1           ; 初始在屏幕第几行显示，show_str的入口参数。
   show_info:
       push cx             ; 计数器压栈,保存cx，下面经常使用cx，保护
       ; 显示年份 
       ; 1.将年份从table段移到data段
       mov ax, es:[bx]
       mov ds:[si], ax		
       mov ax, es:[bx+2]   ; 注意[bx+idata]的寻址方式
       mov ds:[si+2], ax   ; 由于年份就是字符串，直接复制到data段中。
       mov byte ptr ds:[si+4], 0   ; 以0作为字符串结尾。
       ; 2.将data段中的年份字符串输出到屏幕
       mov dl, 3           ; 设置入口参数：所在行的列数，从第几列开始显示
       mov ch, 0           ; ch清零，防止高8位不为零。
       mov cl, 2           ; 字符颜色属性（此处应是二进制数0000 0010代表绿色）
       call show_str       ; 调用子程序，显示字符串。
       
       ; 显示总收入
       ; 1.将总收入从table段移到data段
       push dx             ; 后面要使用dx变量，先保存dx
       mov ax, es:[bx+5]   ; 将总收入的低16位送入ax
       mov dx, es:[bx+7]   ; 将总收入的高16位送入dx，ddtoc的入口参数
       call ddtoc          ; 将总收入转换成字符串后写入data段中。
       pop dx              ; 恢复寄存器dx，此时dh也就恢复了。
       ; 2.将data段中的收入字符串输出到屏幕
       mov dl, 14          ; 所在行的列数
       mov ch, 0           ; ch清零，防止高8位不为零。
       mov cl, 2           ; 字符颜色属性（此处应是二进制数0000 0010）
       call show_str
       
       ; 显示公司总人数
       push dx
       mov ax, es:[bx+10]
       mov dx, 0
       call ddtoc			; 数字转字符，并写入data段
       pop dx
       ; 输出到屏幕
       mov dl, 34          ;所在行的列数
       mov ch, 0           ;ch清零，防止高8位不为零。
       mov cl, 2           ;字符颜色属性（此处应是二进制数0000 0010）
       call show_str
       
       ; 显示总收入
       push dx
       mov ax, es:[bx+13]
       mov dx, 0
       call ddtoc
       pop dx
       ; 输出
       mov dl, 50          ;所在行的列数
       mov ch, 0           ;ch清零，防止高8位不为零。
       mov cl, 2           ;颜色属性（此处应是二进制数0000 0010）
       call show_str
       
       ; 跳转到下一行进行循环
       add bx, 10H         ;bx指向下一行。（table中16字节是一行）
       mov si, 0           ;si置零，ds:si总指向第一个字节。
       add dh, 1           ;累加dh（下一行显示）
       pop cx              ;弹栈到cx，计数器自动减1.
       loop show_info      ;循环，直到cx=0
       
       mov ax, 4c00H
       int 21H
; ------
; to_table:
; 功能：将data1中的数据整理并写入table段中
; 入口参数：data1内存段、table内存段
; 返回值：无
; ------
to_table:
       ;保护寄存器变量
       push ax
       push ds
       push es
       push bx
       push si
       push di
       push cx
       ;将to_table中需要使用的寄存器变量都保存起来。
       ;初始化偏址变量
       mov bx,0
       mov si,0
       mov di,0
       mov cx,21               ;初始化计数器
   s66:
       ;写入年份
       mov ax,0[bx]
       mov es:0[si],ax
       mov ax,2[bx]
       mov es:2[si],ax
       ;写入空格
       mov al,20H
       mov es:4[si],al
       ;写入收入
       mov ax,84[bx]
       mov es:5[si],ax
       mov ax,86[bx]
       mov es:7[si],ax
       ;写入空格
       mov al,20H
       mov es:9[si],al
       ;雇员数
       mov ax,168[di]
       mov es:10[si],ax
       ;写入空格
       mov al,20H
       mov es:12[si],al
       ;除法后写入人均收入
       mov ax,[bx+84]
       mov dx,[bx+86]
       ;没有办法，用个bp变量吧
       mov bp,[di+168]
       div bp
       mov es:13[si],ax
       ;写入空格
       mov al,20H
       mov es:15[si],al
       ;bx、si、di变量的递增
       add bx,4
       add si,16
       add di,2
       loop s66
       ;恢复寄存器变量，并返回主调程序
       pop cx
       pop di
       pop si
       pop bx
       pop es
       pop ds
       pop ax
       ret
; -----
; 子程序名称：ddtoc
; 功能：将一个32位数字转换成字符串，并写入data段中。
; 入口参数：ax(低16位）, dx（高16位）
; 返回值：无
; -----
ddtoc:      ;保护寄存器变量值，因为下面的变量子程序都用到。
           push ax
           push cx
           push bx
           push si
           push bp
           push dx
           mov si, 0       ;偏移地址置零
   change: mov cx, 10      ;设置除数cx=10
           mov bx, 0       ;divdw中导致bx变化，故清零
           mov bp, 0       ;余数bp=0
           call divdw      ;将（dx+ax）/cx求余数bp
           push ax         ;将ax和dx压栈保护
           push dx
           add ax, dx      ;（dx）+（ax）整个的商的值
           mov cx, ax      ;将商赋值给cx，判断整个的商是否为0？
           pop dx          ;将ax和dx弹栈恢复
           pop ax
           jcxz last       ;判断cx是否为0？
           add bp, 30H     ;将数字转换成ASCII码
           push bp         ;将字符的ASCII值压栈保存
           inc si
           jmp short change
   last:   ;最后一次也要转换并压栈
           add bp, 30H     ;将数字转换成ASCII码
           push bp         ; 将字符的ASCII值压栈保存
           inc si
   ;将栈中数据倒序写入内存data段中
           mov cx, si      ;si=数字的字符个数，设置循环次数
           mov si, 0
   write:  pop ds:[si]
           inc si
           loop write
           mov byte ptr ds:[si], 0 ;以0作为字符串结尾。
   ;恢复寄存器，并返回主调程序。
           pop dx
           pop bp
           pop si
           pop bx
           pop cx
           pop ax
           ret
; -------
; 子程序名称：divdw
; 功能：实现32位的除法，被除数存储在2个16位的寄存器中，除数存储在1个16位 ; ;寄存器中；余数存储在另一个16位寄存器中。解决div除法溢出的问题。
; 入口参数：被除数的（ax）低16位，（dx）高16位，除数：（cx）。
; 返回值：结果的商：（ax）低16位，（dx）高16位，余数：（bp）。
; -----------
divdw:                      ; 子程序开始  在ddtoc程序中被调用
       push ax             ;将被除数低16位先压栈保存。
       mov ax, dx          ;（ax）=（dx）
       mov dx, 0000H       ;
       div cx              ;被除数dx+ax（组合），除数cx。
       mov bx, ax          ;将H/N结果的商先保存在bx中，（bx）=0001H
       pop ax              ;将L值弹栈到ax
       div cx              ;此时（dx）=0005H，（ax）=4240H,组合成54240H
       mov bp, dx          ;返回值（cx）等于最终结果的余数
       mov dx, bx          ;最终结果高16位值=（bx）
       ret
; ---------
; 程序名称：cls
; 程序功能：dos或命令提示符窗口清屏，满黑显示
; 入口参数：无
; 返回值：无
; ----------
cls:        push cx
           push di
           push si             ;将子程序用到的寄存器变量入栈保存
           mov ax, 0b800H
           mov es, ax          ;设置es：di指向显示缓冲区内存段
           mov cx, 80*24       ;设置循环次数，屏幕是24行80列
           mov di, 0
scr_cls:    mov byte ptr es:[di+0], ' ' ;第一个字节写入空格，
           mov byte ptr es:[di+1], 0   ;第二个字节写入字符属性0（代表黑色无底）
           inc di
           inc di                      ;为毛这样？自己考虑（11章有提示）
           loop scr_cls
           ;恢复寄存器
           pop si
           pop di
           pop cx
           ret
; ------------
; show_str功能 :按行和列及字符属性显示字符串
; 入口参数：dh-行数、dl-列数、cl-字符属性, ds:si
; 返回值：无
; ------------
show_str:   push dx
           push cx
           push si
           push bx
           push es             ;将子程序用到的寄存器入栈
           mov ax, 0b800H
           mov es, ax          ;设置显示缓冲区内存段
           mov ax, 0           ;（ax）= 0，防止高位不为零
           mov al, 160         ;0a0H-   160字节/行
           mul dh              ;相对于0b800:0000第dh行偏移量
           mov bx, ax          ;将第（dh）行的偏移地址送入bx，bx代表行偏移
           mov ax, 0
           mov al, 2           ;列的标准偏移量是2个字节
           mul dl              ;同一行列的偏移量，尽量使用乘法，（al）=列偏移
           add bx, ax          ;最终获得偏移地址(bx)=506H
           mov di,0            ;将di作为每个字符的偏移量
           mov al, cl          ;将字符属性写入al中
           mov ch, 0           ;将cx高8位设置为0
   show:   mov cl, ds:[si]     ;将字符串单个字符读入cl中
           jcxz ok             ;判断字符串是否为零。
           mov es:[bx+di+0], cl    ;在显示缓冲区中写入字符
           mov es:[bx+di+1], al    ;在显示缓冲区中写入字符属性
           add di, 2
           inc si
           jmp short show
       ok: ;字符串字符为0，结尾
           pop es              ;恢复寄存器
           pop bx
           pop si
           pop cx
           pop dx
           ret
code ends
end start
```





### 检测点 11

#### 检测点 11.1

写出下面每条指令执行后，ZF、PF、SF等标志位的值

```asm
; 可以这么看：zf：是0么？pf：是偶数个1么？sf：是负数么？		1代表真 0代表假
sub al,al	; al=0   zf=1 pf=1 sf=0  是0 是偶数 不是负数
mov al,1	; al=1   zf=1 pf=1 sf=0  传送指令不会影响标志寄存器
push ax		; al=1   zf=1 pf=1 sf=0
pop bx		; bx=1   zf=1 pf=1 sf=0
add al,bl	; al=2   zf=0 pf=0 sf=0	 2 => 0010 只有1个1 所以pf=0
add al,10	; al=12	 zf=0 pf=1 sf=0
mul al		; ax=144 zf=0 pf=1 sf=0
```

> ZF是flag的第6位，零标志位，记录指令执行后结果是否为0，结果为0时，ZF=1
>
> PF是flag的第2位，奇偶标志位，记录指令执行后结果二进制中1的个数是否为偶数，结果为偶数时，PF=1
>
> SF是flag的第7位，符号标志位，记录有符号运算结果是否为负数，结果为负数时，SF=1
>
> add、sub、mul、div 、inc、or、and等运算指令影响标志寄存器
>
> mov、push、pop等传送指令对标志寄存器没影响。



#### 检测点 11.2

写出下面每条指令执行后，ZF、PF、SF、CF、OF等标志位的值

```asm
			  结果			   al			CF	OF	SF	ZF	PF
sub al,al	; 0					0			  0	  0	  0	  1	  1	
mov al,10h	; 10h/0001 0000		10h			  0	  0	  0	  1	  1	;注意mov不改变标志位

add al,90h  ; a0h/1010 0000		a0h		  	  0	  0	  1	  0	  1
mov al,80h  ; 80h/1000 0000		80h			  0	  0	  1	  0	  1

add al,80h  ; 100h/1 0000 0000	0			  1	  1   0   1   1
mov al,0fch ; fch/1111 1100		fch			  1	  1   0   1   1

add al,05h  ; 101h/1 0000 0001	1h			  1	  0   0   0   0	;debug调试 为什么不算有溢出？
mov al,7dh  ; 7dh/0111 1101		7dh			  1	  0   0   0   0

add al,0bh	; 88h/1000 1000		88h			  0	  1   1   0   1
; CF：是否进位/借位?  OF：是否溢出?  sf：是负数么？ zf：是0么？ pf：是偶数个1么？
```

> 所谓溢出：是指，**有符号数化为十进制后，有没有超过 位数表示的范围**，而不是实际相加或相减后超过了位数的表示。



#### 检测点 11.3

（1）补全下面的程序，统计 F000:0 处32个字节中，大小在 [32,128] 的数据的个数

```asm
    mov ax,0f000h
    mov ds,ax
    mov bx,0	; ds:bx指向 F000:0
    
    mov dx,0	; [32,128] 的个数 即:32≤X≤128 的个数
    mov cx,32
s:  mov al,[bx]	; 移动 F000:0 的每个字节到al中
    cmp al,32	; 与32比较
    jb s0		; X>=32 即如果小于32 就进入下次循环
    cmp al,128	; 与128比较
    ja s0		; X<=128 即如果大于128 就进入下次循环
    inc dx		; 计数
    ; 进入下次循环
s0: inc bx
    loop s
```



（2）补全下面的程序，统计 F000:0 处32个字节中，大小在 (32,128) 的数据的个数

```asm
    mov ax,0f000h
    mov ds,ax
    mov bx,0	; ds:bx指向 F000:0
    
    mov dx,0	; [32,128] 的个数 即:32<X<128 的个数
    mov cx,32
s:  mov al,[bx]	; 移动 F000:0 的每个字节到al中
    cmp al,32	; 与32比较
    jna s0		; X>32 即如果小于等于32 不大于 就进入下次循环
    cmp al,128	; 与128比较
    jnb s0		; X<128 即如果大于等于128 不小于 就进入下次循环
    inc dx		; 计数
    ; 进入下次循环
s0: inc bx
    loop s
```



#### 检测点 11.4

下面的程序执行后：(ax)=？

```asm
mov ax,0		; ax=0
push ax			; 栈顶 0
popf			; 出栈到标志寄存器，也就是标志寄存器=0，标志寄存器的每一位都为0
mov ax,0fff0h	; ax=fff0h
add ax,0010h	; ax=0	标志位：
pushf			; 将标志寄存器入栈
pop ax			; 弹到ax中，查看值
 ; 0  0  0  0  of df if tf sf zf 0  af 0  pf 0  cf
 ; 0  0  0  0  0  0  *  *  0  1  0  *  0  1  0  1

; 下面是对那些没有学过的标志位进行屏蔽操作，这就是最后两条指令的意义所在，将不确定的位置都归0，那么只剩下我们能够确定的位置了，所以，结果就可以推理出来了。
and al,11000101b
and ah,00001000b
```

推算过程：

popf 后，标志寄存器中，本章节介绍的那些标志位都为0（但是此时标志寄存器并不是所有位置都为0，这个不用关心，没学过的位置用\*先代替）
向下进行，那么 pushf 将计算后的当时状态的标志寄存器入栈，然后pop给ax，这是ax是寄存器的值（这个值中包含了我们的*号）
接下来就是对那些没有学过的标志位的屏蔽操作，这就是最后两条指令的意义所在，将不确定的位置都归0，那么只剩下我们能够确定的位置了，所以，结果就可以推理出来了。



```asm
and al,11000101B     al=01000101b=45h

and ah,00001000B     ah=00000000b=0hmov ax,0  
push ax  
popf  
mov ax,0fff0h  
add ax,0010h  
pushf

pop ax               ; 0  0  0  0  of df if tf sf zf 0  af 0  pf 0  cf
					 ; 0  0  0  0  0  0  *  *  0  1  0  *  0  1  0  1
	                 ; ax=flag=000000** 010*0101b
	                 
and al,11000101B     ; al=01000101b=45h
and ah,00001000B     ; ah=00000000b=0h
```



#### 实验11 编写子程序

编写一个子程序，将包含任意字符，以 0 结尾的字符串中的小写字母转变成大写字母，描述如下。

名称：letterc
功能：将以 0 结尾的字符串中的小写字母转变成大写字母
参数：ds:si 指向字符串首地址

```asm
assume cs:code
data segment
	db "Beginner's All-purpose Symbolic Instruction Code.",0
data ends

code segment
start:	mov ax,data
		mov ds,ax
		mov si,0	; ds:si 指向data段
		call letterc
		
		mov ax,4c00h
		int 21h
		
letterc:
		push ax
		push cx
		push si
		
		; 问题：要不要判断此字符串是以0结尾？
	s:	mov al,[si]
		cmp al,0	; 如果当前字符为0 直接返回
		je return
		; 如果不是 a-z 下次循环 a≤X≤z
		cmp al,97	; 从 data 段中一一取出字节进行比较
		jb next		; 如果 al<a(97)
		cmp al,122	; 如果 al>122
		ja next
		; 将小写字母转化为大写
		sub al,20h
		mov [si],al
		
		; 进入下次循环取下个字符
next:	inc si
		jmp s
		
return:	pop si
		pop cx
		pop ax
		ret		
code ends
end start
```

> 注意：需要进行转化的是字符串中的小写字母a~z，而不是其他字符。



### 检测点 12

#### 检测点 12.1

（1）用 Debug查看内存，情况如下：

![image-20211230112255294](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/汇编练习题/image-20211230112255294.webp)

则 3 号中断源对应的中断处理程序的入口地址为：<u>0070:018b</u>

> 一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，这个入口地址包括段地址和偏移地址，一个表项占两个字，**高地址存放段地址，低地址存放偏移地址**

（2）

存储N号中断源对应的中断处理程序入口的**偏移地址**的内存单元的地址为： 4N

存储N号中断源对应的中断处理程序入口的**段地址**的内存单元的地址为： 4N+2



#### 实验 12 编写 0 号中断的处理程序

编写 0 号中断的处理程序，使得在除法溢出发生时，在屏幕中间显示字符串 "divide error!" 然后返回到DOS。

```asm
; 编写 0 号中断的处理程序，使得在除法溢出发生时，在屏幕中间显示字符串 "divide error!" 然后返回到DOS。
assume cs:code
code segment

; do0: 当发生了0号中断，cpu去自定义的 do0 程序
; 1. 我们需要写一个程序，将 do0程序 copy到中断向量表中
    ; 中断向量表 存放着中断程序的入口地址，范围：0000:0000 ~ 0000:03FF 大小：1KB
    ; 这1KB内存空间，存放256个中断源(一个中断源占4字节: 偏移地址+段地址)  
    ; 一般而言，cpu没搞全256个中断源，所以 一般0000:0200-0000:02ff的256个字节是空着的，是安全的
    ; 而cpu随时可能发生0号中断，所以，必须将do0放在一个永驻内存的空间，而安全空间0:200-0:2ff符合我们的选择
; 2. 在屏幕中间显示字符串，这就确保显示的字符串存放位置 必须也是永驻内存空间的(即 安全空间)
; 3. 将do0程序写到安全空间后，需要将中断向量表中 0号中断的入口地址 修改为do0的段地址+偏移地址

main:
    ; 1. 将 do0程序 拷贝到安全空间。可用串传输指令(简单省事点) 串传输指令需要：
    ;       源地址 从哪里来 ds:si
    ;     目标地址 到哪里来 es:si
    ;   循环多少次 cx
    ;        方向 正:从0开始 递增    反:从高处开始 递减
    ; 1.1 定义好源地址 cs:do0
    mov ax,cs
    mov ds,ax
    mov si,offset do0
    ; 1.2 定义好目标地址 0:200 - 0:2ff
    mov ax,0
    mov es,ax
    mov di,200h

    ; 1.3 定义好循环次数 循环次数为:do0程序的大小 所以我们需要求出do0程序的大小
    mov cx,offset do0end - offset do0
    ; 1.4 定义为正方向 递增
    cld
    rep movsb   ; 开始循环移动

    ; 3. 将入口地址改为do0地址
    mov ax,0
    mov es,ax
    mov word ptr es:[0],200h    ; 将 0:0(0号中断入口偏移地址)里的值 改为200h(do0的偏移地址)
    mov word ptr es:[2],0       ; 将 0:0(0号中断入口段地址)里的值 改为200h(do0的段地址)

    mov ax,4c00H
    int 21H

; 由于main没有调用 do0 所以是不会执行此程序，当main执行完毕，do0就到了 0:200处
; 所以这里可以直接看作 cs:ip=0:200
do0:    
    jmp short do0start        ; 避免 cpu把输出信息当作指令执行 所以需要手动跳到 do0start
    ; 2.1 定义 0中断处理的提示信息
    db "divide error!"  ; 由于 这段字符串并不是指令 如果cpu当指令执行可能会产生意想不到的问题
                        ; 所以 不能让cpu看到这段指令，我们只要求字符串被读入到内存就行
do0start:
    ; 保存现场 emmm，下面都直接退出到dos了，还保护现场个屁
    ; 保护现场，只有在原程序还要继续使用时才保护，这个是提示报错信息，提示后直接退出到dos
    ; 原程序调用这个子程序都直接退出了，保护了也没啥用。
    ; push ax
    ; push cx
    ; push ds
    ; push es
    ; push si
    ; push di

    ; 问题：tf与if需要设置为0，怎样设置？是默认自动设置好的么？
    ; 这属于中断过程，cpu硬件会自动设置好，包括cs:ip入栈 标志寄存器入栈

    ; 2.2 在屏幕中输出提示信息
    mov ax,cs       ; cs:ip执行到了这里 此时提示字符和cs的地址是一样的
    mov ds,ax
    mov si,202h     ; ds:si 定位到提示字符串处

    mov ax,0b800h
    mov es,ax
    mov di,12*160+36*2     ; 显存中的输出位置 定位到12行36列

    ; 将定义的提示信息 一一copy到指定的显存位置
    mov cx,13
s:  mov al,ds:[si]      ; 为什么是肯定提示信息从202h开始?因为do0的地址为：0:200，而jmp short 只占2个字节
                        ; 而jmp下面就是我们定义的提示信息，所以是202h
    mov es:[di],al

    add di,2
    inc si
    loop s

    mov ax,4c00H
    int 21H

do0end:
    nop     ; 占位符

code ends
end main
```



### 检测点 13

#### 检测点 13.1

（1）在上面的内容中，我们用 7ch 中断例程实现 loop 的功能，则上面的7ch中断例程所能进行的最大转移位移是多少？

```asm
lp:  push bp
     mov bp,sp
     dec cx
     jcxz lpret
     add [bp+2],bx

lpret:   
	 pop bp
     iret
```

**最大位移是FFFFH，因为转移位移是存储在字单元中的，一个字最大就是FFFFH**



（2）用7ch中断例程完成 jmp near ptr s指令的功能，用bx向中断例程传送转移位移

应用举例：在屏幕的第12行，显示data段中以0结尾的字符串。

```asm
assume cs:code
data segment
	db 'conversation',0
data ends

code segment
start:	mov ax,data
		mov ds,ax
		mov si,0	; ds:si 指向data
		mov ax,0b800h
		mov es,ax
		mov di,12*160	; es:di 指向显存第12行
	s:	cmp byte ptr [si],0	; 取出data的字符判断是否为0
		je ok			; 如果是0跳出循环
		mov al,[si]
		mov es:[di],al	; 将data的字符一一复制到显存中，即 输出到屏幕
		inc si
		add di,2
		mov bx,offset s - offset ok	; 设置从标号ok到标号s的转移位移
		int 7ch		; 转移到标号s处
		
	ok:	mov ax,4c00h
		int 21h
code ends
end start
```

**分析：**jmp near ptr s指令的功能为：(ip)=(ip)+16位移，实现段内近转移

安装程序：

```asm
assume cs:code
code segment
; 将程序复制到安全空间
start:	mov ax,cs
		mov ds,ax
		mov si,offset myjmp	; ds:si 源地址 定位到中断例程
		mov ax,0
		mov es,ax
		mov di,200h		; es:di 目的地址 定位到安全空间 0:200h
		mov cx,offset myjmpend - myjmp	; 定义循环次数
		cld			; 递增循环
		rep movsb	; 开始循环
		; 设置入口地址
		mov ax,0
		mov es,ax
		mov word ptr es:[7ch*4],200h	; 偏移地址
		mov word ptr es:[7ch*4+2],0		; 段地址
		
; 中断例程 实现 jmp near ptr s 的功能
myjmp:	push bp	; 因为执行中断例程时，一些东西会入栈，所以我们需要使用到栈
		mov bp,sp
		add [bp+2],bx	; ok的偏移地址+s与ok的字节数 = s的偏移地址
		pop bp
		iret
		
myjmpend:nop
code ends
end start
```



#### 检测点 13.2

判断下面说法的正误：

（1）我们可以编程改变 FFFF:0 处的指令，使得CPU不去执行BIOS中的硬件系统检测和初始化程序

> **错误！** FFFF:0 处的指令是一条跳转指令，只读的，不可能改变。
>
> 为什么 FFFF:0 不能修改？ffff:0-f 属于ROM只读存储区，仅能进行写入操作，无法修改其中内容
>
> 因为计算机一加电，内存中是没数据的，FFFF:0处是ROM(已经嵌入了数据)，所以CS:IP一加电强制被硬件指向  FFFF:0

（2）int 19h 中断例程，可以由DOS提供

> **错误！** 中断例程19h是引导DOS开始启动的程序，所以不是DOS提供的。



#### 实验 13 编写、应用中断例程

（1）编写并安装 int 7ch 中断例程，功能为显示一个用0结束的字符串，中断例程安装在0:200处
参数：(dh)=行号，(dl)=列号，(cl)=颜色，ds:si 指向字符串首地址。

```asm
assume cs:code
code segment
start:	; 1. 安装中断例程 就是拷贝子程序到安全空间
	; 1.1 源地址
	mov ax,cs
	mov ds,ax
	mov si,offset showstr
	; 1.2 目的地址
	mov ax,0
	mov es,ax
	mov di,200h
	; 1.3 循环次数
	mov cx,offset showstrend - offset showstr
	cld
	rep movsb	; 开始循环
	
	; 2.修改入口地址
	mov ax,0
	mov es,ax
	mov word ptr es:[7ch*4],200h	; 偏移地址
	mov word ptr es:[7ch*4+2],0		; 段地址
	
	mov ax,4c00h
	int 21h
	
showstr: ; 中断例程 显示一个用0结束的字符串
		 ; (dh)=行号，(dl)=列号，(cl)=颜色，ds:si 指向字符串首地址。
		 ; 保存现场
		 push ax
		 push dx
		 push es
		 push bx
		 push si
		 ; 1.定位到指定行号和列号的显存位置
		 ; dh*160+dl*25 定位到显存的指令行列
		 mov ah,0
		 mov al,dh	; 跳跃到指定行 说明行不会超过8位，160<255 所以这是8位的乘法
		 mov dh,0a0h	; 为啥*a0h会超过范围？*0ah正常显示？按理说是需要*160(a0h)呀
		 mul dh		; 相乘后的乘积在ax
		 
		 add ax,0b800h	; 定位到指定的行了
		 mov es,ax
		 ; 定位到指定的列
		 mov al,dl		; 也是8位的乘法
		 mov dl,2		; 已经跳到了指定行，现在只需跳列数；显存中一字符占2字节，所以*2
		 mul dl
		 mov bx,ax		; 由于结果在ax中，给bx后 bx就算偏移了
		 
		 ; 开始输出字符串
	s:	 mov al,ds:[si]	; 设置字符到显存
		 cmp al,0
		 je ok			; 如果字符为0则跳到ok
		 mov ah,cl		; 设置字符的颜色
		 
		 mov es:[bx],ax	
		 inc si
		 add bx,2
		 jmp s
		
	ok:	 ; 还原现场
		pop si
		pop bx
		pop es
		pop dx
		pop ax
		
showstrend:nop
code ends
end start
```

以上中断例程安装成功后，对下面的程序进行单步跟踪，尤其注意观察int、iret指令执行前后CS、IP和栈中的状态。

```asm
assume cs:code
data segment
	db "welcome to masm!",0
data ends

code segment
start:	mov dh,10
		mov dl,10
		mov cl,2
		mov ax,data
		mov ds,ax
		mov si,0
		int 7ch
		
		mov ax,4c00h
		int 21h
code ends
end start
```



（2）编写并安装 int 7ch 中断例程，功能为完成 loop 指令的功能
参数：(cx)=循环次数，(bx)=位移

```asm
assume cs:code
code segment
start:	; 1. 安装中断例程 就是拷贝子程序到安全空间
	; 1.1 源地址
	mov ax,cs
	mov ds,ax
	mov si,offset myloop
	; 1.2 目的地址
	mov ax,0
	mov es,ax
	mov di,200h
	; 1.3 循环次数
	mov cx,offset myloopend - offset myloop
	cld
	rep movsb	; 开始循环
	
	; 2.修改入口地址
	mov ax,0
	mov es,ax
	mov word ptr es:[7ch*4],200h	; 偏移地址
	mov word ptr es:[7ch*4+2],0		; 段地址
	
	mov ax,4c00h
	int 21h
	
myloop: ; 中断例程 模拟loop指令
		push si
		dec cx	; cx是循环次数 先--
		jcxz ok	; 如果cx=0 执行ok
		
		mov si,sp	; 将当前栈顶地址给si
		add ss:[si+2],bx	; 将bx(se到s的位移地址)加到原程序的IP中
		
	ok:	pop si
		iret
		
myloopend:nop
code ends
end start
```

以上中断例程安装成功后，对下面的程序进行单步跟踪，尤其注意观察it、iet指令执行前后CS、IP和栈中的状态。

```asm
assume cs:code
code segment
start: mov ax, 0b800H
       mov es, ax
       mov di, 160*12	; es指到12行
       
       mov bx, offset s - offset se	; 设置从标号se到标号s的转移位移
       mov cx, 80
   s:  mov byte ptr es:[di], '!' ; 打算写80个！到显存的第12行
       add di, 2
       int 7cH	; 自定义中断例程：如果(cx)≠0，转移到标号s处
   se: nop
       mov ax, 4c00H
       int 21H
code ends
end start
```



（3）下面的程序，分别在屏幕的第2、4、6、8行显示4句英文诗，补全程序。

```asm
assume cs:code
code segment
s1:		db 'Good, better, best,', '$'
s2:		db 'Never let it rest,', '$'
s3:		db 'Till good is better,', '$'
s4:		db 'And better,best.', '$'
s:		dw offset s1, offset s2, offset s3, offset s4
row:	db 2, 4, 6, 8

start:	mov ax,cs
		mov ds,ax	; 由于数据区是定义在code段中的，所以数据区的cs与这里的cs是相等的
		mov bx,offset s		; bx 定位到数据区中的 s标号 表示要输出的字符偏移地址
		mov si,offset row	; si 定位到数据区中的 row标号 表示要输出到的行数
		; 感觉就像是把 源地址当成一个数组，输出地址当成一个数组，然后一一匹对输出
		mov cx,4
		
	ok:	mov bh,0	; 输出到第0页
		mov dh,ds:[si]	; 行号 ds:si处刚好是字节型的
		mov dl,0	; 列号
		mov ah,2	; 置光标
		int 10h
		
		mov dx,ds:[bx]	; ds:dx指向字符串，ds:[bx]应该只是s1的地址呀，难不成编辑器还能自动找到？
		mov ah,9	; 在光标位置显示字符串
		int 21h
		inc si
		add bx,2
		loop ok
		
		mov ax,4c00h
		int 21h
code ends
end start
```

完成后编译运行，体会其中的编程思想。



### 检测点 14

#### 检测点 14.1

（1）编程，读取 CMOS RAM 的2号单元的内容。

```asm
assume cs:code
code segment
start:  mov al,2        ; 赋值al
        out 70h,al      ; 将al送入端口70h，就相当于是cpu通知cmos我要读取2号单元的内容，然后cmos就会把2号单元的内容，送入71h中(与数据线相连)
        in al,71h       ; 从端口71h处读出单元内容
        ; 一存一取
code ends
end start
```

（2）编程，向 CMOS RAM 的2号单元写入0。

```asm
assume cs:code
code segment
start:  ; 先通知cmos，我要来写入数据了
		mov al,2
		out 70h,al
		; 将写入的数据存入 al中
		mov al,0
		; 写入到端口中  向端口71h写入数据al
		out 71h,al
code ends
end start
```



#### 检测点 14.2

编程，用加法和移位指令计算 (ax)=(ax)\*10。提示，(ax)\*10=(ax)\*2+(ax)\*8.

```asm
assume cs:code
code segment
	; 用加法计算 (ax)=(ax)*10
	mov ax,3
	mov cx,9
s:	add ax,ax
	loop s
	
	; 用移位指令计算 (ax)=(ax)*10
	mov ax,3
	mov bx,ax
	shl ax,1	; 左移一位 (ax)=(ax)*2
	
	mov cl,3	; 8 = 2^3
	shl bx,cl	; 左移cl位，这里是左移3位相当于 (ax)=(ax)*8
	add ax,bx
	
code ends
end 
```



#### 实验14 访问 CMOS RAM

编程，以 “年/月/日 时:分:秒” 的格式，显示当前的日期、时间。

注意：CMOS  RAM中存储着系统的配置信息，除了保存时间信息的单元外，不要向其他的单元中写入内容，否则将引起一些系统错误。

```asm
assume cs:code
code segment
db 9,8,7,4,2,0
; 编程，以 “年/月/日 时:分:秒” 的格式，显示当前的日期、时间。
start:  
    mov ax,cs
    mov ds,ax
    mov si,0    ; ds:si指向目的内存单元

    mov cx,6
    mov bx,0

    ; 通知cmos cpu要来读取时间信息了
 s: push cx
    mov al,ds:[si]
    out 70h,al
    ; 取出时间信息
    in al,71h
    ; 2. 化成字符形式
    mov ah,al
    mov cl,4
    shr ah,cl   ; 保留十位
    and al,00001111b    ; 保留个位
    ; 转化成字符串
    add ah,30h
    add al,30h
    ; 3. 输出到屏幕
    mov dx,0b800H
    mov es,dx
    mov byte ptr es:[160*12+40*2+bx],ah
    mov byte ptr es:[160*12+40*2+2+bx],al
    ; 输出一个空格
    mov byte ptr es:[160*12+40*2+4+bx],20h

    pop cx
    inc si
    add bx,6
    loop s

    mov byte ptr es:[160*12+40*2+4],'/'
    mov byte ptr es:[160*12+40*2+10],'/'
    mov byte ptr es:[160*12+40*2+22],':'
    mov byte ptr es:[160*12+40*2+28],':'

    mov ax,4c00h
    int 21h

code ends
end start
```

> 结果：22/01/02 13:33:24



### 检测点 15

#### 检测点 15.1

（1）仔细分析一下上面的 int 9 中断例程，看看是否可以精简一下？

其实在我们的 int 9 中断例程中，模拟 int 指令调用原 int 9 中断例程的程序段是可以精简的，因为在进入中断例程后，IF和TF都已经置0，没有必要再进行设置了。对于程序段：

```asm
pushf	; ①标志寄存器入栈
; ②IF、TF置0
pushf
pop ax
and ah,11111100b
push ax
popf
; CS、IP入栈
call dword ptr ds:[0]
```

可以精简为：

```asm
pushf	; 标志寄存器入栈
call dword ptr ds:[0]	 ; CS、IP入栈; (IP)=ds:[0],(CS)=ds:[2]
```



（2） 仔细分析程序中的主程序，看看有什么潜在的问题？

在主程序中，如果在设置执行设置int 9中断例程的段地址和偏移地址的指令之间发生了键盘中段，则CPU将转去一个错误的地址执行，将发生错误。

找出这样的程序段，改写他们，排除潜在的问题。

```asm
; 在中断向量表中设置新的int 9中断例程的入口地址
cli           ; 设置IF＝0屏蔽中断
mov word ptr es:[9*4],offset int9
mov es:[9*4+2],cs
sti           ; 设置IF＝1不屏蔽中断
```



#### 实验 15 安装新的 int 9 中断例程

安装一个新的 int 9 中断例程，功能：在DOS下，按下“A”键后，除非不再松开，如果松开，就显示满屏幕的“A”，其他的键照常处理。

提示，按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。断码=通码+80h。

```asm
assume cs:code
stack segment
	db 128 dup (0)
stack ends

code segment
start:	mov ax,stack
		mov ss,ax
		mov sp,128		; 指向栈顶
		
		push cs
		pop ds		; 将cs赋值给ds 相当于 mov ds,cs(虽然不准这么用，不过描述一下)
		
		mov ax,0
		mov es,ax	; es指向目标
		; 将自定义的int9传送到安全空间
		mov si,offset int9	; 设置ds:si指向源地址
		mov di,204h			; 设置es:di指向目的地址
		mov cx,offset int9end - offset int9	; 设置cx为传输长度
		cld					; 设置传输方向为正
		rep movsb			; 把int9安装到了 0:204 
		; 将原来的int 9中断例程的入口地址，保存到 0:200,0:202
		push es:[9*4]
		pop es:[200h]
		push es:[9*4+2]
		pop es:[202h]
		; 如果此刻来了个中断，那么很有可能会导致入口地址的写入不成功。从而下次int 9指向错误的地方，所以将自定义入口写到向量表时，需要屏蔽中断信号
		cli	; 设置IF＝0屏蔽中断
		mov word ptr es:[9*4],204h
		mov word ptr es:[9*4+2],0
		sti	; 设置IF＝1取消屏蔽
		
		mov ax,4c00h
		int 21h
; 自定义 int 9	
int9:	push ax
		push bx
		push cx
		push es
		
		in al,60h	; 从键盘按键中读取到扫描码
		
		mov bx,0
		mov es,bx
		
		pushf	; 标志位入栈
		call dword ptr cs:[200h]	; 当此中断例程执行时(CS)=0
									; cs、IP入栈，
		
		cmp al,9Eh		; A 的扫描码
		jne int9ret		; 不相等进入int9ret
		; 变换背景色
		mov ax,0b800h
		mov es,ax
		mov bx,0
		mov cx,2000
	s:	mov byte ptr es:[bx],41H
		add bx,2
		loop s
		
int9ret:pop es
		pop cx
		pop bx
		pop ax
		iret
		
int9end:nop
code ends
end start
```



### 检测点 16

#### 检测点 16.1

下面的程序将 code 段中a处的8个数据累加，结果存储到b处的双字中，补全程序。

```asm
assume cs:code
code segment
	; 就把 a => cs:[0]	b => cs:[16]
	; 这是编译器自动计算出来的
	a dw 1,2,3,4,5,6,7,8
	b dd 0
	
start:	mov si,0
		mov cx,8
	s:	mov ax,a[si]	; 将 cs:0[si] 移入ax  编译后mov ax,[si+0000]
		;add a[16],ax	; 用 b[0] 行不行？a是dw类型 刚好对应ax的长度
		;add b[0],ax	; 用b会红线，因为b是dd类型的
		add word ptr b[0],ax	; 可以这样
		;adc a[18],0		; 用 b[2] 行不行？
		;adc b[2],0		; 如果上面用dd类型的b，则这里也会默认dd类型
		adc word ptr b[2],0
		add si,2
		loop s
		
		mov ax,4c00h
		int 21h
code ends
end start
```



#### 检测点 16.2

下面的程序将data段中a处的8个数据累加，结果存储到b处的字中，补全程序.

```asm
assume cs:code,es:data
data segment
	a dw 1,2,3,4,5,6,7,8
	b dd 0
data ends

code segment
start:	mov ax,data
		mov es,ax
		
		mov si,0
		mov cx,8
	s	mov al,a[si]
		mov ah,0
		add b,ax
		inc si
		loop s
		
		mov ax,4c00h
		int 21h
code ends
end start
```



#### 实验16 编写包含多个功能子程序的中断例程

安装一个新的 int 7ch 中断例程，为显示输出提供如下功能子程序。
（1）清屏
（2）设置前景色
（3）设置背景色
（4）向上滚动一行

入口参数说明如下。

（1）用ah寄存器传递功能号：0表示清屏，1表示设置前景色，2表示设置背景色，3表示向上滚动一行；
（2）对于1、2号功能，用al传送颜色值，(al)∈{0,1,2,3,4,5,6,7}。

```asm
assume cs:code
code segment
; 1.设置安装中断例程
start:; 1.1 将中断例程拷贝到0:200
    ; 源地址 从哪里来
    mov ax,cs
    mov ds,ax
    mov si,offset interrupt_
    ; 目标地址 到哪里去
    mov ax,0
    mov es,ax
    mov di,200h+4*2
    mov cx,offset interrupt_end - offset interrupt_  ; 中断例程的长度
    cld
    rep movsb

    ; 1.2 修改入口地址
    mov ax,0
    mov es,ax
    mov word ptr es:[7ch*4],200h ; 偏移地址
    mov word ptr es:[7ch*4+2],0h ; 段地址

; 中断例程 0:200
interrupt_:
    ; 设置直接定址表，来指向相应子程序，直接定址表也要安装
    jmp interrupt_begin
    table dw clean_screen,set_ForeColor,set_BackColor,screen_scroll
interrupt_begin:
    push bx
    ; ah 表示功能号，al表示颜色
    cmp ah,3
    ja return   ; 大于3直接退出
    ; 将功能号转化为table中的偏移量
    mov bl,ah
    mov bh,0
    add bx,bx
    call word ptr table[bx]

 return:
    pop bx
    iret 


; ----------------------0号子程序--------------------------------
; 清屏功能,将屏幕置为空格
clean_screen:
    push bx
    push cx
    push es

    mov bx,0b800h
    mov es,bx
    mov bx,0    ; es:bx 指向显存
    mov cx,2000 ; 25(行)*80(列 一列2字节)
 s: mov byte ptr es:[bx],' '
    add bx,2
    loop s

    pop es
    pop cx
    pop bx
    ret

; ----------------------1号子程序--------------------------------
; 设置前景色,(al)为颜色参数
set_ForeColor:
    push es
    push bx
    push cx

    mov bx,0b800h
    mov es,bx
    mov bx,1    ; es:bx 指向显存字符属性
    mov cx,2000
set_fore:
    and byte ptr es:[bx],11111000b  ; 初始化前景色(1 2 3位)
    or es:[bx],al   ; al是我们想设置的颜色
    add bx,2
    loop set_fore

    pop cx
    pop bx
    pop es
    ret

; ----------------------2号子程序--------------------------------
; 设置背景色,(al)为颜色参数
set_BackColor:
    push es
    push cx
    push bx

    mov bx,0b800h
    mov es,bx
    mov bx,1    ; es:bx指向显存中的字符属性
    mov cl,4
    shl al,cl   ; 这里的al代表颜色 左移4次 以更换背景色
    mov cx,2000
set_back:
    and byte ptr es:[bx],10001111b  ; 初始化4 5 6位
    or es:[bx],al   ; 设置为用户想要的背景色
    add bx,2
    loop set_back

    pop bx
    pop cx
    pop es
    ret

; ----------------------3号子程序--------------------------------
; 屏幕向上滚动一行
screen_scroll:
    push ds
    push es
    push ax
    push cx
    push di
    push si

    mov ax, 0b800h
    mov ds, ax
    mov es, ax
    mov si, 160     ; ds:si 指向第n+1行
    mov di, 0       ; es:di 指向第n行
    cld
    mov cx, 24      ; 行循环
copy_:
    push cx
    mov cx, 160     ; 列循环 
    rep movsb       ; 复制 下一行复制到上一行
    ; 进入下次行循环
    pop cx
    loop copy_
    ; 最后一行清空
    mov cx, 80          
    mov di,0
print_s:
    mov byte ptr es:[160*24+si], ' '
    add di, 2
    loop print_s

    pop si
    pop di
    pop cx
    pop ax
    pop es
    pop ds
    ret

; ---------------------------子程序结束------------------------------
interrupt_end:  nop
code ends
end start
```





### 检测点 17

#### 检测点 17.1

“在int 16h中断例程中，一定有设置IF=1的指令。”这种说法对吗？

> IF=1，CPU响应中断，引发中断过程 
> IF=0，不响应可屏蔽中断 
>
> 几乎所有由外设引发的外中断，都是可屏蔽中断（int 9是可屏蔽中断）

正确，当键盘缓冲区为空时，如果设置IF=0，int 9中断无法执行，循环等待会死锁。

> CPU对外设输入的通常处理方法：
> (1) 外设的输入端口
> (2) 向CPU发出外中断(可屏蔽中断)信息
> (3) CPU检测到可屏弊中断信息，如果IF=1，cpu在执行完当前指令后响应中断，执行相应的中断例程
> (4) 可在中断例程中实现对外设输入的处理



#### 实验17 编写包含多个功能子程序的中断例程

安装一个新的 int 7ch 中断例程，实现通过逻辑扇区号对软盘进行读写。

参数说明：
（1）用 ah 寄存器传递功能号：0表示读，1表示写；
（2）用 dx 寄存器传递要读写的扇区的逻辑扇区号；
（3）用 es:bx 指向存储读出数据或写入数据的内存区。

提示，用逻辑扇区号计算出面号、磁道号、扇区号后，调用int 13h中断例程进行实际的读写。

> 题目解析看：[题目](D:\xuan\带上它,便带上整个故事\typora\编程笔记\后端\编程的内功\3. 汇编\2712_汇编语言 第3版.pdf)
> 答案：[百度的](https://blog.csdn.net/love_jing_forever/article/details/53423029)

```asm
assume cs:code

code segment
    start:
        mov ax,cs
        mov ds,ax
        mov si,offset int7cstart

        mov ax,0
        mov es,ax
        mov di,200h

        mov cx,offset int7cend - offset int7cstart
        cld
        rep movsb

        mov word ptr es:[4*7ch],200h
        mov word ptr es:[4*7ch+2],0

        mov ax,4c00h
        int 21h

    int7cstart:
        cmp ah,1
        ja none

        push ax
        push bx
        push cx
        push dx

        push ax

        mov ax,dx
        mov dx,0
        mov cx,1440
        div cx
        push ax
        mov cx,18
        mov ax,dx
        mov dx,0
        div cx
        push ax
        inc dx
        push dx

        pop ax
        mov cl,al
        pop ax
        mov ch,al
        pop ax
        mov dh,al
        mov dl,0

        pop ax
        mov al,1
        cmp ah, 0
        je read
        cmp ah, 1
        je write

    read:
        mov ah,2
        jmp short ok
    write:
        mov ah,3
        jmp short ok    
    ok: 
        int 13h
        pop dx
        pop cx
        pop bx
        pop ax
    none:
        iret    
    int7cend:
        nop

code ends

end start
```



### 课程设计 2(需要用尽毕生所学)

阅读下面的材料：

开机后，CPU自动进入到 FFFF:0 单元处执行，此处有一条跳转指令。CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。

初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。

硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。

如果设为从软盘启动操作系统，则int 19将主要完成以下工作。
（1）控制0号软驱，读取软盘0道0面1扇区的内容到 0:7c00；
（2）将CS:IP指向0:7c00。

软盘的0道0面1扇区中装有操作系统引导程序。int 19h将其装到0:7c00处后，设置CPU从0:7c00开始执行此处的引导程序，操作系统被激活，控制计算机。

如果在0号软驱中没有软盘，或发生软盘I/O错误，则int 19h将主要完成以下工作。
（1）读取硬盘C的0道0面1扇区的内容到0:7c00；
（2）将CS:IP指向0:7c00。



这次课程设计的任务是编写一个可以自行启动计算机，不需要在现有操作系统环境中运行的程序。

该程序的功能如下。

（1）列出功能选项，让用户通过键盘进行选择，界面如下。

```asm
1）reset pc		; 重新启动计算机
2）start system 	; 引导现有的操作系统
3）clock			; 进入时钟程序
4）set clock		; 设置时间
```

（2）用户输入“1”后重新启动计算机（提示：考虑 ffff:0 单元）。

（3）用户输入“2”后引导现有的操作系统（提示：考虑硬盘C的0道0面1扇区）。

（4）用户输入“3”后，执行动态显示当前日期、时间的程序。

显示格式如下：年/月/日 时:分:秒
进入此项功能后，一直动态显示当前的时间，在屏幕上将出现时间按秒变化的效果（提示：循环读取CMOS）。
当按下 F1 键后，改变显示颜色；按下 Esc 键后，返回到主选单（提示：利用键盘中断）。

（5）用户输入“4”后可更改当前的日期、时间，更改后返回到主选单（提示：输入字符串）。



下面给出几点建议：

（1）在DOS下编写安装程序，在安装程序中包含任务程序；

（2）运行安装程序，将任务程序写到软盘上；

（3）若要任务程序可以在开机后自行执行，要将它写到软盘的0道0面1扇区上。如果程序长度大于512个字节，则需要用多个扇区存放，这种情况下，处于软盘0道0面1扇区中的程序就必须负责将其他扇区中的内容读入内存。

> 这个程序较为复杂，它用到了我们所学到的所有技术，需要进行仔细地分析和耐心地调试。这个程序对于我们的整个学习过程是具有总结性的，希望读者能够尽力完成。

[参考：](https://blog.csdn.net/m0_48836226/article/details/120718381?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.pc_relevant_paycolumn_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.pc_relevant_paycolumn_v2&utm_relevant_index=4)







- **实验总结：**

1、实模式、保护模式、长模式等CPU工作模式的区别

**实模式指的是相当于cpu在裸机情况下的一种快速8086 ，但不能发挥80x86的功能；**

**保护模式是指cpu在非裸机情况下，通过操作系统接管过去之后就会具备80x86的威力了；**

**长模式相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是 64 位，还可以单独使用低 32 位。**32 位可以拆分成一个低 16 位寄存器，低 16 位又可以拆分成两个 8 位寄存器。**长模式依然具备保护模式绝大多数特性，如特权级和权限检查。**

2、T指令的单步执行操作是会自动执行对栈寄存器SS操作的语句的下一条语句，同时T指令的单步执行是会引起中断的以保证每次执行一条便停止。

> 因为t命令是修改标志位，从而进行了一次中断过程。而中断过程会入栈一些数据。所以必须保证入栈期间是不能被中断的。所以T命令无法捕捉到细致的入栈语句

