---
title:  汇编语言_王爽_2
date: 2023-01-29 10:47:46
permalink: /pages/0b372e/
categories:
  - studynotes
  - 计算机基础
  - 汇编
tags:
  - 
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---


## 第十一章 标志寄存器

CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。

（1）用来存储相关指令的某些执行结果；

（2）用来为CPU执行相关指令提供行为依据；

（3）用来控制CPU的相关工作方式。

这种特殊的寄存器在 8086CPU 中，被称为**标志寄存器**。8086CPU的标志寄存器有16位，其中**存储的信息通常被称为程序状态字（PSW）**。我们已经使用过8086CPU的ax、bx、cx、dx、si、di、bp、sp、IP、cs、ss、ds、es等13个寄存器了，本章中的标志寄存器（以下简称为flag）是我们要学习的最后一个寄存器。

**flag 和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而 flag 寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。**

8086CPU的 flag 寄存器的结构如图11.1所示。

![image-20211229111706272](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211229111706272.webp)

> flag 的1、3、5、12、13、14、15 位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11 位都具有特殊的含义。

在这一章中，我们学习标志寄存器中的CF、PF、ZF、SF、OF、DF标志位，以及些与其相关的典型指令

### 1. ZF 标志(是0？)

**flag 的第6位是 ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果结果为0，那么 zf=1；如果结果不为0，那么 zf=0。**

比如，指令：

```asm
mov ax,1
sub ax,1
; 执行后，结果为0，则 zf=1

mov ax,2
sub ax,1
; 执行后，结果不为0，则 zf=0
```

对于 zf 的值，我们可以这样来看，zf标记相关指令的计算结果是否为0，如果为0，则 zf 要记录下“是0”这样的肯定信息。**在计算机中 1 表示逻辑真，表示肯定，所以当结果为 0 的时候 zf=1，表示“结果是0”。**

如果结果不为0，则 zf 要记录下“不是0”这样的否定信息。**在计算机中0表示逻辑假，表示否定，所以当结果不为0的时候 zf=0，表示“结果不是0”。**

比如，指令：

```asm
mov ax,1
and ax,0
; 执行后，结果为0，则 zf=1，表示“结果是0”

mov ax,1
or ax,0
; 执行后，结果不为0，则 zf=0，表示“结果非0”

; 感觉zf就是判断指令执行的结果是否为0，如果指令执行结果为0，则为真
```

> 注意，在 8086CPU 的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令。
>
> **算术指令(运算)影响标志位，移动(传送)指令不影响标志位。**
>
> **在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。**



### 2. PF 标志(是偶数1？)

**flag 的第2位是 PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，pf=1，如果为奇数，那么 pf=0。**

比如，指令：

```asm
mov al,1
add al,10
; 执行后，结果为00001011B，其中有3(奇数)个1，则 pf=0

mov al,1
or al,2
; 执行后，结果为00000011B，其中有2(偶数)个1，则 pf=1

sub al,al
; 执行后，结果为00000000B，其中有0(偶数)个1，则 pf=1
```



### 3. SF 标志(是负数？)

**flag 的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，sf=1；如果非负，sf=0。**

计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。比如

00000001B，可以看作为无符号数1，或有符号数+1；

10000001B，可以看作为无符号数129，也可以看作有符号数-127；

这也就是说，对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算。比如：

```asm
mov al,10000001B
add al,1
; 结果: (al)=10000010B
```

可以将 add 指令进行的运算当作无符号数的运算，那么add指令相当于计算129+1，结果为130(10000010B)；也可以将 add 指令进行的运算当作有符号数的运算，那么add指令相当于计算-127+1，结果为-126(10000010B)。

> 不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。
>
> SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。**在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。**

这也就是说，CPU在执行 add 等指令时，是必然要影响到 SF标志位 的值的。至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算了。

比如：

```asm
mov al,10000001B
add al,1
; 执行后，结果为10000010B,sf=1，表示：如果指令进行的是有符号数运算，那么结果为负

mov al,10000001B
add al,01111111B
; 执行后，结果为0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。
```

某些指令将影响标志寄存器中的多个标记位，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。

> 比如指令 sub  al,al 执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1、1、0。
>
> 可以这么看： zf：是0么？pf：是偶数个1么？sf：是负数么？		1代表真  0代表假



### 4. CF 标志(无符号 进位/借位？)

**flag的第0位是CF，进位标志位。一般情况下，在进行<u>无符号数</u>运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。**

对于位数为 N 的无符号数来说，其对应的二进制信息的最高位，即第N-1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位，如图11.2所

![image-20211229134853481](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211229134853481.webp)

> CF 就相当于记录了，这个假想的更高位

我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。比如，两个8位数据：98H+98H，将产生进位。由于这个进位值在8位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了。**其实CPU在运算的时候，并不丢弃这个<font color="red">进位值</font>，而是记录在一个特殊的寄存器的某一位上。8086CPU就用 flag 的CF位来记录这个进位值。**比如，下面的指令

```asm
mov al,98h
add al,al	; 执行后：(al)=30h,cf=1,cf记录了从最高有效位向更高位的进位值
add al,al	; 执行后：(al)=60h,cf=0,cf记录了从最高有效位向更高位的进位值
```

而当两个数据做减法的时候，有可能向更高位借位。比如，两个8位数据：97H-98H，将产生借位，借位后，相当于计算 197H-98H。而flag的CF位也可以用来记录这个借位值。比如，下面的指令

```asm
mov al,97h
sub al,98h	; 执行后：(al)=ffh,cf=1,cf记录了向更高位的借位值
sub al,al	; 执行后：(al)=0,cf=0,cf记录了向更高位的借位值
```

> CF对于加法，记录相加后的进位值；CF对于减法，记录相减后的借位值



### 5. OF 标志(有符号 溢出？)

在进行有符号数运算的时候，结果超过了机器所能表示的范围称为溢出。

那么，什么是机器所能表示的范围呢？

比如说，指令运算的结果用 8 位寄存器或内存单元来存放，比如，add  al，3；那么对于8位的有符号数据，机器所能表示的范围就是-128\~127。同理，对于16位有符号数据，机器所能表示的范围是-32768~32767。

如果运算结果超出了机器所能表达的范围，将产生溢出。

**注意，这里所讲的溢出，只是对有符号数运算而言。**下面我们看两个溢出的例子。

```asm
mov al,98
add al,99
; 执行后将产生溢出。因为 add al,99 进行的有符号数运算是:(al)=98+99=197
; 而结果197超出了机器所能表示的8位有符号数的范围：-128~127。

mov al,0f0h	; f0h,为有符号数 -16 的补码
add al,088h	; 88h,为有符号数 -120 的补码
; 执行后将产生溢出。因为 add al,088h 进行的有符号数运算是:(al)=(-16)+(-120)=-136
; 而结果-136超出了机器所能表示的8位有符号数的范围：-128~127。
```

如果在进行有符号数运算时发生溢出，那么运算的结果将不正确。就上面的两个例子来说：

```asm
mov al,98
add al,99
```

> add 指令运算的结果是 (al)=0C5H，因为进行的是有符号数运算，所以al中存储的是有符号数，而 c5h 是有符号数-59的补码。如果我们用add指令进行的是有符号数运算，则 98+99=-59 这样的结果让人无法接受。造成这种情况的原因，就是实际的结果197，作为一个有符号数，在8位寄存器al中存放不下。

```asm
mov al,0f0h	; f0h,为有符号数 -16 的补码
add al,088h	; 88h,为有符号数 -120 的补码
```

> add 指令运算的结果是 (al)=78h，因为进行的是有符号数运算，所以al中存储的是有符号数，而 78h 是有符号数120。如果我们用add指令进行的是有符号数运算，则 -16-120=-120 这样的结果显然不正确。造成这种情况的原因，就是实际的结果-136，作为一个有符号数，在8位寄存器al中存放不下。



由于在进行有符号数运算时，可能发生溢出而造成结果的错误。则CPU需要对指令执行后是否产生溢出进行记录。

**flag的第11位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0。**

> 一定要注意CF和OF的区别：**CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。**比如：

```asm
mov al,98
add al,99
```

> **add指令执行后：CF=0，OF=1**。前面我们讲过，**CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算**。
>
> 对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。
>
> 对于无符号数运算，98+99没有进位，CF=0；对于有符号数运算，98+99发生溢出，OF=1。

```asm
mov al,0f0h		; 对于 无符号数：240	有符号数：-16
add al,088h		; 对于 无符号数：136	有符号数：-120
; 对于无符号位 al=240+136=376		al=[0,256)	所以对于无符号数而言，发生了进位
; 对于有符号位 al=-16+(-120)=-136		al=[-128,127]	所以对于有符号数而言，发生了溢出
```

> add指令执行后：CF=1，OF=1。对于无符号数运算，0F0H+88H有进位，CF=1；对于有符号数运算，0F0H+88H发生溢出，OF=1。

```asm
mov al,0f0h		; 对于 无符号数：240	有符号数：-16
add al,078h		; 对于 无符号数：120	有符号数：120
; 对于无符号位 al=240+120=360		al=[0,256)	所以对于无符号数而言，发生了进位
; 对于有符号位 al=-16+120=104		al=[-128,127]	所以对于有符号数而言，并没有溢出
```

> add指令执行后：CF=1，OF=0。对于无符号数运算，0F0H+78H有进位，CF=1；对于有符号数运算，0F0H+78H不发生溢出，OF=0。

<!-- 我们可以看出，CF和OF所表示的进位和溢出，是分别对无符号数和有符号数运算而言的，它们之间没有任何关系 -->

所谓溢出：是指，**有符号数化为十进制后，有没有超过 位数表示的范围**，而不是实际相加或相减后超过了位数的表示。



### 6. adc 指令(实现大数据相加)

**adc 是带进位加法指令，它利用了CF位上记录的进位值。**

```properties
指令格式：adc 操作对象1,操作对象2
功能：操作对象1 = 操作对象1 + 操作对象2 + CF
比如指令 adc ax,bx 实现的功能是：(ax) = (ax)+(bx)+CF
```

例：

```asm
mov ax,2
mov bx,1
sub bx,ax	; 1-2 产生借位信号与溢出信号 cf=1 of=1
adc ax,1	
; 执行后，(ax)=4。adc执行时，相当于计算：(ax)+1+CF = 2+1+1=4

; 重开的，与上面的不相关
mov ax,1
add ax,ax
adc ax,3
; 执行后，(ax)=5。adc执行时，相当于计算：(ax)+3+CF = 2+3+0=5

mov al,98h
add al,al
adc al,3
; 执行后，(al)=34h。adc执行时，相当于计算：(al)+3+CF = 30h+3+1=34h
```

> 可以看出，adc指令比add指令多加了一个CF位的值。



先来看一下CF的值的含义。在执行adc指令的时候加上的CF的值的含义，是由adc指令前面的指令决定的，也就是说，**关键在于所加上的CF值是被什么指令设置的**。

显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值。我们来看一下两个数据：0198H和0183H如何相加的：

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211229145522283.webp" alt="image-20211229145522283" style="zoom:50%;" />

可以看出，加法可以分两步来进行：①低位相加；②高位相加再加上低位相加产生的进位值。

下面的指令和 add ax,bx 具有相同的结果

```asm
add al,bl	; ①低位相加
adc ah,bh	; ②高位相加再加上低位相加产生的进位值
```

看来CPU提供adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。我们来看一个例子：

编程，计算 1EF000H+201000H，结果放在 ax(高16位)和bx(低16位)中。

> 因为两个数据的位数都大于16，用add指令无法进行计算。我们将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。程序如下

```asm
mov ax,001Eh	; 1EF000H 的高16位
mov bx,0f000h	; 1EF000H 的低16位
add bx,1000h	; 201000H 的低16位	低16位相加
adc ax,0020h	; 201000H 的高16位	高16位带位相加
```

**adc指令执行后，也可能产生进位值，所以也会对CF位进行设置。**由于有这样的功能，我们就可以对任意大的数据进行加法运算。看一个例子：

编程，计算 1EF0001000H+2010001EF0H，结果放在 ax(最高16位)，bx(次高16位)，cx(低16位)中。

> 计算分3步进行：
>
> （1）先将低16位相加，完成后，CF中记录本次相加的进位值
>
> （2）再将次高16位和CF(来自低16位的进位值)相加，完成后，CF中记录本次相加的进位值
>
> （3）最后高16位和CF(来自次高16位的进位值)相加，完成后，CF中记录本次相加的进位值。

```asm
mov ax,001eh
mov bx,0f000h
mov cx,1000h

add cx,1ef0h	; 低16位相加
adc bx,1000h	; 次高16位带位相加
adc ax,0020h	; 最高16位带位相加
```



下面编写一个子程序，对两个128位数据进行相加。

**名称：**add128

**功能：**两个128位数据进行相加

**参数：**ds:si 指向存储第一个数的内存空间，因数据为128位，所以需要8个字单元，由低地址单元到高地址单元依次存放128位数据由低到高的各个字。运算结果存储在第一个数的存储空间中。

ds:di 指向存储第二个数的内存空间。

```asm
add128:	push ax
		push cx
        push si
        push di
        
        sub ax,ax	; 将CF设置为0
        mov cx,8
     s: mov ax,[si]	; ds:si 指向 第一个128位数的空间的低位
        adc ax,[di]	; ds:di 指向 第二个128位数的空间的低位 带位相加，从低位开始
        mov [si],ax	; 将加好后的数值，存储在第一个数的存储空间
        
        inc si
        inc si		; 16位加法 一次跳两位
        inc di
        inc di
        loop s
        
        pop di
        pop si
        pop cx
        pop ax
        ret
```

**<font color="red">inc 和 loop 指令不影响CF位</font>**，思考一下，上面的程序中，能不能将4个inc指令，用 add si,2   add di,2来取代？

不行，虽然si与di都是指向的索引下标，但对于128位数，可能定位到126时进行+2=128，这样对于SF标志有影响



### 7. sbb 指令(实现大数据减法)

sbb 是带借位减法指令，它利用了CF位上记录的借位值。

```properties
指令格式：sbb 操作对象1,操作对象2
功能：操作对象1 = 操作对象1 - 操作对象2 - CF
比如指令 sbb ax,bx 实现的功能是：(ax) = (ax)-(bx)-CF
```

sbb 指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。比如，计算 003E1000H-00202000H，结果放在ax，bx中，程序如下：

```asm
mov bx,1000h
mov ax,003eh
sub bx,2000h
sbb ax,0020h
```

sbb 和 adc 是基于同样的思想设计的两条指令，在应用思路上和 adc 类似。



### 8. cmp 指令(比较指令)

**cmp 是比较指令，cmp 的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。**

```properties
cmp 指令格式：cmp 操作对象1,操作对象2
功能：计算 操作对象1 - 操作对象2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置
比如，指令 cmp ax,ax，做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。指令执行后：zf=1,pf=1,sf=0,cf=0,of=0
```

```asm
mov ax,8
mov bx,3
cmp ax,bx
; 执行后：(ax)=8,zf=0,pf=1,sf=0,cf=0,of=0
```

其实，我们通过 cmp 指令执行后，相关标志位的值就可以看出比较的结果。cmp ax,bx

> 如果 (ax)=(bx) 则 (ax)-(bx)=0，所以：zf=1；
>
> 如果 (ax)≠(bx) 则 (ax)-(bx)≠0，所以：zf=0；
>
> 如果 (ax)<(bx) 则 (ax)-(bx) 将产生借位，所以：cf=1；
>
> 如果 (ax)≥(bx) 则 (ax)-(bx) 不必借位，所以：cf=0；
>
> 如果 (ax)>(bx) 则 (ax)-(bx) 既不必借位，结果又不为0，所以：cf=0并且zf=0；
>
> 如果 (ax)≤(bx) 则 (ax)-(bx) 既可能借位，结果可能为0，所以：cf=1或zf=1。

现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果。反过来看上面的例子。

指令 cmp ax,bx 的逻辑含义是比较ax和bx中的值，如果执行后：

```properties
zf=1，说明 (ax)=(bx)
zf=0，说明 (ax)≠(bx)
cf=1，说明 (ax)<(bx)
cf=0，说明 (ax)≥(bx)
cf=0并且zf=0，说明 (ax)>(bx)
cf=1或zf=1，说明 (ax)≤(bx)
```

同add、sub指令一样，CPU在执行 cmp 指令的时候，也包含两种含义：**进行无符号数运算和进行有符号数运算。**所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。

上面所讲的是用cmp进行无符号数比较时，相关标志位对比较结果的记录。下面我们再来看一下如果用cmp来进行有符号数比较时，CPU用哪些标志位对比较结果进行记录。我们以  cmp ah,bh 为例进行说明

> 如果 (ah)=(bh) 则 (ah)-(bh)=0，所以：zf=1；
>
> 如果 (ah)≠(bh) 则 (ah)-(bh)≠0，所以：zf=0；
>
> 所以，根据 cmp 指令执行后 zf 的值，就可以知道两个数据是否相等。

对于有符号数运算，在 (ah)<(bh) 情况下， (ah)-(bh) 显然可能引起 sf=1，即结果为负。

比如：

```asm
(ah)=1,(bh)=2	; 则 (ah)-(bh)=0ffh,0ffh为-1的补码，因为结果为负，所以sf=1
(ah)=0feh,(bh)=0ffh	; 则 (ah)-(bh)=-2-(-1)=0ffh，因为结果为负，所以sf=1
```

通过上面的例子，我们是不是可以得到这样的结论：cmp 操作对象1,操作对象2 指令执行后，sf=1，就说明操作对象1 < 操作对象2？当然不是。

```asm
(ah)=22h,(bh)=0a0h	; 则 (ah)-(bh)=34-(-96)=82h,82h是-126的补码，所以sf=1
; 这里虽然 sf=1，但是并不能说明 (ah)<(bh)，因为显然 34>-96
```

两个有符号数A和B相减，得到的是负数，那么可以肯定A<B，这个思路没错。关键在于我们根据什么来断定得到的是一个负数。

单纯地考査 sf 的值不可能知道结果的正负。因为sf记录的只是可以在计算机中存放的相应位数的结果的正负。比如 add ah,al 执行后，sf记录的是ah中的8位二进制信息所表示的数据的正负。cmp ah,bh 执行后，sf记录的是(ah)-(bh) 所得到的8位结果数据的正负。

虽然这个结果没有在我们能够使用的寄存器或内存单元中保存，但是在指令执行的过程中，它暂存在CPU内部的暂存器中。

所得到的相应结果的正负，并不能说明，运算所应该得到的结果的正负。这是因为在运算的过程中可能发生溢出。如果有这样的情况发生，那么，sf的值就不能说明任何问题。比如：

```asm
mov ah,22h
mov bh,0a0h
sub ah,bh
; 结果 sf=1,运算实际得到的结果是(ah)=82h,但逻辑上，运算所应该得到的结果是：34-(-96)=130
; 就是因为130这个结果作为一个有符号数超出了-128-127这个范围，在ah中不能表示而ah中的结果被CPU当作有符号数解释为-126.
; 而sf被用来记录这个实际结果的正负，所以sf=1。但sf=1不能说明在逻辑上，运算所得的正确结果的正负。
```

```asm
mov ah,08ah
mov bh,070h
cmp ah,bh
; 结果 sf=0,运算 (ah)-(bh)的实际结果：1ah，但逻辑上应该得到的结果是：(-118)-112=-230
; sf记录实际结果的正负，所以，sf=0。但sf=0不能说明在逻辑上，运算所得的正确结果的正负。
```

但是逻辑上的结果的正负，才是cmp指令所求的真正结果，因为我们就是要靠它得到两个操作对象的比较信息。**所以cmp指令所作的比较结果，不是仅仅靠sf就能记录的，因为它只能记录实际结果的正负。**

实际结果的正负，之所以不能说明逻辑上真正结果的正负，关键的原因在于发生了溢出。如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了。

**所以，我们应该在考查 sf（得知实际结果的正负）的同时考查of（得知有没有溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。**



#### 结论

下面，我们以 cmp ah,bh 为例，总结一下CPU执行cmp指令后，sf和of的值是如何来说明比较的结果的。

（1）如果 sf=1，而of=0
of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；
因sf=1，实际结果为负，所以逻辑上真正的结果为负，所以 (ah)<(bh)。

（2）如果 sf=1，而of=1
of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；
因sf=1，实际结果为负。
实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负，简单分析下，就可以看出，**如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。**
这样，sf=1，of=1，说明了(ah)>(bh)

（3）如果 sf=0，而of=1
of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；
因sf=0，实际结果非负。而of=1说明有溢出，则结果非0，所以实际结果为正。
实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，简单分析下，就可以看出，**如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。**
这样，sf=0，of=1，说明了(ah)<(bh)

> 感觉有点像：如果发生溢出：of=1；逻辑结果(想要的结果) = 实际结果的反

（4）如果 sf=0，而of=0
of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；
因sf=0，实际结果非负。所以逻辑上真正的结果非负，所以 (ah)≥(bh)



> 上面，我们深入讨论了cmp指令在进行有符号数和无符号数比较时，对fag相关标志位的影响，和CPU如何通过相关的标志位来表示比较的结果。在学习中，**要注意领会8086CPU这种工作机制的设计思想**。实际上，这种设计思想对于各种处理机来说是普遍的。

下面的内容中我们将学习一些根据cmp指令的比较结果（即cmp指令执行后，相关标志位的值）进行工作的指令。



### 9. 检测比较结果的条件转移指令

**"转移" 指的是它能够修改 IP，而”条件“指的是它可以根据某种条件，决定是否修改IP。**

比如，jcxz就是一个条件转移指令，它可以检测cx中的数值，如果 (cx)=0，就修改IP，否则什么也不做。**所有条件转移指令的转移位移都是 [-128, 127]。**

> 除了 jcxz 之外，CPU还提供了其他条件转移指令，**大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改 IP**。它们检测的是哪些标志位呢？
>
> **就是被cmp指令影响的那些，表示比较结果的标志位。这些条件转移指令通常都和 cmp 相配合使用**，就好像call和ret指令通常相配合使用一样。

因为 cmp 指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种：
**即根据无符号数的比较结果进行转移的条件转移指令（它们检测zf、cf的值）和根据有符号数的比较结果进行转移的条件转移指令（它们检测sf、of和zf的值）**。

下面是常用的根据无符号数的比较结果进行转移的条件转移指令

```properties
指令					含义			检测的相关标志位
je (equal)			等于则转移		 zf=1
jne (not equal)		不等于则转移		zf=0
jb (below)			低于则转移		 cf=1
jnb (not below)		不低于则转移		cf=0
ja (above)			高于则转移		 cf=0 且 zf=0
jna (not above)		不高于则转移		cf=1 或 zf=1
# j 表示 jump 跳转
```

注意观察一下它们所检测的标志位，都是cmp指令进行无符号数比较的时候，记录比较结果的标志位。
比如 je，检测 zf 位，当 zf=1 的时候进行转移，如果在 je 前面使用了cmp指令，那么 je 对 zf 的检测，实际上就是间接地检测 cmp 的比较结果是否为两数相等。下面看一个例子。

编程实现如下功能：如果 (ah)=(bh)则(ah)=(ah)+(ah)，否则(ah)=(ah)+(bh)

```asm
	cmp ah,bh	; 判断 ah与bh
	je s		; 如果相等 执行s
	; 不相等 继续向下执行
	add ah,bh
	jmp short ok

s:	add ah,ah
ok:	...
```

> 上面的程序执行时，如果 (ah)=(bh) ，则 cmp ah,bh 使 zf=1，而 je 检测 zf 是否为1，如果为1，将转移到标号s处执行指令 add  ah,ah。
> 这也可以说，cmp比较ah、bh后所得到的相等的结果使得 je 指令进行转移。从而很好地体现了 je 指令的逻辑含义，相等则转移。
>
> 虽然 je 的逻辑含义是“相等则转移”，但它进行的操作是 zf=1时则转移。**“相等则转移”这种逻辑含义，是通过和cmp指令配合使用来体现的，因为是cmp指令为 “zf=1” 赋予了 “两数相等” 的含义**。

至于究竟在 je 之前使不使用cmp指令，在于我们的安排。**je检测的是 zf 位置，不管 je 前面是什么指令，只要CPU执行 je 指令时，zf=1，那么就会发生转移**，比如：

```asm
    mov ax,0
    add ax,0	; zf=0
    je s		; cpu执行je时，发现zf=0，于是跳到了标号s继续执行
    inc ax

s:	inc ax
```

> 执行后，(ax)=1。add ax,0 使得zf=1，所以 je 指令将进行转移。
> 可在这个时候发生的转移的确不带有“相等则转移”的含义。因为此处的je指令检测到的zf=1，不是由cmp等比较指令设置的，而是由add指令设置的，并不具有“两数相等”的含义。
> 但无论“zf=1”的含义如何，是什么指令设置的，只要是zf=1，就可以使得je指令发生转移

所以，所谓相等则转移指令是需要通过与cmp进行配合。至于到底是配合使用还是单独使用，看编程者。就像call与ret指令一样，配合起来就是调用子程序，但完全可以单独使用

对于jne、jb、jnb、ja、jna等指令和cmp指令配合使用的思想和 je 相同。



虽然我们分别讨论了 cmp 指令和与其比较结果相关的有条件转移指令，但是它们经常在一起配合使用。
所以我们在联合应用它们的时候，不必再考虑cmp指令对相关标志位的影响和 je 等指令对相关标志位的检测。
因为相关的标志位，只是为cmp和 je 等指令传递比较结果。我们可以直接考虑cmp和je等指令配合使用时，表现出来的逻辑含义。
它们在联合使用的时候表现出来的功能有些像高级语言中的IF语句。

> 也就是说：只是解释这个转移的原理，真正与cmp配合使用时，直接按照字面意思用就行。只有单独使用时才考虑考虑标志位的值变化



#### 例：

data段中的8个字节如下：

```asm
data segment
	db 8,11,8,1,8,5,63,38
data ends
```

（1）编程，统计 data 段中数值为8的字节的个数，用ax保存统计结果。

编程思路：初始设置 (ax)=0，然后用循环依次比较每个字节的值，找到一个和8相等的数就将ax的值加1.程序如下

```asm
    mov ax,data
    mov ds,ax
    mov bx,0	; ds:bx 指向data段的第一个字节

    mov ax,0
    mov cx,8
s:	cmp byte ptr [bx],8	; ds:bx 与8进行比较
	jne next	; 不相等跳到next，继续循环   类似于 if(ds[bx] != 8) jmp next
	inc ax		; 相等就计数
	
next:inc bx
	loop s
```

这个程序也可以写成这样

```asm
    mov ax,data
    mov ds,ax
    mov bx,0	; ds:bx 指向data段的第一个字节

    mov ax,0
    mov cx,8
s:	cmp byte ptr [bx],8	; ds:bx 与8进行比较
	je ok	; 相等就跳到ok 进行计数
	jmp short next		; 不相等就跳到next 继续循环
	
ok:	inc ax	; 相等 计数+1
next:inc bx	; 继续下次循环
	loop s
```

> 比起第一个程序，它直接地遵循了“等于8则计数值加1”的原则，用 je 指令检测等于8的情况，但是没有第一个程序精简。第一个程序用 jne 检测不等于8的情况，从而间接地检测等于8的情况。
> 要注意在使用 cmp 和条件转移指令时的这种编程思想。



（2）编程，统计 data 段中数值大于8的字节的个数，用ax保存统计结果。

编程思路：初始设置 (ax)=0，然后用循环依次比较每个字节的值，找到一个大于8的就将ax的值加1。程序如下。

```asm
    mov ax,data
    mov ds,ax
    mov bx,0	; ds:bx 指向data段的第一个字节

    mov ax,0
    mov cx,8
s:  cmp byte ptr [bx],8	; 和8进行比较
    jna next	; 如果不大于8转到next，继续循环
    			; jna 不大于 <=	ja 大于 >
    inc ax
    
next:inc bx
    loop s
```



（3）编程，统计data段中数值小于8的字节的个数，用ax保存统计结果。

编程思路：初始设置 (ax)=0，然后用循环依次比较每个字节的值，找到一个小于8的就将ax的值加1。程序如下。

```asm
    mov ax,data
    mov ds,ax
    mov bx,0	; ds:bx 指向data段的第一个字节

    mov ax,0
    mov cx,8
s:  cmp byte ptr [bx],8	; 和8进行比较
    jnb next	; 如果不小于8转到next，继续循环
    			; jnb 不小于 >=	jb 小于 <
    inc ax
    
next:inc bx
    loop s
```



### 10. DF标志和串传送指令

**flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。**

df=0  每次操作后 si、di 递增
df=1 每次操作后 si、di 递减

我们来看下面的一个串传送指令。

```asm
格式：movsb
功能：执行movsb指令相当于进行下面几步操作
（1）((es)*16+(di)) = ((ds)*16+(si))
（2）如果df=0 则：	(si)=(si)+1
					(di)=(di)+1
    如果df=1 则：	 (si)=(si)-1
                    (di)=(di)-1
```

用汇编语法描述 movsb 的功能如下。

```asm
mov es:[di],byte ptr ds:[si]	;8086并不支持这样的指令，这里只是个描述

如果 df=0:
inc si
inc di

如果 df=1:
dec si
dec di
```

可以看出，movsb 的功能是将 ds:si 指向的内存单元中的字节送入 es:di 中，然后根据标志寄存器 df 位的值，将 si 和 di 递增或递减。



当然，也可以传送一个字，指令如下
格式：movsw

movsw 的功能是将 ds:si 指向的内存字单元中的字送入 es:di 中，然后根据标志寄存器 df 位的值，将 si 和 di 递增2或递减2。

用汇编语法描述 movsw 的功能如下。

```asm
mov es:[di],word ptr ds:[si]	;8086并不支持这样的指令，这里只是个描述

如果 df=0:
add si,2
add di,2

如果 df=1:
sub si,2
sub di,2
```

movsb 和 movsw 进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都和 rep 配合使用，格式如下：
rep movsb

用汇编语法来描述 rep movsb 的功能就是：

```asm
s:movsb
  loop s
```

可见，rep 的作用是根据 cx 的值，重复执行后面的串传送指令。由于每执行一次 movsb 指令 si 和 di 都会递增或递减指向后一个单元或前一个单元，则 rep  movsb 就可以循环实现 (cx) 个字符的传送。

同理，也可以使用这样的指令：rep movsw。
相当于：

```asm
s:movsw
  loop s
```

由于 flag 的 df 位决定着串传送指令执行后，si 和 di 改变的方向，所以CPU应该提供相应的指令来对 df 位进行设置，从而使程序员能够决定传送的方向。

8086CPU提供下面两条指令对 df 位进行设置。

cld 指令：将标志寄存器的 df 位 置0

std 指令：将标志寄存器的 df 位 置1



#### 例子

（1）编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中

```asm
data segment
	db 'Welcome to masm!'
	db 16 dup (0)
data ends
```

我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息，它们是：

```properties
（1）传送的原始位置：ds:si
（2）传送的目的位置：es:di
（3）传送的长度：cx
（4）传送的方向：df
```

在这个问题中，这些信息如下。

```asm
（1）传送的原始位置：data:0
（2）传送的目的位置：data:0010
（3）传送的长度：16
（4）传送的方向：因为正向传送(每次串传送指令执行后，si和di递增)比较方便，所以设置df=0
```

```asm
mov ax,data
mov ds,ax
mov si,0	; ds:si 指向data:0

mov es,ax
mov di,16	; es:di 指向data:0010

mov cx,16	; (cx)=16，rep循环16次
cld			; 设置df=0 正向传送 即每次循环di、si+1
rep movsb	; 相当于一个循环，直到(cx)=0为止，将ds:si内容一一传送到es:di
```



（2）编程，用串传送指令，将F000H段中的最后16个字符复制到data段中

```asm
data segment
	db 16 dup (0)
data ends
```

我们还是先来看一下应该为串传送指令提供什么样的信息。

要传送的字符串位于 F000H 段的最后16个单元中，那么它的最后一个字符的位置F000:FFFF，是显而易见的。可以将 ds:si 指向F000H段的最后一个单元，将 es:di 指向data段中的最后一个单元，然后逆向（即从高地址向低地址）传送16个字节即可。

```asm
（1）传送的原始位置：f000:ffff
（2）传送的目的位置：data:000f
（3）传送的长度：16
（4）传送的方向：因为逆向传送(每次串传送指令执行后，si和di递减)比较方便，所以设置df=1
```

```asm
mov ax,0f000h
mov ds,ax
mov si,0ffffh	; ds:si 指向 f000:ffff

mov ax,data
mov es,ax
mov di,15	; es:di 指向data:000f

mov cx,16	; (cx)=16，rep循环16次
std			; 设置df=1 逆向传送 即每次循环di、si-1
rep movsb	; 相当于一个循环，直到(cx)=0为止，将ds:si内容一一传送到es:di
```



### 11. pushf 和 popf

**pushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存器中。**

pushf 和 popf，为直接访问标志寄存器提供了一种方法。



### 12. 标志寄存器在 Debug中的表示

在 Debug中，标志寄存器是按照有意义的各个标志位单独表示的。在 Debug中，我们可以看到下面的信息。

![image-20211229232346574](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211229232346574.webp)

下面列出 Debug对我们已知的标志位的表示。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211229232413848.webp" alt="image-20211229232413848" style="zoom:67%;" />







## 第十二章 内中断

任何一个通用的CPU，比如8086，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。
**中断的意思是指，CPU不再接着（刚执行完的指令）继续向下执行，而是转去处理这个特殊信息。**

注意，我们这里所说的中断信息，是为了便于理解而采用的一种逻辑上的说法。它是对几个具有先后顺序的硬件操作所产生的事件的统一描述。
**“中断信息”是要求CPU马上进行某种处理，并向所要进行的该种处理提供了必备的参数的通知信息。**

因为本书的内容不是微机原理与接口或组成原理，所以这里是描述和解释。

**中断信息可以来自CPU的内部和外部**，这一章中，我们主要讨论来自于CPU内部的中断信息。



### 1. 内中断的产生

当CPU的内部有什么事情发生的时候，将产生需要马上处理的中断信息呢？对于8086CPU，当CPU内部有下面的情况发生的时候，将产生相应的中断信息。

（1）除法错误，比如，执行 div 指令产生的除法溢出；

（2）单步执行；

（3）执行 into 指令

（4）执行 int 指令。

我们现在不要去管这4种情况的具体含义，只要知道CPU内部有4种情况可以产生需要及时处理的中断信息即可。虽然我们现在并不很清楚，这4种情况到底是什么，但是有一点是很清楚的，即，它们是不同的信息。

既然是不同的信息，就需要进行不同的处理。要进行不同的处理，CPU首先要知道，所接收到的中断信息的来源。所以**中断信息中必须包含识别来源的编码。8086CPU用称为<font color="red">中断类型码</font>的数据来标识中断信息的来源。**
**中断类型码为一个字节型数据，可以表示256种中断信息的来源**。以后，我们将产生中断信息的事件，即中断信息的来源，简称为中断源，上述的4种中断源，在8086CPU中的中断类型码如下。

（1）除法错误：0

（2）单步执行：1

（3）执行 into 指令：4

（4）执行 int 指令，该指令的格式为 int n，指令中的 n 为字节型立即数，是提供给CPU的中断类型码。



### 2. 中断处理程序

CPU收到中断信息后，需要对中断信息进行处理。而如何对中断信息进行处理，可以由我们编程决定。我们编写的，**用来处理中断信息的程序被称为中断处理程序。一般来说，需要对不同的中断信息编写不同的处理程序。**

CPU在收到中断信息后，应该转去执行该中断信息的处理程序。我们知道，若要8086CPU执行某处的程序，就要将 CS:IP 指向它的入口（即程序第一条指令的地址）。**可见首要的问题是，CPU在收到中断信息后，如何根据中断信息确定其处理程序的入口。**

CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。

我们知道，中断信息中包含有标识中断源的类型码。根据CPU的设计，**中断类型码的作用就是用来定位中断处理程序。比如CPU根据中断类型码4，就可以找到4号中断的处理程序**。可随之而来的问题是，**若要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢？**



### 3. 中断向量表

**CPU用 8 位的中断类型码通过<font color="red">中断向量表</font>找到相应的中断处理程序的入口地址**。那么什么是中断向量表呢？中断向量表就是中断向量的列表。
那么什么又是中断向量呢？所谓中断向量，就是中断处理程序的入口地址。展开来讲，**中断向量表，就是中断处理程序入口地址的列表。**

**中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口**，如图12.1所示。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211230110337631.webp" alt="image-20211230110337631" style="zoom:80%;" />

> 可以看到，CPU只要知道了中断类型码，**就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到中断处理程序的入口地址**

可见，**CPU用中断类型码，通过查找中断向量表，就可以得到中断处理程序的入口地址**。
在这个方案中，一个首要的问题是，CPU如何找到中断向量表？现在，找到中断向量表成了通过中断类型码找到中断处理程序入口地址的先决条件。

中断向量表在内存中存放，**对于8086PC机，中断向量表指定放在内存地址0处。从内存 0000:0000 到 0000:03FF的1024个单元中存放着中断向量表**。能不能放在别处呢？
不能，如果使用8086CPU，中断向量表就必须放在 0000:0000~0000:03FF 单元中，这是规定，因为8086CPU就从这个地方读取中断向量表

那么在中断向量表中，一个表项占多大的空间呢？一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，**对于8086CPU，这个<font color="red">入口地址包括段地址和偏移地址</font>，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。**



### 4. 中断过程

从上面的讲解中，我们知道，可以用中断类型码，在中断向量表中找到中断处理程序的入口。找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序。
**用中断类型码找到中断向量，并用它设置CS和IP**，这个工作是由CPU的硬件自动完成的。**CPU硬件完成这个工作的过程被称为中断过程**。

CPU收到中断信息后，要对中断信息进行处理，首先将引发中断过程。硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。

有一个问题需要考虑，CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。**所以在中断过程中，在设置 CS:IP 之前，还要将原来的CS和IP的值保存起来**。
在使用call指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call指令先保存当前CS和IP的值，然后再设置CS和IP。



下面是8086CPU在收到中断信息后，所引发的中断过程。

```properties
（1）(从中断信息中)取得中断类型码；
（2）标志寄存器的值入栈（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中）；
（3）设置标志寄存器的第8位TF和第9位IF的值为0（这一步的目的后面将介绍）；
（4）CS的内容入栈；
（5）IP的内容入栈；
（6）从内存地址为 中断类型码*4(中断程序的偏移地址) 和 中断类型码*4+2(中断程序的段地址) 的两个字单元中读取中断处理程序的入口地址设置IP和CS。
```

CPU在收到中断信息之后，如果处理该中断信息，就完成一个由硬件自动执行的中断过程（程序员无法改变这个过程中所要做的工作）。
**中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置CS和IP。**

因为中断处理程序执行完成后，CPU还要回过头来继续执行被中断的程序，所以要在设置CS、IP之前，先将它们的值保存起来。可以看到CPU将它们保存在栈中。
我们注意到，在中断过程中还要做的一个工作就是设置标志寄存器的TF、IF位，对于这样做的目的，我们将在后面的内容和下一章中进行讨论。

因为**在执行完中断处理程序后，需要恢复在进入中断处理程序之前的CPU现场（某一时刻，CPU中各个寄存器的值）。所以应该在修改标记寄存器之前，将它的值入栈保存。**



我们更简洁地描述中断过程，如下：

```asm
(1) 取得中断类型码 N
(2) pushf
(3) TF=0,IF=0
(4) push CS
(5) push IP
(6) (IP)=(N*4), (CS)=(N*4+2)
```

在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。



### 5. 中断处理程序和iret指令

由于CPU随时都可能检测到中断信息，也就是说，**CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中**。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。

中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：

（1）保存用到的寄存器；
（2）处理中断；
（3）恢复用到的寄存器；
（4）用 iret 指令返回。

iret 指令的功能用汇编语法描述为：

```asm
pop IP
pop CS
popf
```

**iret 通常和硬件自动完成的中断过程配合使用。**
可以看到，在中断过程中，寄存器入栈的顺序是 标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其相对应，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。

**iret 指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。**



### 6. 除法错误中断的处理

下面的内容中，我们通过对0号中断，即除法错误中断的处理，来体会一下前面所讲的内容。

当CPU执行 div 等除法指令的时候，如果发生了**除法溢岀错误，将产生中断类型码为 0 的中断信息**，CPU将检测到这个信息，然后引发中断过程，转去执行 0 号中断所对应的中断处理程序。
我们看一下下面程序的执行结果，如图12.2所示（不同的操作系统下显示可能不同）。

```asm
mov ax,1000h
mov bh,1
div bh
```

![image-20211230135507528](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20211230135507528.webp)

> 有一说一：我在电脑上测试这段代码，发现正常执行，并没有被中断。不管是用 dosbox 还是vscode的debug，在程序中写了这写代码，然后调试，还是没报错
>
> 注：vscode模拟的汇编debug，不算真正的，应该是系统分配的一块内存模拟出来使用的
>
> dosbox模拟的汇编debug，接近真实(到底是不是真的不知道)，也有保护机制，进行修改，关闭后重开会复原

可以看到，当CPU执行 div  bh 时，发生了除法溢出错误，产生0号中断信息，从而引发中断过程，CPU执行 0 号中断处理程序。我们从图中可以看出系统中的0号中断处理程序的功能：显示提示信息“Divide  overflow”后，返回到操作系统中。

> 或许可以测试：除0错误



### 7. 编程处理0号中断

现在我们考虑改变一下 0 号中断处理程序的功能，即重新编写一个 0 号中断处理程序，它的功能是在屏幕中间显示“overflow！”，然后返回到操作系统

当CPU执行 div  bh 后，发生了除法溢出错误，产生0号中断信息，引发中断过程，CPU执行我们编写的0号中断处理程序。在屏幕中间显示提示信息“overflow！”后，返回到操作系统中。



编程：当发生除法溢出时，在屏幕中间显示“overflow！”，返回DOS。

我们首先进行分析：
（1）当发生除法溢出的时候，产生0号中断信息，从而引发中断过程。

此时，CPU将进行以下工作。
① 取得中断类型码 0；
② 标志寄存器入栈，TF、IF 设置为0；
③ CS、IP 入栈；
④ (IP)=(0\*4)，(CS)=(0*4+2).

（2）可见，当中断 0 发生时，CPU将转去执行中断处理程序。

只要按如下步骤编写中断处理程序，当中断0发生时，即可显示“overflow！”。
① 相关处理；
② 向显示缓冲区送字符串 “overflow！“；
③ 返回DOS。

我们将这段程序称为：do0

（3）现在的问题是：do0 应存放在内存中。因为除法溢出随时可能发生，CPU随时都可能将CS:IP指向do0的入口，执行程序。

那么do0应该放在哪里呢？
由于我们是在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，所以我们要想得到一块内存区存放do0，应该向操作系统申请。

但在这里出于两个原因我们不想这样做：
① 过多地讨论申请内存将偏离问题的主线
② 我们学习汇编的一个重要目的就是要获得对计算机底层的编程体验。所以，在可能的情况下，我们不去理会操作系统，而直接面向硬件资源。

问题变得简单而直接，我们只需找到一块别的程序不会用到的内存区，将do0传送到其中即可。

前面讲到，内存 0000:0000-0000:03FF，大小为 1KB 的空间是系统存放中断处理程序入口地址的中断向量表。8086支持256个中断，但是，实际上，系统中要处理的中断事件远没有达到256个。所以在中断向量表中，有许多单元是空的。

> 中断向量表是PC系统中最重要的内存区，只用来存放中断处理程序的入口地址，DOS系统和其他应用程序都不会随便使用这段空间。可以利用中断向量表中的空闲单元来存放我们的程序。
> 一般情况下，从 0000:0200 至 0000:02FF 的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用。我们在前面的课程中使用过这段空间（参见5.7节）。

由此，我们可以估计出，do0的长度不能超过256个字节。

**结论：我们可以将 do0 传送到内存 0000:0200 处。**



（4）将中断处理程序 do0 放到 0000:0200 后，若要使得除法溢出发生的时候，CPU转去执行 do0，则必须将do0的入口地址，即 0000:0200 登记在中断向量表的对应表项中。
因为除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从 0\*4 地址单元开始存放，段地址存放在 0\*4+2 字单元中，偏移地址存放在0*4字单元中。

也就是说要将 do0 的段地址 0 存放在 0000:0002 字单元中，将偏移地址 200H 存放在 0000:0000 字单元中。

总结上面的分析，我们要做以下几件事情。

（1）编写可以显示 “overflow！” 的中断处理程序：do0；

（2）将 do0 送入内存 0000:0200 处；

（3）将 do0 的入口地址 0000:0200 存储在中断向量表 0 号表项中。



#### 程序12.1

```asm
assume cs:code
code segment
start:	do0 安装程序
		设置中断向量表
		mov ax,4c00h
		int 21h
		
do0:	显示字符串"overflow!"
		mov ax,4c00h
		int 21h
code ends
end start
```

可以看到，上面的程序分为两部分：
（1）安装 do0，设置中断向量的程序；
（2）do0

程序12.1执行时，do0 的代码是不执行的，它只是作为 do0 安装程序所要传送的数据。
程序12.1执行时，首先执行 do0 安装程序，将 do0 的代码复制到内存 0:200 处，然后设置中断向量表，将 do0 的入口地址，即偏移地址 200H 和段地址 0，保存在 0 号表项中。

这两部分工作完成后，程序就返回了。程序的目的就是在内存 0:200 处安装 do0 的代码，将 0 号中断处理程序的入口地址设置为 0:200。
**do0的代码虽然在程序中，却不在程序执行的时候执行。它是在除法溢出发生的时候才得以执行的中断处理程序。**

do0 部分代码的最后两条指令是依照我们的编程要求，用来返回DOS的。



#### CPU 角度

现在，我们在反过来从CPU的角度看一下，什么是中断处理程序？我们来看一下 do0 是如何变成 0 号中断的中断处理程序的。

（1）程序12.1在执行时，被加载到内存中，此时 do0 的代码在程序12.1所在的内存空间中，它只是存放在程序12.1的代码段中的一段要被传送到其他单元中的数据，我们不能说它是0号中断的中断处理程序；

（2）程序12.1中安装 do0 的代码执行完后，do0 的代码被从程序12.1的代码段中复制到 0:200 处。此时，我们也不能说它是0号中断的中断处理程序，它只不过是存放在 0:200 处的一些数据；

（3）程序12.1中设置中断向量表的代码执行完后，在 0 号表项中填入了 do0 的入口地址 0:200，此时 0:200 处的信息，即 do0 的代码，就变成了 0 号中断的中断处理程序。
因为当除法溢出（即0号中断）发生时，CPU将执行 0:200 处的代码。

> 回忆：
>
> 我们如何让一个内存单元成为栈顶？将它的地址放入SS、SP中；
>
> 我们如何让一个内存单元中的信息被CPU当作指令来执行？将它的地址放入CS、IP中；
>
> 那么，我们如何让一段程序成为N号中断的中断处理程序？将它的入口地址放入中断向量表的N号表项中。

下面的内容中，我们讨论每一部分程序的具体编写方法。



### 8. 安装

可以使用 movsb 指令，将do0的代码送入0:200处。程序如下。

```asm
assume cs:code
code segment
start:	设置 es:di 指向目标地址
		设置 ds:si 指向源地址
		设置 cx 为传输长度
		设置传输方向为正
		rep movsb
		
		设置中断向量表
		
		mov ax,4c00h
		int 21h
		
	do0:显示字符串"overflow!"
    	mov ax,4c00h
		int 21h
code ends
end start
```

我们来看一下，用 rep movsb 指令的时候要确定的信息
（1）传送的原始位置，段地址：code，偏移地址：offset  do0；
（2）传送的目的位置：0:200；
（3）传送的长度：do0 部分代码的长度；
（4）传送的方向：正向。

```asm
assume cs:code
code segment
start:	mov ax,cs
		mov ds,ax
		mov si,offset do0	; 设置 ds:si 指向源地址
		
		mov ax,0
		mov es,ax
		mov di,200h			; 设置 es:di 指向目标地址
		
		mov cx,do0部分代码的长度 ; 设置 cx 为传输长度
		
		cld					; 设置传输方向为正
		rep movsb
		
		设置中断向量表
		
		mov ax,4c00h
		int 21h
		
	do0:显示字符串"overflow!"
    	mov ax,4c00h
		int 21h
code ends
end start
```

问题是，我们如何知道 do0 代码的长度？最简单的方法是，计算一下 do0 中所有指令码的字节数。但是这样做太麻烦了，因为只要 do0 的内容发生了改变，我们都要重新计算它的长度。

可以利用编译器来计算 do0 的长度，具体做法如下。

```asm
assume cs:code
code segment
start:	mov ax,cs
		mov ds,ax
		mov si,offset do0	; 设置 ds:si 指向源地址
		mov ax,0
		mov es,ax
		mov di,200h			; 设置 es:di 指向目标地址
		
		mov cx,offset do0end - offset do0 ; 设置 cx 为传输长度
		; "-" 是编译器识別的运算符号，编译器可以用它来进行两个常数的减法。
		
		cld					; 设置传输方向为正
		rep movsb
		
		设置中断向量表
		
		mov ax,4c00h
		int 21h
		
	do0:显示字符串"overflow!"
    	mov ax,4c00h
		int 21h
do0end:	nop

code ends
end start
```

> "-" 是编译器识別的运算符号，编译器可以用它来进行两个常数的减法。
>
> 比如，指令：mov ax,8-4，被编译器处理为指令：mov ax,4。**汇编编译器可以处理表达式。**
>
> 比如，指令：mov ax,(5+3)*5/10，被编译器处理为指令：mov ax,4



### 9. do0(自定义0号中断)

do0 程序的主要任务是显示字符串，程序如下。

```asm
do0:设置 ds:si 指向字符串
	mov ax,0b800h
	mov es,ax
	mov di,12*160+36*2	; 设置 es:di 指向显存空间的中间位置
	; 一行80个字符 显存中一个字符占2字节，所以这里是跳到 第12行36列
	
	mov cx,9			; 设置 cx 为字符串长度
s:	mov al,[si]			; 将 ds:si 的一个字符(1字节)移入al
	mov es:[di],al		; 将 al 送入 es:di 中
	; 进入下次循环 直到cx=0
	inc si
	add di,2
	loop s
	
	mov ax,4c00h
	int 21h
	
do0end:nop
```

程序写好了，可要显示的字符串放在那里呢？我们看下面的程序

#### 程序 12.2

```asm
assume cs:code
data segment
	db 'overflow!'
data ends

code segment
start:	do0 安装程序
		设置中断向量表
		mov ax,4c00h
		int 21h
		
do0:	显示字符串"overflow!"
		mov ax,4c00h
		int 21h
do0end:	nop

code ends
end start
```

上面的程序，看似将提示信息放到 data 段中很合理，可实际上却大错特错。

注意，“overflow！”在程序12.2的 data 段中。**程序12.2执行完成后返回，它所占用的内存空间被系统释放，而在其中存放的“overflow！”也将很可能被别的信息覆盖**。

而 do0 程序被放到了 0:200 处，随时都会因发生了除法溢出而被CPU执行，很难保证 do0 程序从原来程序12.2所处的空间中取得的是要显示的字符串“overflow！”。

**因为 do0 程序随时可能被执行，而它要用到字符串“overflow！”，所以该字符串也应该存放在一段不会被覆盖的空间中。**正确的程序如下

#### 程序 12.3

```asm
assume cs:code
code segment
start:	mov ax,cs
		mov ds,ax
		mov si,offset do0	; 设置 ds:si 指向源地址
		mov ax,0
		mov es,ax
		mov di,200h			; 设置 es:di 指向目标地址
		
		mov cx,offset do0end - offset do0 ; 设置 cx 为传输长度
		; "-" 是编译器识別的运算符号，编译器可以用它来进行两个常数的减法。
		
		cld					; 设置传输方向为正
		rep movsb
		
		设置中断向量表
		
		mov ax,4c00h
		int 21h
		
	do0:jmp short do0start
    	db "overflow!"
    	
do0start:   
		mov ax,cs		; 不知道用0可不可以，不过，既然cs:ip执行到了这里，此时提示字符与cs处于同一地址
		mov ds,ax
		mov si,202h		; 设置 ds:si 指向字符串
		
		mov ax,0b800h
        mov es,ax
        mov di,12*160+36*2	; 设置 es:di 指向显存空间的中间位置
        ; 一行80个字符 显存中一个字符占2字节，所以这里是跳到 第12行36列
	
        mov cx,9			; 设置 cx 为字符串长度
    s:	mov al,[si]			; 将 ds:si 的一个字符(1字节)移入al
        mov es:[di],al		; 将 al 送入 es:di 中
        ; 进入下次循环 直到cx=0
        inc si
        add di,2
        loop s

    	mov ax,4c00h
		int 21h
		
do0end:	nop

code ends
end start
```

在程序12.3中，将“overflow！”放到 do0 程序中，程序12.3执行时，将标号 do0 到标号 do0end 之间的内容送到0000:0200 处。

注意，**因为在 do0 程序开始处的“overflow！”不是可以执行的代码，所以在“overflow！”之前加上一条 jmp 指令**，转移到正式的 do0 程序。当除法溢出发生时，CPU执行0:200处的jmp指令，跳过后面的字符串，转到正式的do0程序执行。

do0 程序执行过程中必须要找到“overflow！”，那么它在哪里呢？首先来看段地址，“overflow！”和 do0 的代码处于同一个段中，而除法溢出发生时，CS中必然存放 do0 的段地址，也就是“overflow！”的段地址；
再来看偏移地址，0:200处的指令为  jmp short do0start，这条指令占两个字节，所以“overflow！”的偏移地址为202h



### 10. 设置中断向量

下面，将 do0 的入口地址 0:200，写入中断向量表的 0 号表项中，使 do0 成为 0 号中断的中断处理程序。

0 号表项的地址为 0:0，其中 0:0 字单元存放偏移地址，0:2 字单元存放段地址。程序如下

```asm
mov ax,0
mov es,ax	; 将 es的段地址修改为0
mov word ptr es:[0*4],200h	; 将 es:[0*4] 处(原0号中断入口地址的偏移地址)改为 do0的偏移地址
mov word ptr es:[0*4+2],0	; 将 es:[0*4+2] 处(原0号中断入口地址的段地址)改为 do0的段地址
```



### 11. 单步中断

基本上，**CPU在执行完一条指令之后，如果检测到标志寄存器的 TF 位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1**，则它所引发的中断过程如下。

```properties
（1）取得中断类型码 1；
（2）标志寄存器入栈，TF、IF 设置为0；
（3）CS、IP 入栈
（4）(IP) = (1*4), (CS) = (1*4+2)
```

如上所述，如果TF=1，则执行一条指令后，CPU就要转去执行1号中断处理程序。CPU为什么要提供这样的功能呢？

我们在使用 Debug 的 t 命令的时候，有没有想过这样的问题，Debug 如何能让CPU在执行一条指令后，就显示各个寄存器的状态？

我们知道，CPU在执行程序的时候是从 CS:IP 指向的某个地址开始，自动向下读取指令执行。也就是说，如果CPU不提供其他功能的话，就按这种方式工作，只要CPU一加电，它就从预设的地址开始一直执行下去，不可能有任何程序能控制它在执行完一条指令后停止，去做别的事情。
可是，我们在Debug中看到的情况却是，Debug 可以控制CPU执行被加载程序中的一条指令，然后让它停下来，显示寄存器的状态。

Debug有特殊的能力吗？我们只能说 Debug 利用了CPU提供的一种功能。只有CPU提供了在执行一条指令后就转去做其他事情的功能，Debug或是其他的程序才能利用CPU提供的这种功能做出我们使用 T 命令时的效果。



我们来简要地考虑一下 Debug 是如何利用CPU所提供的单步中断的功能的。
首先，Debug 提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。然后，在使用 t命令执行指令时，Debug 将 TF 设置为1，使得CPU工作于单步中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。

> 那么，接下来的问题是，当TF=1时，CPU在执行完一条指令后将引发单步中断，转去执行中断处理程序。
> 注意，**中断处理程序也是由一条条指令组成的**，如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序，在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序.......

CPU当然不能让这种情况发生，解决的办法就是，**在进入中断处理程序之前，设置TF=0。从而避免CPU在执行中断处理程序的时候发生单步中断**。这就是为什么在中断过程中有 TF=0 这个步骤，我们再来看一下中断过程。

```properties
（1）取得中断类型码 N；
（2）标志寄存器入栈，TF=0、IF=0；
（3）CS、IP 入栈
（4）(IP) = (N*4), (CS) = (N*4+2)
```

最后，**CPU提供单步中断功能的原因就是，为单步跟踪程序的执行过程，提供了实现机制**。



### 12. 响应中断的特殊情况

一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应。对于这些情况，我们不一一列举，只是用一种情况来进行说明。

**在执行完向 ss 寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。**

这样做的主要原因是，**ss:sp 联合指向栈顶，而对它们的设置应该连续完成**。如果在执行完设置 ss 的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS 和 IP 的值。而 ss 改变，sp 并未改变，ss:sp 指向的不是正确的栈顶，将引起错误。所以CPU在执行完设置 ss 的指令后，不响应中断。

这给连续设置 ss 和 sp 指向正确的栈顶提供了一个时机。即，我们应该利用这个特性，将设置 ss 和 sp 的指令连续存放，使得设置 sp 的指令紧接着设置 ss 的指令执行，而在此之间，CPU不会引发中断过程。比如，我们要将栈顶设为 1000:0，应该：

```asm
mov ax,1000h
mov ss,ax
mov sp,0
```

而不应该：

```asm
mov ax,1000h
mov ss,ax
mov ax,0
mov sp,0
```

> 好了，现在我们回过来看一下，实验2中的“（3）下一条指令执行了吗？”。现在你知道原因了吗？
>
> 即：在debug中，单步执行mov ax,1000h；mov ss,ax；mov sp,0。发现，并没有单步到(看到) mov sp,0的执行
>
> **Debug 利用单步中断来实现 T 命令的功能**，也就是说，用T命令执行一条指令后，CPU响应单步中断，执行  Debug设置好的处理程序，才能在屏幕上显示寄存器的状态，并等待命令的输入。
>
> 而在 mov ss,ax 指令执行后，CPU根本就不响应任何中断，其中也包括单步中断，所以 Debug 设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。
> CPU接着向下执行后面的指令 mov sp,0h，然后响应单步中断，我们才看到正常的结果。





## 第十三章 int指令

中断信息可以来自CPU的内部和外部，当CPU的内部有需要处理的事情发生的时候，将产生需要马上处理的中断信息，引发中断过程。在第12章中，我们讲解了中断过程和两种内中断的处理。

这一章中，我们讲解另一种重要的内中断，**由 int 指令引发的中断**。



### 1. int 指令

**int 指令的格式为：int n，n为中断类型码，它的功能是引发中断过程。**

CPU执行 int n 指令，相当于引发一个 n 号中断的中断过程，执行过程如下。

```properties
（）取中断类型码 n；
（）标志寄存器入栈，IF=0，TF=0；
（）CS、IP入栈；
（）(IP)=(n*4), (CS)=(n*4+2)
```

从此处转去执行 n 号中断的中断处理程序。

可以在程序中使用 int 指令调用任何一个中断的中断处理程序。例如，下面的程序：

```asm
assume cs:code
code segment
start:	mov ax,0b800h
		mov es,ax
		mov byte ptr es:[12*160+40*2],'!'	; 将 '!' 写入显存12行40列
		int 0
code ends
end start
```

此程序在执行时，将在屏幕中间显示一个 “!”，然后显示 “Divide  overflow” 后返回到系统中。“!” 是我们编程显示的，而 “Divide  overflow” 是哪里来的呢？

程序是没有做除法，但是在结尾使用了 int 0 指令。CPU执行 int 0 指令时，将引发中断过程，执行 0 号中断处理程序，而系统设置的 0 号中断处理程序的功能是显示 “Divide overflow”，然后返回到系统。

> 可见，int 指令的最终功能和 call 指令相似，都是调用一段程序。
>
> 一般情况下，**系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用**。我们在编程的时候，可以**用 int 指令调用这些子程序**。当然，也可以自己编写些中断处理程序供别人使用。以后，我们可以将**中断处理程序简称为中断例程**。



### 2. 编写供应用程序调用的中断例程

前面，我们已经编写过中断 0 的中断例程了，现在我们讨论可以供应用程序调用的中断例程的编写方法。下面通过两个问题来讨论。

#### 问题一：编写、安装中断 7ch 的中断例程。

```asm
; 功能：求一word型数据的平方。
; 参数：(ax)=要计算的数据
; 返回值：dx、ax中存放结果的高16位和低16位
; 应用举例：求2*3456^2。
assume cs:code
code segment
start:	mov ax,3456	; (ax)=3456
		int 7ch		; 调用中断 7ch 的中断例程，计算ax中数据的平方
		add ax,ax	; dx:ax 存放结果，将结果乘以2。自己+自己就相当于乘2
		adc dx,dx	; 低位直接相加，高位带位相加
		
		mov ax,4c00h
		int 21h
code ends
end start
```

分析一下，我们要做以下3部分工作。

（1）编写实现求平方功能的程序；
（2）安装程序，将其安装在 0:200 处
（3）设置中断向量表，将程序的入口地址保存在 7ch 表项中，使其成为中断 7ch 的中断例程。

安装程序如下。

```asm
assume cs:code
code segment
; 安装程序是干嘛的？安装程序：将中断例程的所有代码复制到安全空间，然后修改中断向量表指向自定义的中断例程
start:	mov ax,cs	
		mov ds,ax		
		mov si,offset sqr	; 设置 ds:si 指向源地址。因为中断例程sqr就在本程序下，只不过不运行，只是作为子程序，需要被安装(复制)到安全空间，所以源地址的段地址=cs
		mov ax,0
		mov es,ax
		mov di,200h			; 设置 es:di 指向目标地址。安全空间：0:200h~0:2ffh
		mov cx,offset sqrend - offset sqr	; 循环次数=sqr的字节长度
		cld			; 依次递增拷贝
		rep movsb	; 开始循环拷贝
		
		; 设置中断向量表中的7ch入口地址 指向自定义的中断例程
		mov ax,0
		mov es,ax
		mov word ptr es:[7ch*4],200h
		mov word ptr es:[7ch*4+2],0
		
		mov ax,4c00h
		int 21h
		
sqr:	mul ax		; 中断例程
		iret
		
sqrend:	nop			; 占位符，主要用来计算整个中断例程的字节大小
code ends
end start
```

注意，在中断例程 sqr 的最后，要使用 iret 指令。用汇编语法描述，iret 指令的功能为：

```asm
pop IP
pop CS
popf
```

CPU执行 int 7ch 指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈中，在执行完中断例程后，应该用 iret 指令恢复 int 7ch 执行前的标志寄存器和CS、IP的值，从而接着执行应用程序。


>因为我们编写这个中断例程主要是用于计算，所以中断例程算完了肯定需要恢复现场，让CPU继续执行原程序

#### 个人认为 int与call调用程序的区别

**int 指令和 iret 指令的配合使用与 call 指令和 ret 指令的配合使用具有相似的思路。**

> 我感觉：int 与 call 都可以调用子程序，区别在于：call 调用的子程序必须在同一文件范围内，且用完就没了，只能被本程序调用；
>
> 而 int 调用子程序时，由于子程序被写在了**常驻**的安全空间，可以被多个不同的程序调用，复用性强



#### 问题二：编写、安装中断7ch的中断例程。

```asm
; 功能：将一个全是字母，以0结尾的字符串，转化为大写。
; 参数：ds:si指向字符串的首地址。
; 应用举例：将data段中的字符串转化为大写。
assume cs:code
data segment
	db 'conversation',0
data ends

code segment
start:	mov ax,data
		mov ds,ax
		mov si,0	; ds:si 指向字符串
		int 7ch
		
		mov ax,4c00h
		int 21h
code ends
end start
```

安装程序如下。

```asm
assume cs:code
code segment
start:	mov ax,cs
		mov ds,ax
		mov si,offset captial	; ds:si 指向源地址
		mov ax,0
        mov es,ax
        mov di,200h		; es:di 指向目标地址 安全空间 0:200h
        mov cx,offset captialend - offset captial	; 为啥不直接减si？- 只能作用于两个常数(立即数)，减si 又得新加一条指令
        cld		; 方向：递增
        rep movsb	; 开始逐字节拷贝
        
        ; 修改 7ch 的入口地址
        mov ax,0
        mov es,0
        mov word ptr es:[7ch*4],200h	; 偏移地址
        mov word ptr es:[7ch*4+2],0		; 段地址
		
		mov ax,4c00h
		int 21h
; 中断例程
capital:push cx
		push si
		
change:	mov cl,[si]	; 将 ds:si 的字符送入cl
		mov ch,0
		jcxz ok		; 如果cx=0 执行ok，即 循环终止条件：cx=0
		and byte ptr [si],11011111b	; 转大写
		inc si		; 执行下个字符
		jmp short change
		
	ok:	pop si
		pop cx
		iret	; 还原现场，让cpu继续执行原程序
capitalend:nop	; 占位符 用于计算中断例程的大小		
code ends
end start
```

在中断例程 capital 中用到了寄存器 si 和 cx，**编写中断例程和编写子程序的时候具有同样的问题，就是要避免寄存器的冲突。应该注意例程中用到的寄存器的值的保存和恢复。**

> 注意：保护现场只针对于，还想让CPU返回原程序执行的情况。如果是编写 提示错误信息并返回到dos 的中断例程，就没必要保护现场了。原程序调用这个子程序都直接退出了，保护了也没啥用。



### 3. 对int、iret和栈的深入理解(好好看看)

问题：用 7ch 中断例程完成 loop 指令的功能。

**loop s 的执行需要两个信息，循环次数和到 s 的位移**，所以，7ch中断例程要完成 loop 指令的功能，也需要这两个信息作为参数。我们用 cx 存放循环次数，用 bx 存放位移。

应用举例：在屏幕中间显示80个 '!'

```asm
assume cs:code
code segment
start:	mov ax,0b800h
		mov es,ax
		mov di,160*12	; 二话不说 先定位到 显存中的12行
		
		mov bx,offset s - offset se	; 设置从标号se到标号s的转移位移量
		mov cx,80	; 设置循环次数
	s:	mov byte ptr es:[di],'!'
		add di,2
		int 7ch		; 模拟loop指令：如果(cx)≠0，转移到标号s处
	se:	nop
	
		mov ax,4c00h
		int 21h
code ends
end start
```

在上面的程序中，用 int 7ch 调用 7ch 中断例程进行转移，用 bx 传递转移的位移。

分析：为了模拟 loop 指令，7ch中断例程应具备下面的功能。
（1）dec cx；(cx--)
（2）如果 (cx)≠0，转到标号 s 处执行，否则向下执行。

下面我们分析 7ch 中断例程如何实现到目的地址的转移。
（1）转到标号 s 显然应设 (CS)=标号s的段地址，(IP)=标号 s 的偏移地址。
（2）那么，**中断例程如何得到标号 s 的段地址和偏移地址呢？**

int 7ch 引发中断过程后，进入 7ch 中断例程，在中断过程中，当前的标志寄存器、CS和IP都要压栈，此时**压入的CS和IP中的内容**，分别是**调用程序的段地址（可以认为是标号s的段地址）和  int  7ch 后一条指令的偏移地址（即标号se的偏移地址）**。

（3）现在知道，**可以从栈中直接和间接地得到标号 s 的段地址和偏移地址**，那么如何用它们设置CS:IP呢？

可以利用 iret 指令，**我们将栈中的 se 的偏移地址加上 bx 中的转移位移，则栈中的 se 的偏移地址就变为了 s 的偏移地址**。我们再使用 iret 指令，用栈中的内容设置CS、IP，从而实现转移到标号 s 处。

7ch 中断例程如下：

```asm
lp:	push bp		; 保护bp
	mov bp,sp	; bp指向了栈空间，现在栈顶是 原bp的值
	dec cx		; 先让cx-1
	jcxz lpret	; 如果cx=0 跳转到lpret
	add [bp+2],bx	; ss:[bp] 是取栈顶值，ss:[bp+2]是原IP的值
				; 原IP值(se的偏移地址)+bx(se到e的位移地址)=s的偏移地址
lpret:
	pop bp
	iret
```

因为要访问栈，使用了 bp，在程序开始处将 bp 入栈保存，结束时出栈恢复。当要修改栈中 se 的偏移地址的时候。**栈中的情况为：栈顶处是bp原来的数值，下面是se的偏移地址，再下面是s的段地址，再下面是标志寄存器的值**。

而此时，bp中为栈顶的偏移地址，所以 ((ss)*16+(bp)+2) 处为se的偏移地址，将它加上bx中的转移位移就变为s的偏移地址。最后用 iret 出栈返回，CS:IP即从标号s处开始执行指令。

如果 (cx)=0，则不需要修改栈中se的偏移地址，直接返回即可。CPU从标号se处向下执行指令。



### 4. BIOS和DOS所提供的中断例程

在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统），BIOS中主要包含以下几部分内容。

```properties
（1）硬件系统的检测和初始化程序；
（2）外部中断（第15章中进行讲解）和内部中断的中断例程
（3）用于对硬件设备进行I/O操作的中断例程；
（4）其他和硬件系统相关的中断例程。
```

操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。

BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用 int 指令直接调用 BIOS 和 DOS 提供的中断例程，来完成某些工作。

**和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。**



### 5. BIOS和DOS中断例程的安装过程(产生疑问)

前面的课程中，我们都是自己编写中断例程，将它们放到安装程序中，然后运行安装程序，将它们安装到指定的内存区中。此后，别的应用程序才可以调用。

而BIOS和DOS提供的中断例程是如何安装到内存中的呢？我们下面讲解它们的安装过程。

（1）开机后，CPU一加电，初始化 (CS)=0FFFFH，(IP)=0，自动从 FFFF:0 单元开始执行程序。FFFF:0 处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。

> cpu一加电，就初始化 cs:ip，这个初始化是谁进行初始化的？个人感觉，应该还是从ROM中读的。
> [这是一个硬件动作，出厂时就被设定死了，如果cs:ip指向的0xFFFF0处没有正确的程序，计算机就无法正确的启动](https://juejin.cn/post/6844904056733859854)
>
> 为什么cs:ip初始化为 ffff:0 ，而不是 0:0？这些内存中存放了什么？[参考](https://www.cxybb.com/article/wchstrife/78879554)
>
> [浅谈-计算机加电后的启动过程](https://www.codenong.com/cs109510087/)

（2）**初始化程序将建立BIOS所支持的中断向量，即 将BIOS提供的中断例程的入口地址登记在中断向量表中**。注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。

（3）硬件系统检测和初始化完成后，调用 int 19h 进行操作系统的引导。从此将计算机交由操作系统控制。

（4）**DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。**



### 6. BIOS中断例程应用

下面我们举几个例子，来看一下BIOS中断例程的应用。

**int 10h 中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。**

**一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程，都<font color="red">用 ah 来传递内部子程序的编号</font>。**

下面看一下 int 10h 中断例程的设置光标位置功能。

```asm
mov ah,2	; 置光标
mov bh,0	; 第0页
mov dh,5	; dh中放行号
mov dl,12	; dl中放列号
int 10h		; 调用BIOS中断例程 上面的都是此例程的2号子程序的入口参数
```

> **(ah)=2 表示调用第10h号中断例程的2号子程序，功能为设置光标位置**，可以提供光标所在的行号(80\*25字符模式下：0\~24)、列号(80\*25字符模式下：0\~79)，和页号作为参数。
>
> (bh)=0，(dh)=5，(dl)=12，设置光标到第0页，第5行，第12列

bh 中页号的含义：内存地址空间中，B8000H~BFFFFH 共32kB的空间，为80*25彩色字符模式的显示缓冲区。一屏的内容在显示缓冲区中共占 4000 个字节。

显示缓冲区分为8页，每页4KB(≈4000B)，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000H~B8F9FH 中的 4000 个字节的内容将出现在显示器上。



再看一下 int 10h 中断例程的在光标位置显示字符功能。

```asm
mov ah,9	; 在光标位置显示字符
mov al,'a'	; 字符
mov bl,7	; 颜色属性
mov bh,0	; 第0页
mov cx,3	; 字符重复个数
int 10h		; 调用BIOS中断例程 上面的都是此例程的9号子程序的入口参数
```

> **(ah)=9 表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符**，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。

bl 中的颜色属性的格式如下：

```asm
		  7	   6 5 4	3	 2 1 0
含义		BL    R G B    I    R G B
		 闪烁	   背景	 高亮	  前景
```

可以看出，**和显存中的属性字节的格式相同。**

编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的'a'。

```asm
assume cs:code
code segment
	mov ah,2	; 置光标
	mov bh,0	; 第0页
	mov dh,5	; dh中放行号
	mov dl,12	; dl中放列号
	int 10h
	
	mov ah,9			; 在光标位置显示字符
	mov al,'a'			; 字符
	mov bl,11001010b	; 颜色属性 注意，闪烁的效果必须在全屏DOS方式下才能看到
	mov bh,0			; 第0页
	mov cx,3			; 字符重复个数
	int 10h
	
	mov ax,4c00h
	int 21h
code ends
end 
```



### 7. DOS中断例程应用

int 21h 中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。

我们前面一直使用的是 **int 21h 中断例程的4ch号功能，即程序返回功能**，如下：

```asm
mov ah,4ch	; 程序返回
mov al,0	; 返回值
int 21h
```

> (ah)=4ch 表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。

我们看一下 int 21h 中断例程在光标位置显示字符串的功能：

```asm
ds:dx 指向字符串	; 要显示的字符串需用"$"作为结束符
mov ah,9		; 功能号9，表示在光标位置显示字符串
int 21h
```

> (ah)=9 表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。



编程：在屏幕的5行12列显示字符串“Welcome to masm！”。

```asm
assume cs:code
data segment
	db 'Welcome to masm','$'
data ends

code segment
start:	mov ah,2	; 置光标
		mov bh,0	; 第0页
		mov dh,5	; dh中放行号
		mov dl,12	; dl中放列号
		int 10h		; 调用BIOS提供的中断例程 让光标移动到5行12列
		
		mov ax,data
		mov ds,ax
		mov dx,0	; ds:dx 指向字符串的首地址 data:0
		mov ah,9	; 对应显示字符串的子程序的序号
		int 21h		; 调用dos提供的中断例程 让ds:dx指向以'$'结尾的字符串 在光标处输出
		
		mov ax,4c00h
		int 21h
code ends
end start
```

> 上述程序在屏幕的5行12列显示字符串“Welcome to masm！”，直到遇见 '$'（”$“本身并不显示，只起到边界的作用）。
>
> 如果字符串比较长，遇到行尾，程序会自动转到下一行开头处继续显示；如果到了最后一行，还能自动上卷一行。

DOS为程序员提供了许多可以调用的子程序，都包含在 int 21h 中断例程中。我们这里只对原理进行了讲解，对于DOS提供的所有可调用子程序的情况，读者可以参考相关的书籍。







## 第十四章 端口

我们前面讲过，各种存储器都和CPU的地址线、数据线、控制线相连。**CPU在操控它们的时候，把它们都当作内存来对待，把它们总地看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为内存地址空间**（可参见1.15节）。

在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片。
（1）各种接口卡（比如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作；
（2）主板上的接口芯片，CPU通过它们对部分外设进行访问；
（3）其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。

**在这些芯片中，都有一组可以由CPU读写的寄存器**。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同。
（1）都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的；
（2）**CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。**

可见，**从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。**

CPU可以直接读写以下3个地方的数据。

```properties
（1）CPU内部的寄存器
（2）内存单元
（3）端口
```

这一章，我们讨论端口的读写。



### 1. 端口的读写

**在访问端口的时候，CPU通过端口地址来定位端口。<font color="red">因为端口所在的芯片和CPU通过总线相连，所以，端口地址和内存地址一样</font>，通过地址总线来传送。**在PC系统中，CPU最多可以定位 64KB 个不同的端口。则端口地址的范围为0~65535。

对端口的读写不能用 mov、push、pop 等内存读写指令。端口的读写指令只有两条 in 和 out，分别用于从端口读取数据和往端口写入数据。

我们看一下CPU执行内存访问指令和端口访问指令时候，总线上的信息：

#### （1）访问内存：(cpu是怎样执行mov指令的)

```asm
mov ax,ds:[8]	; 假设执行前 (ds)=0
```

执行时与总线相关的操作如下所示。

① CPU通过地址线将地址信息 8 发出；
② CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据；
③ 存储器将 8号单元 中的数据通过数据线送入CPU

#### （2）访问端口：

```asm
in al,60h	; 从 60h 号端口读入一个字节
```

执行时与总线相关的操作如下。

① CPU通过地址线将地址信息 60h 发出；
② CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；
③ 端口所在的芯片将 60h 端口中的数据通过数据线送入CPU。

> 注意，**在 in 和 out 指令中，<font color="red">只能使用 ax 或 al </font>来存放从端口中读入的数据或要发送到端口中的数据。访问 8 位端口时用al，访问16位端口时用ax。**

对 0~255 以内的端口进行读写时：

```asm
in al,20h	; 从20h端口读入一个字节
out 20h,al	; 往20h端口写入一个字节
```

**对 256~65535 的端口进行读写时，端口号放在 dx 中：**

```asm
mov dx,3f8h	; 将端口号 3f8h 送入dx
in al,dx	; 从3f8h端口读入一个字节
out dx,al	; 向3f8h端口写入一个字节
```



### 2. CMOS RAM 芯片

下面的内容中，我们通过对 CMOS RAM的读写来体会一下对端口的访问。

PC机中，有一个 CMOS RAM芯片，一般简称为CMOS。此芯片的特征如下。

（1）包含一个实时钟和一个有128个存储单元的RAM存储器（早期的计算机为64个字节）。

（2）该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。

（3）128个字节的RAM中，内部实时钟占用 0~0dh 单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开杌的时候配置 CMOS RAM中的系统信息。

（4）该芯片内部有两个端口，端口地址为 70h 和 71h。CPU通过这两个端口来读写CMOS RAM。

（5）**70h 为地址端口，存放要访问的 CMOS RAM单元的地址；71h 为数据端口，存放从选定的 CMOS  RAM 单元中读取的数据，或要写入到其中的数据。**
可见，CPU对CMOS RAM的读写分两步进行，比如，读 CMOS  RAM的2号单元：
	① 将 2 送入端口 70h
	② 从端口 71h 读出2号单元的内容

​	

### 3. shl 和 shr 指令

**shl 和 shr 是逻辑移位指令**，后面的课程中我们要用到移位指令，这里进行一下讲解。

shl 是逻辑左移指令，它的功能为：
（1）将一个寄存器或内存单元中的数据向左移位；
（2）将最后移出的一位写入 CF 中；
（3）最低位用 0 补充。

指令：

```asm
mov al,01001000b
shl al,1	; 将al中的数据左移一位
; 执行后 (al)=10010000b，CF=0
```

我们来看一下 shl al,1 的操作过程。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220102122024731.webp" alt="image-20220102122024731" style="zoom:67%;" />

如果接着上面，继续执行一条 shI  al,1，则执行后：(al)=0010000b，CF=1。shl 指令的操作过程如下。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220102122121987.webp" alt="image-20220102122121987" style="zoom:67%;" />

**如果移动位数大于1时，必须将移动位数放在 cl 中。**

比如，指令：

```asm
mov al,01010001b
mov cl,3
shl al,cl
; 执行后 (al)=10001000b，因为最后移出的一位是0，所以CF=0。
```

> 可以看出，将Ⅹ逻辑左移一位，相当于执行Ⅹ=Ⅹ*2

```asm
mov al,00000001b	; 执行后 (al) = 00000001b = 1
shl al,1			; 执行后 (al) = 00000010b = 2
shl al,1			; 执行后 (al) = 00000100b = 4
shl al,1			; 执行后 (al) = 00001000b = 8
mov cl,3			
shl al,cl			; 执行后 (al) = 01000000b = 64
```



shr 是逻辑右移指令，它和shl所进行的操作刚好相反。
（1）将一个寄存器或内存单元中的数据向右移位；
（2）将最后移出的一位写入CF中；
（3）最高位用0补充。

指令：

```asm
mov al,10000001b
shl al,1	; 将al中的数据右移一位
; 执行后 (al)=01000000b，CF=1
```

如果接着上面，继续执行一条 shr al,1，则执行后：(al)=00100000b，CF=0。

**如果移动位数大于1时，必须将移动位数放在cl中**

```asm
mov al,01010001b
mov cl,3
shr al,cl
; 执行后 (al)=00001010b，因为最后移出的一位是0，所以CF=0.
```

> 可以看出，将Ⅹ逻辑右移一位，相当于执行Ⅹ=Ⅹ/2



### 4. CMOS RAM中存储的时间信息

在 CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节，存放单元为：

```properties
秒: 0	分: 2	时: 4	日: 7	月: 8	年: 8	
```

这些数据以BCD码的方式存放。
BCD码是以4位二进制数表示十进制数码的编码方法，如下所示。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220102124252651.webp" alt="image-20220102124252651" style="zoom:80%;" />

> 可见，**一个字节可表示两个BCD码**。则 CMOS  RAM 存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，**高 4 位的BCD码表示十位，低4位的BCD码表示个位**。比如，0001 0100b表示14。



编程，在屏幕中间显示当前的月份。
分析，这个程序主要做以下两部分工作。

（1）从 CMOS RAM的8号单元读出当前月份的BCD码。

**要读取 CMOS RAM的信息，首先要向地址端口70h写入要访问的单元的地址：**

```asm
mov al,8
out 70h,al
```

**然后从数据端口71h中取得指定单元中的数据：**

```asm
in al,71h
```

（2）将用BCD码表示的月份以十进制的形式显示到屏幕上。

我们可以看出，BCD码值 = 十进制数码值，则 BCD码值+30h = 十进制数对应的ASCII码。

从 CMOS  RAM的8号单元读出的一个字节中，包含了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。比如，00010100b表示14。

我们需要进行以下两步工作。
**① 将从 CMOS RAM的8号单元中读出的一个字节，分为两个表示BCD码值的数据。**

```asm
mov ah,al	; al中为从 CMOS RAM 的8号单元中读出的数据
mov cl,4
shr ah,cl	; 向右边移动4位，此时ah中是月份的十位数码值
and al,00001111b	; 取低4位表示BCD码，即此时al中是月份的个位数码值
```

**② 显示 (ah)+30h 和 (al)+30h 对应的ASCII码字符。**



完整的程序如下：

```asm
assume cs:code
code segment
start:	
	; 1.通知cmos cpu要读取8号单元的数据了
	mov al,8
	out 70h,al
	; 2.取出cmos中8号单元的数据到al 是月份
	in al,71h
	
	; 一个月有28-31天，所以是用两位BCD码分别表示十位和个位
	; 所以需要将 al中的十位与个位分离出来
	mov ah,al
	mov cl,4
	shr ah,cl	; 右移4位，从而保留住十位
	and al,00001111b	; and运算，保留住个位
	
	; 由于BCD码直接表示为十进制编码，所以转化为字符，直接+30h就行
	add ah,30h
	add al,30h
	
	; 显示到屏幕
	mov bx,0b800h
	mov es,bx
	mov byte ptr es:[160*12+40*2],ah	; 12行40列位置 显示月份的十位数码
	mov byte ptr es:[160*12+40*2+2],ah	; 显示月份的个位数码
	
	mov 4c00h
	int 21h
code ends
end start
```





## 第十五章 外中断

以前我们讨论的都是CPU对指令的执行。我们知道，CPU在计算机系统中，除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出。也就是说，CPU除了有运算能力外，还要有IO（nput/Output，输入/输出）能力。
比如，我们按下键盘上的一个键，CPU最终要能够处理这个键。在使用文本编辑器时，按下a键后，我们可以看到屏幕上岀现“a”，是CPU将从键盘上输入的键所对应的字符送到显示器上的。

要及时处理外设的输入，显然需要解决两个问题：①外设的输入随时可能发生，CPU如何得知？②CPU从何处得到外设的输入？

这一章中，我们以键盘输入为例，讨论这两个问题。

### 1. 接口芯片和端口

第14章我们讲过，PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问。

**外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。**CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。

可见，**CPU通过端口和外部设备进行联系。**



### 2. 外中断信息

现在，我们知道了外设的输入被存放在端口中，可是外设的输入随时都有可能到达，CPU如何及时地知道，并进行处理呢？更一般地讲，就是**外设随时都可能发生需要CPU及时处理的事件，CPU如何及时得知并进行处理？**

CPU提供中断机制来满足这种需要。前面讲过，当CPU的内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自CPU的内部。

还有一种中断信息，来自于CPU外部，当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。

在PC系统中，外中断源一共有以下两类。

#### 1. 可屏蔽中断

**可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的 IF 位的设置。**
**当CPU检测到可屏蔽中断信息时，如果 IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应可屏蔽中断。**

我们回忆一下内中断所引发的中断过程：

```properties
（1）取中断类型码n；
（2）标志寄存器入栈，IF=0，TF=0；
（3）CS、IP入栈；
（4）(IP)=(n*4)，(CS)=(n*4+2)
由此转去执行中断处理程序。
```

可屏蔽中断所引发的中断过程，除在第1步的实现上有所不同外，基本上和内中断的中断过程相同。因为**可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；**而内中断的中断类型码是在CPU内部产生的。

现在，我们可以解释中断过程中将 IF 置为0的原因了。**将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。**

当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。8086CPU提供的设置IF的指令如下：

```asm
sti, 设置IF=1
cli, 设置IF=0
```



#### 2. 不可屏蔽中断

**不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。**

**对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。**则不可屏蔽中断的中断过程为：

```asm
（1）标志寄存器入栈，IF=0，TF=0；
（2）CS、IP入栈；
（3）(IP)=(8)，(CS)=(0AH)
```



**几乎所有由外设引发的外中断，都是可屏蔽中断。**当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。
**不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。**在我们的课程中，主要讨论可屏蔽中断。



### 3. PC机键盘的处理过程

下面我们看一下键盘输入的处理过程，并以此来体会一下PC机处理外设输入的基本方法。

#### 1. 键盘输入

键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。

按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，**该寄存器的端口地址为60h。**

松开按下的键时，也产生—个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中。

**一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。扫描码长度为一个字节，通码的第7位为0，断码的第7位为1**，即：
**断码 = 通码 + 80h**

比如，g键的通码为 22h，断码为 a2h。

表15.1是键盘上部分键的扫描码，只列出通码。断码=通码+80h。

![image-20220102154624836](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220102154624836.webp)



#### 2. 引发9号中断

键盘的输入到达 60h 端口时，相关的芯片就会向CPU发出中断类型码为 9 的可屏蔽中断信息。CPU检测到该中断信息后，如果 IF=1，则响应中断，引发中断过程，转去执行 int 9 中断例程。



#### 3. 执行int 9中断例程

BIOS提供了 int 9 中断例程，用来进行基本的键盘输入处理，主要的工作如下：

（1）读出 60h 端口中的扫描码；

（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送入内存中的 BIOS 键盘缓冲区；
如果是控制键（比如 Ctrl）和切换键（比如  CapsLock）的扫描码，则将其转变为状态字节（用二进制位记录控制键和切换键状态的字节）写入内存中存储状态字节的单元；

（3）对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。

BIOS 键盘缓冲区是系统启动后，BIOS用于存放 int 9 中断例程所接收的键盘输入的内存区。该内存区可以存储15个键盘输入，因为 int 9 中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，**所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。**

0040:17 单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下。

```properties
0: 右shift状态，置 1 表示按下 右shift键；
l: 左shift状态，置 1 表示按下 左shif键；
2: Ctrl状态，置 1 表示按下Ctrl键；
3: Alt状态，置 1 表示按下Alt键
4: Scrolllock状态，置 1 表示Scroll指示灯亮；
5: NumLock状态，置 1 表示小键盘输入的是数字
6: CapsLock状态，置 1 表示输入大写字母；
7: Insert状态，置 1 表示处于删除态。 
```



### 4. 编写 int 9 中断例程

从上面的内容中，可以看出**键盘输入的处理过程：①键盘产生扫描码；②扫描码送入60h端口；③引发9号中断；④CPU执行 int 9 中断例程处理键盘输入。**

上面的过程中，第1、2、3步都是由硬件系统完成的。我们能够改变的只有 int 9 中断处理程序。我们可以重新编写 int 9 中断例程，按照自己的意图来处理键盘的输入。但是，在课程中，我们不准备完整地编写一个键盘中断的处理程序，因为要涉及一些硬件细节，而这些内容脱离了我们的内容主线。

但是，我们却还要编写新的键盘中断处理程序，来进行一些特殊的工作，那么这些硬件细节如何处理呢？这点比较简单，因为BIOS提供的 int 9 中断例程已经对这些硬件细节进行了处理。我们只要在自己编写的中断例程中调用BIOS的 int 9 中断例程就可以了。



编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下 Esc 键后，改变显示的颜色。

我们先来看一下如何依次显示“a”~“z”

```asm
assume cs:code
code segment
start:	mov ax,0b800h
		mov es,ax
		mov ah,'a'	; 将ah赋值为 'a'
	s:	mov es:[160*12+40*2],ah	; 将ah写入显存，即在屏幕上显示
		inc ah		; 让a的ASCII++ 即输出下一个字符
		cmp ah,'z'	; 判断ah是否等于z
		jna s		; 不大于z(即ah<=z) 跳到s
		mov ax,4c00h
		int 21h
code ends
end start
```

在上面的程序的执行过程中，我们无法看清屏幕上的显示。因为一个字母刚显示到屏幕上，CPU执行几条指令后，就又变成了另一个字母，字母之间切换得太快，无法看清。

应该在每显示一个字母后，延时一段时间，让人看清后，再显示下一个字母。**那么如何延时呢？我们让CPU执行一段时间的空循环。**因为现在CPU的速度都非常快，所以循环的次数一定要大，用两个16位寄存器来存放32位的循环次数。如下：

```asm
    mov dx,10h
    mov ax,0	; 相当于是把dx当成32位的高16位，ax当成低16位，即：100000h
s:  sub ax,1	; ax-1
    sbb dx,0	; dx带位减0，也就是说 相当于逻辑上的低位ax向高位dx借1位进行减法操作
    cmp ax,0	
    jne s		; 如果ax!=0，跳到s
    cmp dx,0
    jne s		; 如果dx!=0, 跳到s
```

上面的程序，循环100000h次。我们可以将循环延时的程序段写为一个子程序。

现在，我们的程序如下：

```asm
assume cs:code
stack segment
	db 128 dup (0)
stack ends

code segment
start:	mov ax,stack
		mov ss,ax
		mov sp,128	; 栈
		
		mov ax,0b800h
		mov es,ax
		mov ah,'a'	; 将字符存入ah
	s:	mov es:[160*12+40*2],ah	; 将ah的内容输出到屏幕
		call delay	; 进行空循环，让我们可以看见 a-z的展示效果
		inc ah
		cmp ah,'z'
		jna s
		
		mov ax,4c00h
		int 21h
		
delay:	push ax
		push dx
		mov dx,1000h
		mov ax,0	; 循环1000 0000h次，可自由调整循环次数
	s1:	sub ax,1
		sbb dx,0
		cmp ax,0
		jne s1
		cmp dx,0
		jne s1
		
		pop dx
		pop ax
		ret
code ends
end start
```

显示“a”~“z”，并可以让人看清，这个任务已经实现。那么如何实现，按下Esc 键后，改变显示的颜色呢？

键盘输入到达60h端口后，就会引发9号中断，CPU则转去执行 int 9 中断例程。我们可以编写 int 9 中断例程，功能如下。

（1）从60h端口读出键盘的输入；

（2）调用BIOS的 int 9 中断例程，处理其他硬件细节；

（3）判断是否为 Esc 的扫描码，如果是，改变显示的颜色后返回；如果不是则直接返回。

下面对这些功能的实现一一进行分析

#### 1. 从端口 60h 读出键盘的输入

```asm
in al,60h 
```

#### 2. 调用BIOS的 int 9中断例程

有一点要注意的是，我们写的中断处理程序要成为新的 int 9 中断例程，**主程序必须要将中断向量表中的 int 9 中断例程的入口地址改为我们写的中断处理程序的入口地址。**

**则在新的中断处理程序中调用原来的 int 9 中断例程时**，中断向量表中的 int 9 中断例程的入口地址却不是原来的 int 9 中断例程的地址。所以**不能使用int指令直接调用。**

要能在我们写的新中断例程中调用原来的中断例程，就必须在将中断向量表中的中断例程的入口地址改为新地址之前，将原来的入口地址保存起来。这样，在需要调用的时候，我们才能找到原来的中断例程的入口。

对于我们现在的问题，假设将原来 int 9 中断例程的偏移地址和段地址保存在 ds:[0] 和 ds:[2] 单元中。那么我们在需要调用原来的 int 9 中断例程时候，就可以在 ds[0]、ds:[2] 单元中找到它的入口地址。



那么，有了入口地址后，如何进行调用呢？
当然不能使用指令 int 9 来调用。我们可以用别的指令来对 int 指令进行一些模拟，从而实现对中断例程的调用。

我们来看，int指令在执行的时候，CPU进行下面的工作。

```properties
（1）取中断类型码n；
（2）标志寄存器入栈；
（3）IF=0，TF=0：
（4）CS、IP入栈；
（5）(IP)=(n*4），(CS)=(n*4+2)。
```

取中断类型码是为了定位中断例程的入口地址，在我们的问题中，中断例程的入口地址已经知道。所以，我们用别的指令模拟 int 指令时候，不需要做第(1)步。在假设要调用的中断例程的入口地址在 ds:0 和 ds:2 单元中的前提下，我们将 int 过程用下面几步模拟。

```properties
（1）标志寄存器入栈；
（2）IF=0，TF=0：
（3）CS、IP入栈；
（4）(IP)=((ds)*16+0)，(CS)=((ds)*16+2)。
```

可以注意到第(3)、(4)步和 call dword ptr ds:[0] 的功能一样，call dword ptr  ds:[0] 的功能也是：

```asm
CS、IP入栈；
(IP)=((ds)*16+0），(CS)=((ds)*16+2)。
; 如果不记得了，复习10.6节的内容
```

所以 int 过程的模拟过程变为：

```properties
（1）标志寄存器入栈；
（2）IF=0，TF=0：
（3）call dword ptr ds:[0]
```

对于(1)，可用 pushf 实现；对于(2)，可用下面的指令实现：

```asm
pushf
pop ax
and ah,11111100b	; IF和TF为标志寄存器的第9位和第8位
push ax
popf
```

**则模拟 int 指令的调用功能，调用入口地址在 ds:0、ds:2 中的中断例程的程序**为：

```asm
pushf	; 标志寄存器入栈

pushf
pop ax
and ah,11111100b
push ax
popf	; IF=0,TF=0

call dword ptr ds:[0]	; CS、IP入栈 (IP)=((ds)*16+0),(CS)=((ds)*16+2)
```



#### 3. 如果是Esc的扫描码，改变显示的颜色后返回

如何改变显示的颜色？

显示的位置是屏幕的中间，即第12行40列，显存中的偏移地址为：160\*12+40\*2。所以字符的ASCII码要送入段地址 b800h，偏移地址160\*12+40\*2处。
而段地址 b800h，偏移地址 160\*12+40\*2+1 处是字符的属性，只要改变此处的数据就可以改变在段地址b800h，偏移地址 160\*12+40\*2 处显示的字符的颜色了。

该程序的最后一个问题是，**要在程序返回前，将中断向量表中的 int 9 中断例程的入口地址恢复为原来的地址。否则程序返回后，别的程序将无法使用键盘。**



经过分析，完整的程序如下：

```asm
assume cs:code
stack segment
	db 128 dup (0)
stack ends

data segment
	dw 0,0
data ends

code segment
start:	; 初始化ss:sp指向栈
		mov ax,stack
		mov ss,ax
		mov sp,128
		; 初始化ds指向data
		mov ax,data
		mov ds,ax
		; 初始化es指向目标空间 0
		mov ax,0
		mov es,ax
		; 1.将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中
		push es:[9*4]	; 9号中断例程的偏移地址
		pop ds:[0]
		push es:[9*4+2]	; 9号中断例程的段地址
		pop ds:[2]
		; 2.在中断向量表中设置新的 int 9 中断例程的入口地址(就是我们自定义的int 9)
		mov word ptr es:[9*4],offset int9
		mov es:[9*4+2],cs
		; 3.题目要求：依次输出a-z
		mov ax,0b800h
		mov es,ax
		mov ah,'a'
	s:	mov es:[160*12+40*2],ah
		call delay	; 空循环程序，让我们人眼可以看到a-z慢慢的变化
		inc ah
		cmp ah,'z'
		jna s
		; 4.将中断向量表中 int 9 中断例程的入口恢复为原来的地址
		mov ax,0
		mov es,ax	; es重新指向目标空间 0
		push ds:[0]		; data段中存的是原来int 9的CS:IP
		pop es:[9*4]	; 将原int 9的入口地址重新设置回去，以便可以被其他程序调用
		push ds:[2]
		pop es:[9*4+2]
		; 5.退出程序
		mov ax,4c00h
		int 21h
		
		; 3.1 空循环，让CPU延时
delay:	push ax
		push dx
		mov dx,100h	; 100 0000h次循环
		mov ax,0
	s1:	sub ax,1
		sbb dx,0
		cmp ax,0
		jne s1		; jne是不等于的意思
		cmp dx,0
		jne s1
		pop dx
		pop ax
		ret
		
; --------------以下为新的 int 9 中断例程---------------
int9:	push ax
		push bx
		push es
		
		in al,60h	; 拿到从键盘输入的扫描码
		; 对int指令进行模拟，调用原来的 int 9 中断例程
		; pushf:将标志寄存器的值压栈，popf:从栈中弹出数据，送入标志寄存器中
		pushf	; ①标志寄存器入栈
		; ②IF、TF=0
		pushf
		pop bx
		and bh,11111100b	; IF与TF分别处于第9位和第8位
		push bx
		popf
		call dword ptr ds:[0]	; ③CS、IP入栈 (IP)=((ds)*16+0),(CS)=((ds)*16+2)
		
		cmp al,1		; 1是ESC的扫描码
		jne int9ret
		; 下面是按了ESC之后的处理程序
		mov ax,0b800h
		mov es,ax
		inc byte ptr es:[160*12+40*2+1]	; 改变12行40列字符的颜色，由于显存一字符占2字节，[0]是ASCII码,[1]是颜色属性，将字符的属性值+1，改变颜色
		
int9ret:pop es
		pop bx
		pop ax
		iret
code ends
end start
```

> 注意，本章中所有关于键盘的程序，因要直接访问真实的硬件，则必须在DOS实模式下运行。在  Windows 2000 的DOS方式下运行，会出现一些和硬件工作原理不符合的现象。

当按下键盘的键位，CPU会调用int 9.所以只要int 9的入口地址改成我们自定义的，就行了，我们自定义的int 9就会被自动调用。
且CPU调用int 9时，这些初始化都已经由硬件自动完成了。改进程序看[汇编练习题15.1](D:\xuan\带上它,便带上整个故事\typora\编程笔记\后端\编程的内功\3. 汇编\汇编练习题.md)



### 5. 安装新的 int 9 中断例程

下面，我们安装一个新的 int 9 中断例程，使得原 int 9 中断例程的功能得到扩展。

任务：安装一个新的 int 9 中断例程。
功能：在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理。

我们进行一下分析。

#### （1）改变屏幕的显示颜色

**改变从 B8000H 开始的 4000 个字节中的所有奇地址单元中的内容，当前屏幕的显示颜色即发生改变。**程序如下：

```asm
	mov ax,0b800h
	mov es,ax	; es指向显存
	mov bx,1	; bx指向奇地址(字符颜色属性)
	mov cx,2000
s:	inc byte ptr es:[bx]	; 对每个字符的颜色属性+1 从而实现改变颜色的效果
	add bx,2
	loop s
```

#### （2）其他键照常处理

可以调用原 int 9 中断处理程序，来处理其他的键盘输入。

#### （3）原 int 9 中断例程入口地址的保存

因为在编写的新 int 9 中断例程中要调用原 int 9 中断例程，所以，要保存原 int 9 中断例程的入口地址。保存在哪里？显然不能保存在安装程序中，因为安装程序返冋后地址将丢失。我们将地址保存在0:200单元处。

#### （4）新 int 9 中断例程的安装

这个问题在前面已经详细讨论过。我们可将新的 int 9 中断例程安装在 0:204 处。

```asm
assume cs:code
stack segment
	db 128 dup (0)
stack ends

code segment
start:	mov ax,stack
		mov ss,ax
		mov sp,128		; 指向栈顶
		
		push cs
		pop ds		; 将cs赋值给ds 相当于 mov ds,cs(虽然不准这么用，不过描述一下)
		
		mov ax,0
		mov es,ax	; es指向目标
		; 将自定义的int9传送到安全空间
		mov si,offset int9	; 设置ds:si指向源地址
		mov di,204h			; 设置es:di指向目的地址
		mov cx,offset int9end - offset int9	; 设置cx为传输长度
		cld					; 设置传输方向为正
		rep movsb			; 开始传送
		; 将原来的int 9中断例程的入口地址，保存到 0:200-202中
		push es:[9*4]
		pop es:[200h]
		push es:[9*4+2]
		pop es:[202h]
		; 如果此刻来了个中断，那么很有可能会导致入口地址的写入不成功。从而下次int 9指向错误的地方，所以将自定义入口写到向量表时，需要屏蔽中断信号
		cli	; 设置IF＝0屏蔽中断
		mov word ptr es:[9*4],204h
		mov word ptr es:[9*4+2],0
		sti	; 设置IF＝1取消屏蔽
		
		mov ax,4c00h
		int 21h
; 自定义 int 9	
int9:	push ax
		push bx
		push cx
		push es
		
		in al,60h	; 从键盘按键中读取到扫描码
		
		pushf	; 标志位入栈
		call dword ptr cs:[200h]	; 当此中断例程执行时(CS)=0
									; cs、IP入栈，
		
		cmp al,3bh		; F1 的扫描码为3bh
		jne int9ret		; 不相等进入int9ret
		; 变换背景色
		mov ax,0b800h
		mov es,ax
		mov bx,1
		mov cx,2000
	s:	inc byte ptr es:[bx]
		add bx,2
		loop s
		
int9ret:pop es
		pop cx
		pop bx
		pop ax
		iret
		
int9end:nop
code ends
end start
```

这一章中，我们通过对键盘输入的处理，讲解了CPU对外设输入的通常处理方法，即：

（1）外设的输入送入端口；
（2）向CPU发出外中断（可屏蔽中断）信息；
（3）CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，执行相应的中断例程；
（4）可在中断例程中实现对外设输入的处理。

**端口和中断机制，是CPU进行 I/O 的基础**



### 6. 指令系统总结

若要详细了解8086指令系统中的各个指令的用法，可以查看有关的指令手册。
8086CPU提供以下几大类指令

#### 1. 数据传送指令

比如，mov、push、pop、pushf、popf、xchg 等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。

#### 2. 算术运算指令

比如，add、sub、adc、sbb、inc、dec、cmp、imul、idⅳ、aaa 等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的 sf、zf、of、cf、pf、af位。

#### 3. 逻辑指令

比如，and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 等都是逻辑指令。除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。

#### 4. 转移指令

可以修改 IP，或同时修改CS和IP的指令统称为转移指令。转移指令分为以下几类。

（1）无条件转移指令，比如，jmp
（2）条件转移指令，比如，jcxz、je、jb、ja、jnb、jna 等；
（3）循环指令，比如，loop
（4）过程，比如，call、ret、retf；
（5）中断，比如，int、iret

#### 5. 处理机控制指令

这些指令对标志寄存器或其他处理机状态进行设置，比如，cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock 等都是处理机控制指令。

#### 6. 串处理指令

这些指令对内存中的批量数据进行处理，比如，movsb、movsw、cmps、scas、lods、stos 等。若要使用这些指令方便地进行批量数据的处理，则需要和 rep、repe、repne 等前缀指令配合使用。







## 第十六章 直接定址表

这一章，我们讨论如何有效合理地组织数据，以及相关的编程技术。

### 1. 描述了单元长度的标号

前面的课程中，我们一直在代码段中使用标号来标记指令、数据、段的起始地址。比如，下面的程序将 code 段中的 a 标号处的8个数据累加，结果存储到 b 标号处的字中。

```asm
assume cs:code
code segment
	a: db 1,2,3,4,5,6,7,8
	b: dw 0
	
start:	mov si,offset a	; si定位到标号a的地址
		mov bx,offset b	; bx定位到标号b的地址
		mov cx,8
	s:	mov al,cs:[si]	
		mov ah,0		; 将标号a中的数据存入ax
		add cs:[bx],ax	; 将ax累加到标号b
		inc si
		loop s
		
		mov ax,4c00h
		int 21h
code ends
end start
```

程序中，code、a、b、start、s都是标号。**这些标号仅仅表示了内存单元的地址。**

但是，我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。

上面的程序还可以写成这样：

```asm
assume cs:code
code segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	
start:	mov si,0	; si定位到标号a(cs:0)的地址
		mov cx,8
	s:	mov al,a[si]		
		mov ah,0		; 将a中的数据存入ax
		add b,ax	; 将ax累加到b
		inc si
		loop s
		
		mov ax,4c00h
		int 21h
code ends
end start
```

在code段中使用的**标号a、b后面没有 ":"，它们是同时描述内存地址和单元长度的标号。**标号a，描述了地址 code:0，和从这个地址开始，以后的内存单元都是字节单元；而标号 b 描述了地址 code:8，和从这个地址开始，以后的内存单元都是字单元。

因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。比如，对于程序中的”b dw 0“：

```properties
指令:	mov ax,b
相当于:mov ax,cs:[8]

指令:	mov b,2
相当于:mov word ptr cs:[8],2

指令:	inc b
相当于:inc word ptr cs:[8]
```

在这些指令中，标号b代表了一个内存单元，地址为 code:8，长度为两个字节。

下面的指令会引起编译错误：

```asm
mov al,b ; 因为b代表的内存单元是字单元，而al是8位寄存器。
```

如果我们将程序中的指令“add b,ax”，写为“add b,al”，将岀现同样的编译错误。

```properties
; 对于程序中的“a db 1,2,3,4,5,6,7,8”
指令:	mov al,a[si]
相当于:mov al,cs:0[si]

指令:	mov al,a[3]
相当于:mov al,cs:0[3]

指令:	mov al,a[bx+si+3]
相当于:mov al,cs:0[bx+si+3]
```

可见，使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。以后，我们将这种标号称为**数据标号，它标记了存储数据的单元的地址和长度**。它不同于仅仅表示地址的地址标号。



### 2. 在其他段中使用数据标号

一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中。在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。

**注意，在后面加有 “:” 的地址标号，只能在代码段中使用，不能在其他段中使用。**

下面的程序将 data 段中 a 标号处的8个数据累加，结果存储到 b 标号处的字中。

```asm
assume cs:code,ds:data
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
data ends

code segment
start:	mov ax,data
		mov ds,ax

		mov si,0	; si定位到标号a(cs:0)的地址
		mov cx,8
	s:	mov al,a[si]		
		mov ah,0		; 将a中的数据存入ax
		add b,ax	; 将ax累加到b
		inc si
		loop s
		
		mov ax,4c00h
		int 21h
code ends
end start
```

**注意，如果想在代码段中直接用数据标号访问数据，则需要用伪指令 assume 将标号所在的段和一个段寄存器联系起来。**否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。

当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，用 assume 指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。我们在程序中还要使用指令对段寄存器进行设置。

> 即，使用 assume 与段寄存器相关联，还是得设置指向对应得段空间

比如，在上面的程序中，**我们要在代码段 code 中用 data 段中的数据标号 a、b访问数据，则必须用  assume 将一个寄存器和data段相联。**在程序中，我们用ds寄存器和data段相联，则编译器对相关指令的编译如下。

```properties
指令:	mov al,a[si]
编译为:mov al,[si+0]

指令:	add b,ax
编译为:add [8],ax
```

因为这些实际编译出的指令，都默认所访问单元的段地址在ds中，而实际要访问的段为data，所以若要访问正确，在这些指令执行前，ds中必须为data段的段地址。则我们在程序中使用指令:

```asm
mov ax,data
mov ds,ax	; 设置 ds指向data段
```



可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。
比如：

```asm
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	c dw a,b
data ends
```

数据标号 c 处存储的两个字型数据为标号a、b的偏移地址。相当于

```asm
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	c dw offset a,offset b
data ends
```

再比如：

```asm
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	c dd a,b
data ends
```

数据标号c处存储的两个双字型数据为标号 a 的偏移地址和段地址、标号 b 的偏移地址和段地址。相当于：

```asm
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	c dw offset a, seg a, offset b, seg b
data ends
```

**seg 操作符，功能为取得某一标号的段地址。offset 取偏移地址**



### 3. 直接定址表

现在，我们讨论用查表的方法编写相关程序的技巧。

编写子程序，以十六进制的形式在屏幕中间显示给定的字节型数据。

分析：一个字节需要用两个十六进制数码来表示，所以，子程序需要在屏幕上显示两个ASCII字符。我们当然要用 “0”、“1”、“2”、“3”、“4”、“5”、“6”、“7”、“8“、”9“、”A”、“B”、“C”、“D”、“E”、“F”这16个字符来显示十六进制数码。

我们可以将一个字节的高4位和低4位分开，分别用它们的值得到对应的数码字符(BCD)。比如2Bh，可以得到高4位的值为2，低4位的值为11，**那么如何用这两个数值得到对应的数码字符“2”和“B”呢？**

最简单的办法就是一个一个地比较，如下：

```asm
如果数值为0，则显示“0”
......
如果数值为11，则显示“B”
......
```

我们可以看出，

显然，这样做，程序是比较混乱的。我们希望能够在 数值0\~15和字符“0”\~“F” 之间找到一种映射关系。这样用0\~15间的任何数值，都可以通过这种映射关系直接得到“0”\~“F”中对应的字符。

数值0\~9和字符“0”~“9”之间的映射关系是很明显的，即：**数值+30h=对应字符的ASCII值**
但是，10\~15和“A”~“F”之间的映射关系是：**数值+37h=对应字符的ASCII值**

因为数值0\~15和字符“0”~“F”之间没有一致的映射关系存在，所以，我们应该在它们之间建立新的映射关系。

**具体的做法是，建立一张表，表中依次存储字符“0”\~“F”，我们可以通过数值0~15直接查找到对应的字符。**
子程序如下：

```asm
; 用al传送要显示的数据
showbyte:jmp short show
		table db '0123456789ABCDEF'	; 字符表
		
		push bx
		push es
		
		mov ah,al
		shr ah,1
		shr ah,1
		shr ah,1
		shr ah,1	; 右移4位，ah中得到高4位
		and al,00001111b	; al中为低4位的值
		
		mov bl,ah
		mov bh,0
		mov ah,table[bx]	; 用高4位的值作为相对于table的偏移，取得对应的字符
		
		mov bx,0b800h
		mov es,bx
		mov es:[160*12+4*2],ah	; 将ah中的字符显示到屏幕
		
		mov bl,al
		mov bh,0
		mov al,table[bx]	; 用低4位的值作为相对于table的偏移，取得对应的字符
		
		mov es:[160*12+40*2+2],al	; 将al中的字符显示到屏幕
		
		pop es
		pop bx
		ret
```

可以看出，在子程序中，我们在数值0\~15和字符“0”~“F”之间建立的映射关系为：**以数值N为 table表中的偏移，可以找到对应的字符。**

利用表，在两个数据集合之间建立一种映射关系，使我们可以用查表的方法根据给出的数据得到其在另一集合中的对应数据。这样做的目的一般来说有以下3个。
（1）为了算法的清晰和简洁；
（2）为了加快运算速度；
（3）为了使程序易于扩充。



在上面的子程序中，我们更多的是为了算法的清晰和简洁，而采用了查表的方法。下面我们来看一下，**为了加快运算速度而采用查表的方法的情况。**

编写一个子程序，计算sin(x)，x∈{0°，30°，60°，90°，120°，150°，180°}，并在屏幕中间显示计算结果。比如 sin(30) 的结果显示为“0.5”。

我们可以利用麦克劳林公式来计算 sin(x)。x为角度，麦克劳林公式中需要代入弧度，则：
$$
sin(x)=sin(y)≈y- \frac{1}{3!} y^3 + \frac{1}{5!}y^5
\qquad y = \frac{x}{180}*3.1415926
$$
可以看岀，计算 sin(x) 需要进行多次乘法和除法。乘除是非常费时的运算，它们的执行时间大约是加法、比较等指令的5倍。如何才能够不做乘除而计算 sin(x) 呢？我们看下需要计算的 sin(x) 的结果：

```properties
sin(0)=0
sin(30)=0.5
sin(60)=0.866
sin(90)=1
sin(120)=0.866
sin(150)=0.5
sin(180)=0
```

我们可以看出，其实用不着计算，可以占用一些内存空间来换取运算的速度。将所要计算的 sin(x) 的结果都存储到一张表中；然后用角度值来查表，找到对应的 sin(x) 的值。
用 ax 向子程序传递角度，程序如下：

```asm
showsin:jmp short show

    table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180	; 字符串偏移地址表
    ag0	  db '0',0		; sin(0)对应的字符串“0”
    ag30  db '0.5',0    ; sin(30)对应的字符串“0.5”
    ag60  db '0.866',0  ; sin(60)对应的字符串“0.866”
    ag90  db '1',0    	; sin(90)对应的字符串“1”
    ag120 db '0.866',0  ; sin(120)对应的字符串“0.866”
    ag150 db '0.5',0    ; sin(150)对应的字符串“0.5”
    ag180 db '0',0    	; sin(180)对应的字符串“0”
show:	push bx
		push es
		push si
		mov bx,0b800h
		mov es,bx		; es指向显存
; 以下用角度值/30 作为相对于table的偏移，取得对应的字符串的偏移地址，放在bx中
		mov ah,0		; ax存的是角度
		mov bl,30
		div bl
		mov bl,al
		mov bh,0
		mov bx,table[bx]
; 以下显示 sin(x)对应的字符串
		mov si,160*12+40*2
shows:	mov ah,cs:[bx]
		cmp ah,0
		je showret
		mov es:[si],ah
		inc bx
		add si,2
		jmp short shows
		
showret:pop si
		pop es
		pop bx
		ret
```

在上面的子程序中，我们在角度值 X 和表示 sin(x) 的字符串集合 table 之间建立的映射关系为：**以角度值/30为table表中的偏移，可以找到对应的字符串的首地址。**



**编程的时候要注意程序的容错性，即对于错误的输入要有处理能力。**在上面的子程序中，我们还应该再加上对提供的角度值是否超范围的检测。如果提供的角度值不在合法的集合中，程序将定位不到正确的字符串，岀现错误。对于角度值的检测，请读者自行完成。

上面的两个子程序中，我们将通过给出的数据进行计算或比较而得到结果的问题，转化为用给出的数据作为查表的依据，通过查表得到结果的问题。具体的查表方法，是用查表的依据数据，直接计算出所要査找的元素在表中的位置。像这种**可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为直接定址表。**



### 4. 程序入口地址的直接定址表(真屌)

**我们可以在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。**我们看下面的问题。

实现一个子程序 setscreen，为显示输出提供如下功能。
（1）清屏
（2）设置前景色
（3）设置背景色
（4）向上滚动一行。

入口参数说明如下。
（1）用 ah 寄存器传递功能号：0表示清屏，1表示设置前景色，2表示设置背景色，3表示向上滚动一行；
（2）对于1、2号功能，用 al 传送颜色值，(al)∈{0,1,2,3,4,5,6,7}。

下面我们讨论一下各种功能如何实现。
（1）清屏：将显存中当前屏幕中的字符设为空格符；
（2）设置前景色：设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位；
（3）设置背景色：设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位；
（4）向上滚动一行：依次将第n+1行的内容复制到第n行处；最后一行为空。

我们将这4个功能分别写为4个子程序，请读者根据编程思想，自行读懂下面的程序。

```asm
; sub1: 清屏功能
sub1:	push bx
		push cx
		push es		; 保护现场
		mov bx,0b800h
		mov es,bx	; 指向显存
		mov bx,0
		mov cx,2000
sub1s:	mov byte ptr es:[bx],' '	; 将显存中每个字节设置为' '
		add bx,2
		loop sub1s
		; 恢复现场并返回
		pop es
		pop cx
		pop bx
		ret
		
; sub2:	设置前景色
sub2:	push bx
		push cx
		push es		; 保护现场
		mov bx,0b800h
		mov es,bx	; 指向显存
		mov bx,1	; 指向显存中的奇地址,即 字符的属性 当修改字符的属性后 其颜色发生改变
		mov cx,2000
sub2s:	and byte ptr es:[bx],11111000b	;将奇地址的低3位置0 初始化低3位 高位不变
		or es:[bx],al	; 然后设置为用户指定的颜色,这里的al代表要修改成的颜色,al=1-7,所以只是修改了低3位的值
		add bx,2
		loop sub2s
		; 恢复现场并返回
		pop es
		pop cx
		pop bx
		ret
		
; sub3:	设置背景色
sub3:	push bx
		push cx
		push es		; 保护现场
		mov cl,4	; 设置移位次数
		shl al,cl	; 将al左移4次,这里的al是指定要修改的颜色,因al=1-7(低3位),左移4位后移动到了高位，就可以改变高3位的值，从而改变背景色
		mov bx,0b800h
		mov es,bx	; 指向显存
		mov bx,1	; 指向显存中的奇地址,即 字符的属性 当修改字符的属性后 其颜色发生改变
		mov cx,2000
sub3s:	and byte ptr es:[bx],10001111b	; 初始化 567位 其他位不变
		or es:[bx],al	; 将567位设置为用户指定颜色
		add bx,2
		loop sub3s
		; 恢复现场并返回
		pop es
		pop cx
		pop bx
		ret
		
; sub4:	向上滚动一行，所有代码向上滚动
sub4:	push cx
		push si
		push di
		push es
		push ds		; 保护现场
		; 需要向上滚动一行，就需要将n+1行的所有字符，复制到第n行
		mov si,0b800h
		mov es,si	; es:di是目标地址 即屏幕第n行
		mov ds,si	; ds:si是源地址 即屏幕第n+1行
		mov si,160	; ds:si指向es:di的下一行(一行80字符,一字符2字节)
		mov di,0
		cld			; 递增拷贝
		mov cx,24	; 一屏有25行 因为是所有行向上滚动一行，则最后一行直接清空就行 代表行循环
		
sub4s:	push cx
		mov cx,160	; 一行有80列，一列2字节，代表列循环
		rep movsb	; 开始拷贝,ds:si -> es:di 中 下一行复制到上一行
		pop cx		; 开始下一次行循环
		loop sub4s
		; 最后一行清空
		mov cx,80	; 因为字符才会显示，所以只需要清除偶地址就行(偶地址代表字符 奇地址只是属性)
		mov si,0
sub4s1:	mov byte ptr [160*24+si],' '	; 最后一行清空
		add si,2
		loop sub4s1
		; 恢复现场并返回
		pop ds
		pop es
		pop di
		pop si
		pop cx
		ret
```

**我们可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。**对应关系为：**功能号*2 = 对应的功能子程序在地址表中的偏移**。程序如下：

```asm
setscreen:	jmp short set
	table dw sub1,sub2,sub3,sub4
	set:	push bx
			cmp ah,3	; 判断功能号是否大于3
			ja sret		; 大于3直接返回
			mov bl,ah
			mov bh,0
			add bx,bx	; 根据ah中的功能号计算对应子程序在table表中的偏移
			
			call word ptr table[bx]	; 调用对应功能的子程序
	sret:	pop bx
			ret
```

当然，我们也可以将子程序 setscreen 如下实现。

```asm
setscreen:	cmp ah,0
			je do1
			cmp ah,1
			je do2
			cmp ah,2
			je do3
			cmp ah,3
			je do4
			jmp short sret
			
	do1:	call sub1
			jmp short sret
	do2:	call sub2
			jmp short sret
	do3:	call sub3
			jmp short sret
	do4:	call sub4

	sret:	ret
```

显然，用通过比较功能号进行转移的方法，程序结构比较混乱，不利于功能的扩充。比如说，在 setscreen 中再加入一个功能，则需要修改程序的逻辑，加入新的比较、转移指令。

用根据功能号査找地址表的方法，程序的结构清晰，便于扩充。如果加入一个新的功能子程序，那么只需要在地址表中加入它的入口地址就可以了。







## 第十七章 使用BIOS进行键盘输入和磁盘读写

大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入。程序和数据通常需要长期存储，磁盘是最常用的存储设备。BIOS为这两种外设的 I/O 提供了最基本的中断例程，在本章中，我们对它们的应用和相关的问题进行讨论

### 1. int 9 中断例程对键盘输入的处理

我们已经讲过，**键盘输入将引发 9 号中断，BIOS提供了int9中断例程。**CPU在9号中断发生后，执行 int 9 中断例程，从 60h 端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。

一般的键盘输入，在CPU执行完 int 9 中断例程后，都放到了键盘缓冲区中。键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。

下面我们按照键盘缓冲区的逻辑结构，来看一下键盘输入的扫描码和对应的ASCII码是如何写入键盘缓冲区的。

> 注意：在我们的课程中，仅在逻辑结构的基础上，讨论BIOS键盘缓冲区的读写问题。**其实键盘缓冲区是用环形队列结构管理的内存区**，但我们不对队列和环形队列的实现进行讨论，因为那是另一门专业课《数据结构》的内容。



下面，我们通过下面几个键：A、B、C、D、E、Shift_A、A 的输入过程，简要地看一下 int 9 中断例程对键盘输入的处理方法。

（1）初始状态下，没有键盘输入，键盘缓冲区空，此时没有任何元素。

![image-20220104142936953](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104142936953.webp)

（2）按下A键，引发键盘中断；CPU执行 int 9 中断例程，从60h端口读出A键的通码；然后检测状态字节，看看是否有 Shift、Ctrl 等切换键按下；
发现没有切换键按下，则将A键的扫描码 1eh 和对应的ASCII码，即字母“a”的ASCII码61h，写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCII码。此时缓冲区中的内容如下。

![image-20220104143141937](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104143141937.webp)

（3）按下B键，引发键盘中断；CPU执行 int 9 中断例程，从60h端口读出B键的通码；然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，将B键的扫描码30h和对应的ASCII码，即字母“b”的ASCIl码62h，写入键盘缓冲区。此时缓冲区中的内容如下。

![image-20220104143259455](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104143259455.webp)

（4）按下 C、D、E 键后，缓冲区中的内容如下。

![image-20220104143335160](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104143335160.webp)

（5）按下左Shift键，引发键盘中断；int 9 中断例程接收左Shift键的通码，设置0040:17处的状态字节的第1位为1，表示 左Shift键 按下。

（6）按下A键，引发键盘中断；CPU执行 int 9 中断例程，从60h端口读出A键的通码；检测状态字节，看看是否有切换键按下；发现左 Shift 键被按下，则将A键的扫描码 1Eh和 Shift_A对应的ASCII码，即字母“A”的ASCII码41h，写入键盘缓冲区。此时缓冲区中的内容如下。

![image-20220104143628920](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104143628920.webp)

（7）松开左 Shift键，引发键盘中断；int 9中断例程接收左 Shift键的断码，设置0040:17处的状态字节的第1位为0，表示左 Shift键松开。

（8）按下A键，引发键盘中断；CPU执行 int 9 中断例程，从60h端口读出A键的通码；然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，则将A键的扫描码 1eh和A对应的 ASCII码，即字母“a”的 ASCII码6lh，写入键盘缓冲区。此时缓冲区中的内容如下。

![image-20220104143840540](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104143840540.webp)



### 2. 使用 int 16h 中断例程读取键盘缓冲区

BIOS提供了 int 16h 中断例程供程序员调用。int 16h中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0。下面的指令从键盘缓冲区中读取一个键盘输入，并且将其从缓冲区中删除：

```asm
mov ah,0
int 16h
; 结果：(ah)=扫描码，(al)=ASCII码
```

下面我们接着上一节中的键盘输入过程，看一下 int l6h 如何读取键盘缓冲区。

（1）执行

```asm
mov ah,0
int 16h 
```

后，缓冲区中的内容如下。

![image-20220104144544776](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104144544776.webp)

ah中的内容为1Eh，al中的内容为6lh

> 记住：这是采用队列的思想，先进先出

（2）第二次执行(还是同样的代码)后，缓冲区中的内容如下。

![image-20220104144734645](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104144734645.webp)

ah中的内容为30h，al中的内容为62h。

（3）再次执行(还是同样的代码)后，缓冲区中的内容如下。

![image-20220104144826877](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104144826877.webp)

ah中的内容为2Eh，al中的内容为63h。

（4）执行4次(还是同样的代码)后，缓冲区空。

![image-20220104144929187](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104144929187.webp)

ah中的内容为1Eh，al中的内容为61h。

（5）再次执行(还是同样的代码)。int 16h 中断例程检测键盘缓冲区，发现缓冲区空，则循环等待，直到缓冲区中有数据。

（6）按下A键后，缓冲区中的内容如下。

![image-20220104145119648](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104145119648.webp)

（7）循环等待的 int 16h 中断例程检测到键盘缓冲区中有数据，将其读出，缓冲区又为空。

![image-20220104145159446](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104145159446.webp)

ah中的内容为1Eh，al中的内容为61h。



从上面我们可以看出，int 16h 中断例程的0号功能，进行如下的工作。

```properties
（1）检测键盘缓冲区中是否有数据；
（2）没有则继续做第1步；
（3）读取缓冲区第一个字单元中的键盘输入；
（4）将读取的扫描码送入ah,ASCII码送入al;
（5）将已读取的键盘输入从缓冲区中删除
```

可见，BIOS的 int 9 中断例程和 int 16h 中断例程是一对相互配合的程序，**int 9中断例程向键盘缓冲区中写入，int 16h中断例程从缓冲区中读出**。
它们写入和读出的时机不同，**int 9中断例程是在有键按下的时候向键盘缓冲区中写入数据；而int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。**

我们在编写一般的处理键盘输入的程序的时候，可以调用 int 16h 从键盘缓冲区中读取键盘的输入。

编程，接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色；输入“g”，将屏幕上的字符设置为绿色；输入“b”，将屏幕上的字符设置为蓝色。

```asm
assume cs:code
code segment
start:	mov ah,0	; 调用第0号子程序功能：读取键盘缓冲区
		int 16h
		; 读取后：(ah)=扫描码，(al)=ASCII码
		; 字符属性：0000 0000,其字符前景色只看后3位，000对应RGB，ah设置为1代表B为1，即蓝色
		mov ah,1	; 品味 RGB
		; 根据不同按键，设置不同的颜色
		cmp al,'r'
		je red
		cmp al,'g'
		je green
		cmp al,'b'
		je blue
		; 以上都不是 直接退出
		jmp short sret
		; 对应RGB
		; 如果是red,ah=*001b(*代表很多 但前景色只考虑后3位 所以这里屏蔽),这里向下执行时一共进行了左移2位,ah=100,从而可以设置为红色
red:	shl ah,1	; 品味
		; 如果是green,ah=*001b,这里向下执行时一共进行了左移1位,ah=010,从而可以设置为绿色
green:	shl ah,1	; 品味

blue:	mov bx,0b800h
		mov es,bx
		mov bx,1	; 指向显存的奇地址
		mov cx,2000
	s:	and byte ptr es:[bx],11111000b	; 初始化前景色
		or es:[bx],ah	; ah设置为前景色
		add bx,2
		loop s
		
sret:	mov ax,4c00h
		int 21h
code ends
end start
```



### 3. 字符串的输入

用户通过键盘输入的通常不仅仅是单个字符而是字符串。下面我们讨论字符串输入中的问题和简单的解决方法。

最基本的字符串输入程序，需要具备下面的功能。
（1）在输入的同时需要显示这个字符串；
（2）一般在输入回车符后，字符串输入结束；
（3）能够删除已经输入的字符。

对于这3个功能，我们可以想象在DOS中，输入命令行时的情况。

编写一个接收字符串输入的子程序，实现上面3个基本功能。因为在输入的过程中需要显示，子程序的参数如下：
(dh)、(dl) = 字符串在屏幕上显示的行、列位置；
ds:si 指向字符串的存储空间，字符串以 0 为结尾符。

**分析**

（1）字符的输入和删除。

每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的，我们看下面的过程。

```asm
空字符串:
输入“a”:a
输入“b”:ab
输入“c”:abc
删除一个字符：ab
删除一个字符：a
删除一个字符：
```

**可以看出在字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即后进先岀。**这样，我们就可以用栈的方式来管理字符串的存储空间，也就是说，**字符串的存储空间实际上是一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串。**

（2）在输入回车符后，字符串输入结束。

输入回车符后，可以在字符串中加入0，表示字符串结束。

（3）在输入的同时需要显示这个字符串。

每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，即从字符栈的栈底到栈顶，显示所有的字符。

（4）程序的处理过程。

现在我们可以简单地确定程序的处理过程如下。
① 调用int 16h读取键盘输入；
② 如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行①；
③ 如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行①；
④ 如果是  Enter键，向字符栈中压入0，返回。

从程序的处理过程中可以看出，字符栈的入栈、出栈和显示栈中的内容，是需要在多处使用的功能，我们应该将它们写为子程序。

```asm
; 子程序：字符栈的入栈、出栈和显示。
; 参数说明：(ah)=功能号，0表示入栈，1表示出栈，2表示显示；
;         ds:si 指向字符栈空间；
;         对于 0号功能：(al)=入栈字符；
;         对于 1号功能：(al)=返回的字符；
;         对于 2号功能：(dh)、(dl) = 字符串在屏幕上显示的行、列位置。
charstack:	jmp short charstart

table	dw charpush,charpop,charshow
top		dw 0	; 栈顶

charstart:	push bx
			push dx
			push di
			push es		; 保护现场
			
			cmp ah,2	
			ja sret		; 选择功能程序大于2，返回
			; 将功能子程序对应到table中的偏移地址 从而执行对应的子程序
			mov bl,ah
			mov bh,0
			add bx,bx
			jmp word ptr table[bx]	; 因为每个内存单元是字单元型的，正确的读取：0 2 4
; --------字符入栈功能-------
charpush:	mov bx,top	; bx=栈顶
			mov [si][bx],al	; al是字符，字符入栈  [si][bx]=>[bx+si]
			inc top		; 栈顶++
			jmp sret	; 返回
; --------字符出栈功能-------		
charpop:	cmp top,0	
			je sret		; 栈顶=0 返回
			dec top		; 先栈顶--
			mov bx,top	; 
			mov al,[si][bx]
			jmp sret
			
charshow:	mov bx,0b800h
			mov es,bx	; es:bx 指向显存
			mov al,160	
			mov ah,0	; ax=显存中的一行的内存大小 一行=80字符*2字节
			mul dh		; dh=行号
			mov di,ax	; 相乘后结果在ax中，di定位到字符在显存中指定行显示
			add dl,dl	; dl=列号，因为一列是2字节，所以列号需要*2
			mov dh,0	; 此时将dx作为显存中指定列的列号
			add di,dx	; di正儿八经的定位到显存中指定行和指定列
			
			mov bx,0
			
charshows:	cmp bx,top	; 判断栈顶是否为空
			jne noempty	; 不空执行 noempty
			mov byte ptr es:[di],' '	
			jmp sret
noempty:	mov al,[si][bx]	; 将ds:[bx+si]的字符送入al
			mov es:[di],al	; 将字符显示到指定行列
			mov byte ptr es:[di+2],' '
			; 进入下次循环
			inc bx
				add di,2
			jmp charshows
			
	sret:	pop es
			pop di
			pop dx
			pop bx
			ret
```

上面的子程序中，字符栈的访问规则如下所示。

（1）栈空

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104155954781.webp" alt="image-20220104155954781" style="zoom:67%;" />

（2）“a”入栈

![image-20220104160007421](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104160007421.webp)

（3）“b”入栈

![image-20220104160014974](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/汇编语言/王爽_第3版/image-20220104160014974.webp)

另外一个要注意的问题是，显示栈中字符的时候，要注意清除屏幕上上一次显示的内容。

我们现在写出完整的接收字符串输入的子程序，如下所示。

```asm
getstr:	push ax

getstrs:mov ah,0
		int 16h		; 取出从键盘输入的字符
		
		cmp al,20h
		jb nochar	; 如果ASCII码小于20h，说明不是字符
		mov ah,0
		call charstack	; ah=0,调用字符入栈子程序
		mov ah,2
		call charstack	; ah=2,调用显示栈中字符子程序
		jmp getstrs		; 继续等待输入

nochar:	cmp ah,0eh		; 退格键的扫描码
		je backspace
		cmp ah,1ch		; Enter键的扫描码
		je enter
		; 否则继续等待输入
		jmp getstrs
		
backspace:mov ah,1
		call charstack	; ah=1,调用字符出栈子程序
		mov ah,2
		call charstack	; ah=2,调用显示栈中字符子程序
		jmp getstrs
		
enter:	mov al,0
		mov ah,0
		call charstack	; 0入栈
		mov ah,2
		call charstack	; 显示栈中的字符
		pop ax
		ret
```



### 4. 应用 int 13h 中断例程对磁盘进行读写

我们主要以3.5英寸软盘为例，进行讲解。

3.5英寸软盘分为上下两面，每面有80个磁道，每个磁道又分为18个扇区，每个扇区的大小为512个字节。

则：2面 \* 80磁道 \* 18扇区 \* 512字节 = 1440KB ≈ 1.44MB

磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。面号和磁道号从0开始，而扇区号从1开始。

如果我们通过直接控制磁盘控制器来访问磁盘，则需要涉及许多硬件细节。**BIOS提供了对扇区进行读写的中断例程**，这些中断例程完成了许多复杂的和硬件相关的工作。我们可以通过调用BIOS中断例程来访问磁盘。

BIOS提供的访问磁盘的中断例程为 int 13h。读取 0面0道1扇区 的内容到0:200的程序如下所示。

```asm
mov ax,0
mov es,ax
mov bx,200h

mov al,1
mov ch,0
mov cl,1
mov dl,0
mov dh,0
mov ah,2
int 13h
; 入口参数：
;     (ah) = int 13h 的功能号(2表示读扇区)
;     (al) = 读取的扇区数
;     (ch) = 磁道号
;     (cl) = 扇区号
;     (dh) = 磁头号(对于软盘即面号，因为一个面用一个磁头来读写)
;     (dl) = 驱动器号	软驱从0开始，0：软驱A，1：软驱B；
;                      硬盘从80h开始，80h：硬盘C，81h：硬盘D
;     es:bx 指向接收从扇区读入数据的内存区

; 返回参数
;     操作成功：(ah)=0，(al)=读入的扇区数
;     操作失败：(ah)=出错代码
```

将 0:200 中的内容写入 0面0道1扇区。

```asm
mov ax,0
mov es,ax
mov bx,200h

mov al,1
mov ch,0
mov cl,1
mov dl,0
mov dh,0

mov ah,3
int 13h
; 入口参数：
;     (ah) = int 13h 的功能号(3表示写扇区)
;     (al) = 写入的扇区数
;     (ch) = 磁道号
;     (cl) = 扇区号
;     (dh) = 磁头号(面)
;     (dl) = 驱动器号	软驱从0开始，0：软驱A，1：软驱B；
;                      硬盘从80h开始，80h：硬盘C，81h：硬盘D
;     es:bx 指向将写入磁盘的数据

; 返回参数
;     操作成功：(ah)=0，(al)=写入的扇区数
;     操作失败：(ah)=出错代码
```

> 注意，下面我们要使用int 13h中断例程对软盘进行读写。直接向磁盘扇区写入数据是很危险的，很可能覆盖掉重要的数据。
>
> 如果向软盘的0面0道1扇区中写入了数据，要使软盘在现有的操作系统下可以使用，必须要重新格式化。在编写相关的程序之前，必须要找一张空闲的软盘。在使用int 13h中断例程时一定要注意驱动器号是否正确，千万不要随便对硬盘中的扇区进行写入。

编程：将当前屏幕的内容保存在磁盘上。

分析：1屏的内容占4000个字节，需要8个扇区，用0面0道的1~8扇区存储显存中的内容。程序如下。

```asm
assume cs:code
code segment
start:	mov ax,0b800h
		mov es,ax
		mov bx,0
		
		mov al,8
		mov ch,0
		mov cl,1
		mov dl,0
		mov dh,0
		mov ah,3
		int 13h
		
		mov ax,4c00h
		int 21h
code ends
end start
```

