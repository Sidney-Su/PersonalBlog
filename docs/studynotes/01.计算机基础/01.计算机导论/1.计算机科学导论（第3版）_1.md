---
title: 计算机科学导论（第3版）_1
date: 2023-01-29 10:41:02
permalink: /pages/42f1d2/
categories:
  - studynotes
  - 计算机基础
  - 计算机导论
tags:
  - 
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---
计算机科学导论（第3版） 作者：[美] [*贝赫鲁兹佛罗*](https://item.jd.com/72314048825.html)

## 第一章 绪论

### 1. 图灵模型

1937首次提出通用计算机设想：所有的计算都可能在一种特殊的机器上执行





### 2. 冯-若依曼模型

```properties
•存储器: 用来存储数据和程序的区域
•算术逻辑单元（ALU）: 用来计算和逻辑运算的地方
•控制单元: 对存储器、算术逻辑单元、输入/输出等子系统进行控制操作
•输入/输出单元: 输入子系统负责从计算机外部接收输入数据，输出子系统负责从计算机处理结果输出到计算机外部
```

人类可识别(高级语言) -->  计算机可识别(二进制)   这个过程称为编译





### 3. 位置化数字系统

在位置化数字系统中，数字符号所占据的位置决定了其表示的值。不同位置的数字符号，表示不同的数量，叫做位置化数字系统

最大值：十进制与二进制计算最大值都是差不多的，只是底数不一样

> 数码k表示的二进制整数的最大值是N~max~=2^k^-1.例如，如果k=5，那么这个最大值就是N~max~ = 2^5^ - 1 = 31

![image-20211104153612897](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104153612897.webp)

k=5, (FFFFF)~16~  => 16^5^  -1

> 一个数的负2次方等于这个数的正2次方的倒数，一个数的负n次方等于这个数的正n次方的倒数。
> 16^-2^ => 1/(16^2^)  约等于 0.0039



n位数的最大值：
- N~max~ = 2^k^-1
- (100)~10~ => k=3,10^3^-1=999
> k代表位数，(100)~10~ => k=3,代表3位十进制数。所以这是求3位十进制数的最大值为 999
> 十进制与二进制计算最大值都是差不多的，只是底数不一样





### 4. 进制转换

**其他进制转十进制：**可以通过位置化数字系统来转换，将数码乘以其在源系统中的位置量并求和便得到十进制中的数。

**十进制转其他进制：**

1. 十进制整数 / 其他进制 = 商.....余数    一直除直到商为0，然后余数倒序放一起。(整数部分)

   连乘法：十进制小数 * 其他进制 = 整数.小数    一直乘到小数部分等于0，然后整数顺序放一起。(小数部分)





## 第三章 数据存储

### 1. 计算机内部的数据格式

```properties
位（bit，binary digit缩写）是存储在计算机中的最小单位：0或1，代表设备的某一种状态。

位模式（位流）：表示数据的不同类型，多个位组成一个位模式，由16个位组成的位模式。如果我们需要存储1000个位模式，每个16位，需要16000个开关。
8位模式、16位模式、32位模式、64位模式

字节：长度为8的位模式，称为1字节
1KB = 1000B，1KiB = 1024B

字：指代更长位模式，比如可以表示 1个字 = 2字节 或 1个字 = 4字节 等等
```

![image-20211104163516960](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104163516960.webp)



### 2. 存储数字

```properties
在存储到计算机内存之前，数字被转换为二进制系统，但是：
1.如何存储数字的正负符号
2.如何显示小数点
```



#### 1. 存储整数

![image-20211104163800758](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104163800758.webp)

**整数通常使用 定点表示法 存储在内存中。**



##### 1.1 存储整数——无符号表示法

![image-20211104163942103](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104163942103.webp)



![image-20211104163946320](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104163946320.webp)

```asm
例如：3 => 不足8(n)位  左边补0存储 => 0000 0011
```

![image-20211104164322961](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104164322961.webp)

存储整数——译解无符号整数：就是将二进制形式存储的无符号整数转换为十进制展示

存储整数——溢出：因为存储单元位的数量限制，可以表达的整数范围是有限的，在n位存储单元中，可以存储的无符号整数的范围仅（为0~2的n次方-1）

![image-20211104165752395](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104165752395.webp)

有符号的，一般用来做运算



##### 1.2 存储整数——符号加绝对值表示法

用于无符号整数的有效范围（0~2的n次方-1）被分成两个相等的子范围，前部分表示整数，后部分表示负数

![image-20211104170011028](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104170011028.webp)

```properties
•该系统中有两个0：正0（0000），负0（1000）
•符号加绝对值格式存储一个整数时，需要用1个二进制位表示符号（0表示正，1表示负）
•在最左位用于定义符号（0表示正，1表示负） 即最高位表正负
```

存储整数——符号加绝对值表示法溢出（正溢出与负溢出）

符号加绝对值表示法的应用：符号加绝对值表示法不用于存储整数，而用于存储部分实数。此外，符号加绝对值表示法通常用于采样模拟信号，例如：音频。

> 注意：这个不要跟补码混淆了，就单纯的，最高位表示符号位，并没有进行补码的计算



##### 1.3 存储整数——二进制补码表示法

几乎所有的计算机都使用**二进制补码表示法来存储**n位存储单元中**有符号整数**

![image-20211104171334805](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104171334805.webp)

在二进制补码表示法中，最左位决定符号，如果是0，**该整数**为正，如果是1，**该整数**为负。

反码：简单反转各个位，即把0变成1，1变成0，该运算不区分正负数(所有位都取反操作)。

**补码（有两种运算方式）**

方式一：首先，从右边复制位，直到有1被复制，接着反转其余位。(第一个1下来，其他全部取反)

![image-20211104172239443](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104172239443.webp)

> 注意：是先将负数也看作其正数形式，然后再做以上转换

方式二：先取整数的反码，再加1（取反加1）。这个教的常用点



正数的补码形式：原码 \=== 反码 \=== 补码
负数的补码形式：

- 补码 = 反码+1
- 反码 = 原码除符号位外全取反
- 原码 = 十进制负数形式 转 二进制形式



整数两次补码还是原先的整数

![image-20211104173235397](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104173235397.webp)

```properties
正数存原码(因为正数的原码、反码、补码都是相同的)
负数存补码：负数的反码为对该数的原码除符号位外各位取反
		  负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1
```

![image-20211104174031651](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104174031651.webp)



![image-20211104174816508](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211104174816508.webp)





#### 2. 存储实数

##### 2.1 定点表示法

![image-20211105092518005](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105092518005.webp)



##### 2.2 浮点表示法(可表示很大的整数部分或很小的小数部分)

![image-20211105093245347](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105093245347.webp)

> 也个数字的浮点表示法由三部分组成：符号、位移量、定点数。
> 科学记数法：52460 = 5.246 \* 10^4^	(+表符号 4表位移量 5.246表定点数)
> 浮点表示法：10011 = 1.0011 * 2^4^	(+表符号 4表位移量 1.0011表定点数)



科学计数法：左边只留一个非零数码

##### 存储实数——浮点表示法规范化

![image-20211105093929813](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105093929813.webp)

**存储实数——符号、指数和尾数**

![image-20211105094455413](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105094455413.webp)

二进制的尾数形式，定点部分的左边必定是1，所以没必要存储

```properties
在一个二进制数规范化之后，只需存储该数字的三部分信息：符号、指数和尾数（小数点右边的位）。
（1）符号（S）：一个二进制位来表示（0或1）
（2）指数（E）：指数（2的幂）定义为小数点移动的位数，可正可负。余码表示法是用来存储指数位的方法。
（3）尾数（M）：尾数是指小数点右边的二进制数，它定义了该数的精度，作为无符号整数进行存储。
```



##### 存储实数——余码系统(如何存指数)

![image-20211105095030722](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105095030722.webp)

<!--即：指数本来可以是[3|-3]，通过加上偏移量使之必然成为一个正数后，用无符号数存储。比如用余7系统，3+7=>10，-3+7=>4 ；所以指数3实质存储为10，指数-3实质存储为4-->

![image-20211105095251716](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105095251716.webp)

```properties
指数是有符号的数，在余码系统中，正的和负的整数都可以作为无符号整数存储。
为了表示正的或负的整数，将一个偏移量（正整数）添加到每个数字中，将它们统一移到正的一方。这个偏移量的值为2^m-1，m为内存单元存储指数的大小。
```



##### 5.IEEE标准

![image-20211105100101529](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105100101529.webp)

> 余127码：2^(8-1)^-1 = 127

![image-20211105100215467](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105100215467.webp)



##### 6.IEEE标准浮点数的存储

![image-20211105101436078](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105101436078.webp)

**例子：存储一个正浮点数**

![image-20211105101505158](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105101505158.webp)

**例子：存储一个负浮点数**

![image-20211105101553674](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105101553674.webp)

<!--为什么负数没采用补码形式存储？我认为应该是把这个系统都看作是无符号整数存储，所以没有负数的概念，负数只需要在符号位标识一下就行-->

![image-20211105102015177](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105102015177.webp)



##### 7.IEEE标准浮点数的还原

![image-20211105102524700](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105102524700.webp)

例子：

![image-20211105102634805](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105102634805.webp)



##### 8.上溢和下溢

浮点表示法不能存储绝对值过大或过小的数字。试图存储绝对值很小的数导致下溢，存储绝对值很大的数导致上溢情况。

##### 9.存储零

带有整数部分和小数部分的实数为零是表示为0.0，无法用上述步骤存储。因此约定在这种情况下，符号、指数、尾数都设为0。

##### 10.截断误差

存储数字时只会保留规定的位数，额外的位数会被阶段舍弃。



### 3.存储文本

文本的片段是用来表示该语言中某个意思的一系列的符号。我们可以**用位模式来表示任何一个符号**，只要解决需要多少位来表示的问题——而这取决于要表示的语言集由多少个符号。例如英语仅有26个字母，汉字则更多。更多的符号意味着更长的位模式。

位模式的长度与符号的数量并不是线性的，而是对数关系。即2^k^=N --> k=log~2~ N

![image-20211105103906668](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105103906668.webp)

> 1位可以存储两个字符，依次类推，2位可存4个字符.....

**代码：不同的用于表示文本符号的集合。**

1）ASCII
该代码使用7位表示每个符号，总共可定义2^7^ = 128种不同的符号。
2）Unicode
该代码可表示最大2^32^ = 4294967296个符号。

> 最开始是ASCII表出来，因为只需要表示英文字母，足够，每个代码对应不同的符号。如(01000001)~2~ = A
>
> 因为ASCII只能容纳英文字母，所以其他国家纷纷开发了自己的编码(如中国的GBK)。然后为了统一，用Unicode编码对应所有国家的编码字符。



### 4.存储音频

音频是随时间变化的实体，是不可数的。我们只能在每一时刻度量声音的密度，存储进计算机。

#### 4.1 采样

我们不能记录一段时间内音频信号的所有值，但是可以选择数量有限的点来度量它们的值并记录下来。

![image-20211105105525988](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105105525988.webp)

**采样率：每秒多少个样本值**

#### 4.2 量化

采样得到的是真实的数字，但是如果使用无符号的数会更简便。**量化**是指将样本值截断取为最接近的整数值的一个过程。量化就是取整。

![image-20211105105612588](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105105612588.webp)

#### 4.3 编码

量化的样本值需要编码成位模式。一些系统使用无符号整数，一些系统使用符号加绝对值。

```properties
1.每样本位：每个样本系统决定分配多少位。
2.位率：每样本位的数量为B，每秒样本数为S，则需要每秒音频存储S*B位。该乘积称为位率R。
```

![image-20211105110151249](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105110151249.webp)

#### 4.4 声音编码标准

例：MP3(MPEG Layer 3) ：有损压缩法





### 5.图像

#### 5.1 光栅图

当我们存储模拟图像时，采用光栅图（或位图）。一张照片由模拟数据组成，不同于音频信号(随时间而变化)，图像的数据密度随空间变化。数据的采样称作**扫描**，样本称为**像素**。换言之，整个图像被分成许多个小的像素，每个像素假定有单独的密度值。

##### 1.解析度

我们要决定每英寸的方块或线条需要记录多少像素。在图像处理中的扫描率称为解析度。如果解析率足够高，人眼不会看出在重现图像中的不连续。



##### 2.色彩深度

用于表现像素的位的数量，称为色彩深度。

###### （1）真彩色（用于像素编码的技术之一）

用24位来编码一个像素，每个三原色（RGB）都表示为8位，可以表示0~256之间的一个数。

真彩色模式可以编码2^24^种颜色。

![image-20211105111420948](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105111420948.webp)

###### （2）索引色

许多应用程序用不到真彩色那么大的颜色范围，索引色模式仅使用一部分，并对其建立索引。即简化版的真彩色。

![image-20211105111702855](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105111702855.webp)

###### （3）图像编码标准

例：JPEG，GIF等

![image-20211105111801017](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105111801017.webp)



#### 5.2 矢量图

光栅图有两个缺点，即文件尺寸太大和重新调整大小有麻烦。放大光栅图意味着扩大像素，所以放大后光栅图看起来很粗糙。

**矢量图**的编码方法并不存储每个像素的位模式，而是将像素分解成几个几何图形的组合。例如：线段、矩形或圆形。每个几何形状由数学公式表达。矢量图是由定义如何绘制这些形状的一系列命令构成的。

> 当要显示或打印图像时，将图像的尺寸输入传给系统，系统重新设计图像的大小并用相同的公式画出图像。因此矢量图也称为几何模型或面向对象图形。每一次绘制图像，公式也需要重新估算一次。
>
> 例如，考虑半径为r的圆形。程序需要绘制该圆的主要信息如下：1. 一个圆的半径r。2. 圆心的位置。3. 绘制的线型和颜色。4. 填充的类型和颜色。
>
> 当该圆的大小改变时，程序改变半径的值并重新计算这些信息以便再绘制一个圆。改变图像大小不会改变绘图的质量。

矢量图不适合存储图像的细微精妙，而适合应用程序采用主要的几何元素来创建图像。



#### 5.3 光栅图&矢量图对比

```properties
光栅图
优点：可以存储图片的精细部分
缺点：文件体积大、重新调整图片大小影响图片画质

矢量图
优点：文件体积小
缺点：存储的图片不精细
```





### 6. 存储视频

视频时图像在时间上的表示（称为**帧**）。所以，如果知道如何将一副图片存储在计算机中，我们也就知道如何存储视频；每一帧转化为一系列位模式并存储，这些图像组合起来表示成视频。视频通常是压缩存储的。

![image-20211105113113341](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105113113341.webp)

> 视频存的就是一张张图片，只是一帧的切换速度超过了人眼最大可识别的频率，所以产生了一直动的效果。正是因为图片太多了，需要压缩存储。

```
每秒中播放的帧数,就是我们说的帧速率. 图像停留在人眼的时间大约是1/24秒,所以电影和电视一般采用每秒钟播放24张图片来放映,也就是24帧/秒左右(电影25、电视24). 而这类产品一般支持到15帧/秒.所以,在大动态画面出现时,它产生一些跳跃的感觉,也就是很正常的事情了.

(2)从转换软件的工作原理来说,它可以看做分成2个步骤：
第一,把你要转换的正常视频文件先读出来(解码)
第二,按照MTV或者AMV规定的格式(帧速、分辨率大小、颜色等),重新组合成新文件(再次编码). 
如果理解了这个过程,那么一些用户在使用过程中抱怨的“我怎么转换不了某段视频”,其实大部分原因是出在第一阶段——转换软件,本身就不支持某个格式文件的解码,所以就无法先进行第一步,也就自然没有第二步了. 解决这个问题的方法,只能用其他软件,先转成一种它支持读取的格式,然后再用它来转成MTV或者AMV格式；
```





## 第四章 数据运算

引言：第三章中，我们了解了计算机都可以存储哪些类型的数据。本章将讲述如何在这些存储在计算机的数据上进行运算。数据上的运算可以分为三大类：算术运算、位移运算和逻辑运算。

### 4.1 逻辑运算

 逻辑运算是指那些应用于位模式中的一个二进制位，或者两个模式中相应的两个二进制位的相同基本运算。这意味着我们可以在位层次和模式层次上定义逻辑运算。

#### 4.1.1 位层次上的逻辑运算

一个位可能使0或1，可以假设0代表逻辑假，1代表逻辑真，我们可以应用布尔代数中定义的操作去操纵二进制位。本节介绍4种运算：非（NOT)，与（AND)，或（OR），异或（XOR）。

（相关知识：布尔代数和逻辑电路）

非、与、或分别对应C语言中的“！”，“&&”，“||”

异或表示：如果输入相同，则输出为0；如果输入不同，则输出位1。



非（NOT)运算符是一元操作符，有一个输入，输出位是输入位的相反，**如果输入0，则输出1；如果输入1，则输出0。**

![image-20211105135458695](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105135458695.webp)

与（AND)运算符是二元操作符，有两个输入，**如果输入都是1，则输出1；其它3种情况，输出都是0。**

![image-20211105135516262](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105135516262.webp)

或(OR)运算符是二元操作符，有两个输入，**如果输入都是0，则输出0；其它3种情况，输出都是1。**

![image-20211105135748133](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105135748133.webp)

异或(XOR)运算符是二元操作符，**有两个输入，如果输入相同，则输出0；如果输入不同，则输出1。**



#### 4.1.2 模式层次上的逻辑运算

相同的4个运算符可以被应用到n位模式。效果对于NOT来说，是把运算符应用到每一位；对其余三种运算来说，把运算应用到相应的位对。

例如： 10011000 AND 00101010 = 00001000

            NOT 10011000= 01100111

4种逻辑运算可以用于修改位模式。

（1）求反

NOT运算符唯一的应用就是求反。对模式应用此运算符把0变成1，把1变成0.

（2）复位

**与运算**的一个应用就是把位模式中指定的位进行**复位（置0）**。这种情况下第二个输入叫做**掩码**。掩码中的0位对第一个输入中相应的位进行复位。掩码中的1位使得第一个输入中的相应的位保持不变。

```properties
对指定的位复位：
AND 指定的位通过掩码 复位---0(与操作的复位就是置0)
OR 指定的位通过掩码 复位---1(或操作的复位就是置1)
XOR 指定的位通过掩码 复位 取反(异或操作的复位是对位取反)
```

![image-20211105142748425](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105142748425.webp)

掩码是根据你想通过原码复位(变成)什么样子而产生的。

```properties
在与操作中，复位意味着将某位变成0
题目中，要求用掩码复位原码的最左边5位
原码：10100110
得出掩码：00000111 (因为左边5位需要复位 所以and操作的掩码左边5位是0)
结果：00000110
```

（3）置位

**或运算**的一个应用就是把位模式中指定的位进行**置位（置1）**。此时的掩码中，1位对第一个输入中的位进行置位，0位使得第一个输入中相应的位保持不变。

![image-20211105143806261](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105143806261.webp)

（4）反转

**异或运算**的一个应用就是把**指定的位进行反转**。此时掩码中的1位对第一个输入中的相应的位进行反转，0位使得第一个输入中相应的位保持不变。

![image-20211105143834471](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105143834471.webp)





### 4.2 移位运算

移位运算移动模式中的位，改变位的位置。能向左或向右移动。我们把移位运算分为两大类：逻辑移位运算和算术移位运算。

#### 4.2.1 逻辑移位运算

**逻辑移位运算应用于不带符号位的数的模式。**原因是移位运算可能会改变数的符号。

##### 1.逻辑移位

逻辑右移运算把每一位向右移动一个位置。在n位模式中，最右位被丢弃，最左位填0。同理逻辑左移丢弃最左位，最右位填0。

![image-20211105144132942](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105144132942.webp)

##### 2.循环移位

循环移位对位进行移位，没有位丢弃或增加。循环右（左）移将每一位都向右（左）移动移位，最右（左）位填到最左（右）位。

![image-20211105144330443](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105144330443.webp)





#### 4.2.2 算术移位运算

**算术移位运算假定位模式使用二进制补码格式表示的带符号的整数。算术右移被用来对整数除以2；算术左移被用来对整数乘以2。**这些运算不改变符号位。算术右移保留符号位，但同时也把它赋值，放入相邻的右边的位中。算术左移丢弃符号位，接受它右边的位作为符号位。如果新的符号为与原先的相同，那么运算成功；否则发生上溢或下溢，结果使非法的。

![image-20211105144812034](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105144812034.webp)



![image-20211105145236423](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105145236423.webp)





### 4.3 算术运算

算术运算包括加减乘除，适用于整数和浮点数。乘除法运算方式：1. 通过循环加减运算 2. 通过移位来运算

#### 4.3.1 整数的算术运算

本章只讨论整数的加法和减法。

##### 1.二进制补码整数的加减法

二进制补码的优点是，加法和减法之间没有区别。遇到减法运算时，计算机只简单地把它转变成加法，但要为第二个数求二进制的补。

**A-B=A+(B\`+1)     B\`+1表示B的补码**

二进制补码的加法就像十进制一样：列与列相加，如果有进位，就加到下一列上。但是，最后一列的进位会被舍弃。

算法过程如下：

1）如果运算是减法，取第二个整数的补码；否则，转下一步

2）整数相加

![image-20211105150450868](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105150450868.webp)

> A+B，A是正数，B是负数(需要转换为补码形式)

![image-20211105150736681](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105150736681.webp)

> A-B=A+B的补码，A是正数，B是负数取补码，据公式A-B=A+B补，所以B在原负数取补码的情况下再次取补码(即取两次补码)。=>A+B补补

![image-20211105150849907](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105150849907.webp)

> A-B=A+B补，A是负数取补码，-B=+B补，所以B也需要取补码。=>(A补)+(B补)

![image-20211105152134099](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105152134099.webp)



##### 2.符号加绝对值整数的加减法

流程如下：

1）检查运算，如果是减法，那么改变第二个整数B的符号

2）对两整数的符号应用XOR运算，如果结果S是0，意味着符号相同；否则符号不同

3）如果符号相同，Rm=±（Am+Bm)，（Rm,Am和Bm表示R,A和B的绝对值），结果的符号与A、B都相同。此时应考虑，相加结果可能会发生上溢，需要报告并终止过程。

4）如果符号不同，Rm=±（Am-Bm），则从A中减去B，然后对符号进行判断。相减的过程为取第二个绝对值的二进制补码然后相加。结果的符号是较大绝对值的整数的符号。





#### 4.3.2 实数的算术运算(有点复杂，与余码相关)

以浮点数格式存储的实数的加法和减法被简化为**小数点对齐后以符号加绝对值格式**（符号和尾数的组合）存储的两整数的加法和减法。过程如下：

1）如果两数中任意一个为0，结果为另一个数，结束

2）如果运算时减法，那么改变第二个数B的符号来模拟加法

3）通过在尾数中隐含的1和增加指数，将两个数去规范化

4）然后统一指数，即增加较小的指数，移位相应的尾数，直到两个数具有相同的指数。

5）现在把每个数的符号和尾数的组合看成一个符号加绝对值格式的整数。两个整数相加

6）最后，再次规范化数

![image-20211105154744034](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105154744034.webp)

> 这是余127码，S代表符号位，E代表余127码后的指数，M代表尾数。注意去规范化后，E是加1，M是最左边加1位1
>
> (为什么？规范化是类似于科学计数法，最左边保留了1位[在二进制中肯定为1]和小数点，去规范化后相当于左边不需要保留1位了，相当于指数又移动了一位。所以指数肯定要加1了，且原保留的1位需要添加到尾数中)

![image-20211105154846822](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105154846822.webp)

> 对齐尾数，保证指数相等。A比B小5，保证A与B的指数相等时，A的尾数需要右移5位(因为A的指数加了5)
>
> 然后进行符号加绝对值加法(这个不太懂)。尾数相加后，继续规范化相加后的值，从而得到了最终结果。去规范化变成规范化，将上面的规范化的步骤反一下就行

减法运算：

![image-20211105160428904](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105160428904.webp)



![image-20211105160502875](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105160502875.webp)

> 看情况应该是，符号位也是直接相加







## 第五章 计算机组成

引言：计算机的组成部件可以分为三大类（或三个子系统）：**中央处理单元(CPU)，主存储器(内存)和输入输出子系统**。接下来的部分将讨论这些子系统以及如何将这些子系统组成一个计算机。



### 5.1 中央处理单元

**中央处理器（CPU）用于数据的运算**。在大多数体系中，它有三个组成部分：**算术逻辑单元（ALU），控制单元，寄存器组（快速存储单元）**。

#### 5.1.1 算术逻辑单元(ALU)

**算术逻辑单元对数据进行逻辑、移位和算术运算。**

相关运算见计算机科学导论学习笔记（四），第四章数据运算

```properties
逻辑运算：非、与、或、异或，这些运算把输入数据作为二进制位模式，运算结果也是二进制位模式
移位运算：逻辑移位运算和算术移位运算
算术运算：整数和实数的加减运算
```



#### 5.1.2 寄存器

寄存器是用来**临时存放数据**的高速独立的存储单元。CPU中通常有多个寄存器。

##### 1.数据寄存器

计算机在CPU中使用几十个数据寄存器来存储输入数据和输出结果，并且需要一些寄存器来**保存运算的中间结果**。

##### 2.指令寄存器(IR)

计算机存储的不仅是数据，还有存储在内存中相应的程序。**CPU的主要职能是从内存中逐条地取出指令，并将取出地指令存储在指令寄存器中并解释执行指令。**

##### 3.程序计数器(PC)

CPU中另一个通用寄存器是程序计数器。**程序计数器中保存当前正在执行的指令地址**，当前指令执行完后，计数器自动加1，指向下一条指令的内存地址。



#### 5.1.3 控制单元

控制单元控制各个子系统的操作，控制是通过从控制单元到其他子系统的**信号**来进行的。





### 5.2 主存储器(内存)

主存储器是存储单元的集合，**每一个存储单元都有唯一的标识，称为地址**。**数据以字的位组形式**在内存中传入和传出。字可以是8位、16位、32位或64位等。如果是8位，一般称为一个字节。

#### 5.2.1 地址空间

在存储器中存取每个字都需要有相应的标识符，在硬件层次上，每个字都是通过地址来标识的。所有在存储器中标识的独立的**地址单元的总数称为地址空间**。

例如，一个64KB(总共能存多少位)、**字长为1个字节(每存1条数据是8位)**的内存地址空间的范围为0~65535(代表可以存多少条数据。64\*1024\*8 / 8 = 65536)。下表给出了经常用来表示存储大小的单位名称：

| 单位     | 字节数的准确值 | 近似值 |
| -------- | -------------- | ------ |
| 千字节   | 2^10^(1024)    | 10^3^  |
| 兆字节   | 2^20^(1048576) | 10^6^  |
| 千兆字节 | 2^30^          | 10^9^  |
| 兆兆字节 | 2^40^          | 10^12^ |

> 内存地址用无符号二进制整数定义

![image-20211105163756184](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105163756184.webp)

> 5.1题  32MB=> 2^25^ * 8。如果字长以1字节(8位)存储，需要25位寻址总线。如果字长以2字节(16位)存储，需要 (2^25^ *8)/16 = 2^24^，需要24位寻址总线。

**作为位模式的地址**

由于计算机中都是以位模式存储数，因此存储地址也是位模式表示的。如果一个内存是64K（2^16)，字长为一个字节，那么就需要16位的位模式来表示地址。第三章提到，地址用无符号整数来表示，则起始地址通常是0000000000000，最后一个地址位11111111111111111。

通常，一个计算机有N个字的存储空间的话，那么就需要Log2N位无符号整数来确定每一个存储单元。



#### 5.2.2 存储器的类别

主要有两种类型的存储器：RAM和ROM。

##### 1.随机存取存储器（RAM）

可以使用存储单元地址来随机存取一个数据项，而不需要存取位于它前面的所有数据项。RAM与ROM的区别在于，用户可以读写RAM，即用户可以在RAM中写信息，之后可以方便地通过覆盖来擦出原有信息。RAM的另一个特点是易失性。特点：**易失性**，当系统断电后，信息将丢失。即断电后，RAM中的信息会被删除。

##### 2.只读存储器（ROM）

只读存储器的内容是制造商写进去的，用户只能读但不能写，它的优点是非易失性。特点：**非易失性**，切断电源后，信息也不会丢失。**常用来存储那些在开机时运行的程序。**



#### 5.2.3 存储器的层次结构

为了满足速度快且价格低廉的存储器的需求，通常采用存储器的层次结果，即：

```properties
·当对速度要求很苛刻时可以使用少量高速存储器。如CPU中的寄存器。
·用适量的中速存储器来存储经常需要访问的数据。例如高速缓冲存储器
·用大量的低速存储器存储那些不经常访问的数据。例如主存
```



#### 5.2.5 高速缓冲存储器

**高速缓冲存储器的存取速度比主存快，但比CPU及其内部寄存器慢。**高速缓冲存储器通常容量较小，常被置于主存和CPU之间。

高速缓冲存储器在任何时间都含有主存中的一部分内容的副本。当CPU要存取主存中的一个字时，将按以下步骤进行：

```properties
1）CPU首先检查高速缓存

2）如果要存取的字存在，CPU就把它复制；如果不存在，CPU就从主存中拷贝一份需要读取的字的数据块，该数据块将覆盖高速缓冲存储器中的内容。

3）CPU在高速缓存中存取并拷贝该字
由于80-20规则，计算机通常花费80%的时间来读取20%的数据。相同的数据往往被存取多次，因此高速缓存可以存储这20%的数据，使得存取至少快80%。
```





### 5.3 输入/输出子系统

可以使计算机与外界进行通信，并在断电情况下存储程序和数据。输入/输出设备可以分为两大类：非存储设备和存储设备

#### 5.3.1 非存储设备

非存储设备使得CPU与外界可以通信，但它们不能存储信息。

**1.键盘和监视器**

键盘提供输入功能；监视器显示输出并响应键盘的输入。

其他还有：鼠标、操纵杆等。

**2.打印机**



#### 5.3.2 存储设备

尽管存储设备被分为输入/输出设备，但它也可以存储大量的信息。它们更见便宜且存储的数据不易丢失。有时称它们为辅助存储设备，通常分为**磁介质**和**光介质**两种。

##### 1.磁介质存储设备：磁盘、磁带等

使用磁性来存储位数据，如果一个点有磁性则表示1，没有磁性则表示0

磁盘是由一张一张的磁片叠加而成的，信息是通过盘上的每个磁片的读/写磁头读写磁介质表面来进行数据存取。

![image-20211105170324262](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105170324262.webp)

> 磁盘是快速旋转的，控制器的读写头就可以扫描到对应位置读取到指定的内容了

**表面结构**
	为了将数据存储在磁盘的表面，每个盘面都被划分为磁道，每个磁道又分成若干个扇区。磁道间通过磁道内部间隔隔开，扇区之间通过扇区内部间隔隔开。

**数据存取**
	磁盘是一个随机存取设备，在某一时间点可以读取的最小存储区域只能是一个扇区。数据块可以存储在一个扇区或多个扇区上

**性能**
取决几个因素：角速度、寻道时间和传送时间

```properties
角速度定义了磁盘的旋转速度
寻道时间定义了读/写磁头寻找数据所在磁道的时间
传送时间定义了将数据从磁盘移到CPU/内存所需要的时间
```



##### 2.光存储设备：

光存储设备使用激光技术来存储和读取数据

```properties
1）CD-ROM 只读光盘
2）CD-R 可刻录光盘
3）CD-RW 可重写光盘
4）数字多功能光盘（DVD）
```

![image-20211105170826715](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105170826715.webp)

> 怎么做？激光器在光盘的表面造一些坑(坑就代表数据)。计算机里的光驱里的激光扫描光盘。



### 5.4 子系统的互连

#### 5.4.1 CPU与存储器的连接

CPU与内存之间通常由称为总线的三组线路连接在一起，分别是：**数据总线、地址总线和控制总线。**

![image-20211105171808343](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211105171808343.webp)

##### 1.数据总线

数据总线由多根线构成，**每根线每次传送1个位的数据**。线的数量取决于字的大小。例如，计算机的字是32位（4字节），那么需要32根线的数据总线，以便同一时刻同时传送32位的数据。

##### 2.地址总线

地址总线允许访问存储器的每个字，**地址总线的线数取决于存储空间的大小**。例如，存储器容量为2的n次方个字，那么地址总线一次需要传送n位的地址数据，因此需要n根线。

##### 3.控制总线

控制总线**负责在中央处理器和内存之间传送信息**。例如，必须有一个代码从CPU发送到内存，用于指定进行的是读还是写操作。**控制总线的线数取决于计算机所需要的控制命令的总数**。如果计算机由2的m次方条控制命令，那么控制总线就需要有m根，因为m位可以定义2的m次个不同的操作。



#### 5.4.2 I/O设备的连接

**输入/输出设备不能直接与连接CPU和内存的总线相连**，因为输入/输出设备的本质与内存和CPU不同，后两者是电子设备，而前者是机电、磁性或光学设备。输入/输出设备相比操作速度慢很多。因此必须要有中介来处理这种差异，通过一种被称为输入/输出控制器或接口的器件连接到总线上。

连接输入/输出设备到总线上，每一个输入/输出设备都有一个特定的控制器。控制器清除了输入/输出设备与CPU及内存在本质上的障碍，控制器可以是串行或并行的设备。

```properties
•串行控制器
•只有一根数据线连接到设备上

•并行控制器
•有多根数据线连接到设备上，一次能同时传送多个位

•常用控制器
•SCSI、火线、USB和HDMI
```

控制器，或者说接口，可以是串行或并行的设备。串行控制器一次只有一根数据线连接到设备，并行控制器则有数根数据线，使得一次能传送多个位。

（1）SCSI 并行接口

（2）火线 串行接口

（3）USB（通行串行总线）

多个设备可以被连接到一个USB接口上，这个控制器也被称为根集线器。



#### 5.4.3 输入/输出设备的寻址

通常CPU使用相同的总线在主存和输入/输出设备之间读写数据。**唯一不同的是指令**。如果指令涉及到主存中的字，那么数据就会在主存和CPU之间传输。如果指令涉及到输入/输出设备，那么数据会在输入/

输出设备和CPU之间传输。

##### 1.I/O独立寻址

用来读写内存的指令和输入/输出设备的指令是完全不同。有**专门的指令完成对输入/输出设备的操作**，每个输入/输出设备有自己的地址。**输入/输出设备地址可以和内存地址相同。**

通过不同的指令+地址，来决定是读取IO设备还是内存。

![image-20211108170705175](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211108170705175.webp)

##### 2.I/O存储器映射寻址

CPU将输入/输出控制器中的**每一个寄存器都看成是内存中的某个字**，即没有单独的指令来操作内存或输入输出设备。

```properties
优点
CPU有较小的指令集，对内存操作的指令也可以操作输入/输出设备

缺点	
输入/输出控制器也占用了一部分内存地址
```

![image-20211108170724548](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211108170724548.webp)





### 5.5 程序执行

通用计算机使用称为程序的一系列指令来处理数据。通过执行程序，将输入数据转换为输出数据。程序和数据都放在内存中。

#### 5.5.1 机器周期

CPU利用**重复的机器周期**来执行程序中的指令，一步一条，从开始到结束。一个周期包括3步：**取指令-->译码-->执行**

##### 1.取指令

控制单元命令系统**将下一条要执行的指令复制到CPU的指令寄存器(IR)中**，被复制的**指令的地址保存在程序计数器(PC)**中。复制完成后，程序计数器自动加1指向内存中的下一条指令。

##### 2.译码

当指令置于寄存器后，控制单元进行译码，得到可以执行的二进制代码。

##### 3.执行

**控制单元发送任务命令到CPU的某个部件。**例如，控制单元告知系统，让它从内存中读数据。这就是执行阶段。



#### 5.5.2 输入/输出操作

计算机需要通过命令把数据从I/O设备传输到CPU和内存，因为I/O设备的运行速度比CPU慢得多，因此CPU的操作在某种程度上必须和I/O设备同步。

##### 1.程序控制输入/输出

采用最简单的同步，**CPU等待I/O设备**。缺点：CPU需要不时地检查设备状态，影响 CPU的性能。

> 形容：老板发一个任务让员工做，员工准备的比较慢，然后老板每隔一段时间来问一下。当员工准备好了，老板就把手中的总线操作权交给员工来处理。

##### 2.中断控制输入/输出

首先CPU**告知**I/O设备即将开始传输，但是CPU并不需不停地查询I/O设备的状态。**当I/O设备准备好了，它通知（中断）CPU**。在这种方法中CPU没有被浪费。

> 形容：老板发一个任务让员工做，然后做自己的事去了，当员工准备好了，就通知老板。老板监听到了员工的报告，中断手中的总线操作权交给员工来处理。

##### 3.直接存储器存取（DMA）

这种方法需要一个DMA来承担CPU的一些功能，主要用于高速I/O设备传输大量的数据，如硬盘。优点：CPU工作效率很高。缺点：需要增加DMA控制硬件

> 形容：老板发任务给女秘书(DMA)，然后做自己的事去了，然后秘书需要通知员工什么的。当DMA准备好之后，通知老板可以做了。老板监听到DMA的通知后，中断总线控制权，交给DMA操作。即：老板发任务秘书 -> 秘书挨个通知员工准备做某事 -> 通知老板准备完毕 -> 老板将任务执行权给秘书 ->任务执行完毕 ->老板结果执行权继续做某事







### 5.6 不同的体系结构

#### 5.6.1 CISC

CISI（复杂指令集计算机）体系结构的设计策略是使用**大量的指令，包括复杂指令**。

> 优点：**程序设计更容易**，因为每个简单的或复杂的任务都有一条对应的指令。程序员不需要写一大堆的指令去完成复杂的任务
>
> 缺点：指令集的复杂性使得CPU和控制单元**电路非常复杂**
>
> 优化方案：程序在两个层面上运行，CPU不直接执行**机器语言指令**，CPU只执行被称为**微操作**的简单操作，复杂指令被转化为一系列简单操作后由CPU执行，使用微操作的程序设计被称为**微程序设计**。
>
> 应用：英特尔公司开发的**奔腾系列CPU**



#### 5.6.2 RISC

RISC（精简指令集计算机）体系结构的设计策略是使用**少量的指令**完成最少的简单操作。

> 缺点：程序设计更难，复杂指令需要用简单指令模拟



#### 5.6.3 流水线

计算机对每条指令使用**取指令、译码和执行**三个阶段，早期计算机每条指令的这三个阶段需要**串行完成**，现代计算机使用流水线技术改善**吞吐量**（单位时间内完成的指令总数）。

如果控制单元能同时执行两个或三个阶段，那么下一条指令就可以在前一条指令完成前开始。

![image-20211109101835726](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109101835726.webp)



#### 5.6.4 并行处理

计算机传统上有单个控制单元、单个算术逻辑单元、单个内存单元。现代计算机有多个控制单元、多个算术逻辑单元、多个内存单元，**每一个控制单元都能单独处理指令**，这种思想称为并行处理，并行处理能**改善吞吐量。**

并行处理可以发生在**数据流、指令流**或两者都有。

![image-20211109101939055](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109101939055.webp)

##### 1.SISD组织（单指令流，单数据流）

表示计算机有**一个**控制单元、**一个**算术逻辑单元和**一个**内存单元，指令被**顺序执行**，每条指令可以存取数据流中的一个或多个数据项。

![image-20211109102024313](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109102024313.webp)

##### 2. SIMD组织（单指令流，多数据流）

表示计算机有**一个**控制单元、**多个算术逻辑单元**和**一个**内存单元，所有处理器单元从控制单元**接收相同的指令**，但在不同的数据项上操作

![image-20211109102152174](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109102152174.webp)

##### 3. MISD组织（多指令流，单数据流）

多指令流的多个指令作用于相同的数据项，**MISD组织从未被实现**

##### 4. MIMD组织（多指令流，多数据流）

**多指令流**的**多个指令**作用于**多个数据流**（每条指令作用于一个数据项）——**MIMD组织被现代计算机实现**

![image-20211109102315813](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109102315813.webp)

> 参考：现代CPU有多个核心数(如4核8线程)，而每个核心中，有三大件(运算器、控制器)，相互独立的读取指令，每个核心读取一条，这样也提高了吞吐量。







### 5.7 简单计算机(重)

简单计算机有三部分组成：CPU、存储器、输入/输出子系统

#### **CPU**

•数据寄存器：**16个**16位的数据寄存器R0到R15 (每个寄存器也有地址，2^4^>=16，只需要4位就可以存下寄存器的地址了)

•控制单元：有两个专用寄存器，**程序计数器PC**和**指令寄存器IR**

> 程序计数器PC，只含有8位，保存的是**下一条被执行的指令的内存存储单元地址**，在每一个机器周期后，程序计数器加1，指向下一条指令
>
> 指令寄存器IR，含有16位，保存当前机器周期译码的指令



#### 主存

•有**256个16位**的存储单元，二进制的地址空间为(00000000\~11111101)~2~或是十六进制的**(00\~FD)~16~**

•主存中既有数据又有程序，**前64个存储单元(00\~3F)~16~被专用于程序指令**，任何程序的程序指令存储在连续的内存单元中，**内存单元(40\~FD)~16~用来存储数据**

> 16位应该是代表每一个存储单元的大小



#### 输入/输出子系统

子系统由一个键盘和显示器组成，子系统通过**内存映射地址**（I/O存储器映射寻址），它们的地址分别为**(FE)~16~和(FF)~16~**

> 即总共256个空间大小，00-3F给程序指令，40-FD用来存储数据，FE|FF给IO设备

![image-20211109104443706](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109104443706.webp)



#### 指令集

•有16条指令集合的能力，每条计算机指令由两部分组成：**操作码**（opcode）和**操作数**（operand）

•操作码：在操作数上执行的操作类型

•每条指令由**16位组成**，被分为**4个4位的域**，**最左边的域含有操作码**，**其他3个域含有操作数或操作数的地址**

![image-20211109105749983](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109105749983.webp)



![image-20211109105753907](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109105753907.webp)



![image-20211109105839225](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109105839225.webp)



![image-20211109105843953](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109105843953.webp)

> 解读HALT指令：当取指令译码后，发现操作数为0，将执行停止程序执行的操作
>
> 解读LOAD指令：取指令译码，操作码为1，执行load。将内存M的数据复制到寄存器R中
>
> 解读ADDI指令：操作码为３，执行addi，将寄存器R1与R2的值相加后存入目标寄存器空间



#### 处理指令

简单计算机使用机器周期（取指令、译码和执行）

•取指令阶段：**其地址由PC**决定的指令**从内存中**得到，**装入IR**中，然后**PC加1**，指向下一条指令

•译码阶段：**IR中**的指令被**译码**，所需的**操作数**从寄存器或内存中取到

•执行阶段：**指令被执行**，结果被放入合适的内存单元或寄存器中

> 一旦第三个阶段结束，控制单元又开始新的机器周期，现在PC是指向下一条指令的，处理过程一直继续，直到CPU遇到**HALT指令**。



#### 示例(重)

> 如何进行整数A和B相加，结果为C，假定整数是二进制补码格式C=A+B
> 1. 先把A、B存放在寄存器R0和R1中，操作的结果存在R2中
> 2. ALU只能操作存储在CPU数据寄存器中的数据，但是在CPU中只有有限的寄存器，如果数据量很大，并且数据在程序执行过程中应该保留在计算机中，比较好的方法是把它们存在内存中，临时地把它们调入寄存器中。
> 3. 假定A、B存储在内存单元地址(40)~16~和(41)~16~，结果C被存在内存单元(42)~16~，则A、B需要被调入CPU中，结果C存在内存中

完成这个简单的加法需要5条指令

![image-20211109114134368](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109114134368.webp)

> **ALU只能操作存储在CPU数据寄存器中的数据**，相加是由ALU操作的
>
> 简单说就是：操作数在内存中需要计算。将内存中的操作数1、2分别装入寄存器；通过ALU计算出结果放到寄存器2中；然后将寄存器2(结果值)放到内存中，然后停止操作。

5条指令被译码为

![image-20211109114232840](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109114232840.webp)

> 注意：存储的都是地址，前4位表操作码，后12位根据操作码的不同划分的区域不同(但存的还是操作数地址)
>
> 第一条指令译码：(1040)~16~，(1)代表load指令，(0)代表目标寄存器是R0地址，(40)代表内存M40的地址。将M40地址的值取出来，存入到R0寄存器中。
>
> 第三条指令译码：(3201)~16~，(3)ADDI指令，(系统看到这个指令估计就直接将后12位再分3块)，(2)目标寄存器地址R2，(0)寄存器0地址，(1)寄存器1地址。将R0与R1值取出，通过ALU计算后的值存入到R2中。

为了遵循冯-诺依曼模型，把程序和数据存储在内存中

•**程序**存储在内存单元地址(00)~16~到(04)~16~，共5行指令

•**数据**存储在内存单元地址(40)~16~、(41)~16~和(42)~16~中



#### 指令周期(重, 细解示例)

##### 1. 周期1：

 开始时，PC指向程序的第一条指令，它在内存单元(00)~16~中，**控制单元**经历3个步骤

> •取出存储在内存单元(00)~16~中的指令，放入到IR中，PC的值加1(指向下一个地址)
> •译码指令(1040)~16~为R0<--M40
> •执行指令，存储在内存单元(40)~16~中的整数的副本被装入寄存器R0中(即复制一份内存单元数据到寄存器)

![image-20211109133644977](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109133644977.webp)

> 译码那里应该是 R0 <--- M40





##### 2. 周期2：

 开始时，PC指向程序的第二条指令，它在内存单元(01)~16~中，控制单元经历3个步骤：

> •取出存储内存单元(01)~16~中的指令，放入到IR中，PC的值加1
> •译码指令(1141)~16~为R1<-- M41
> •执行指令，存储在内存单元(41)~16~中的整数的副本被装入寄存器R1中

![image-20211109133850564](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109133850564.webp)



##### 3. 周期3：

 开始时，PC指向程序的第三条指令，它在内存单元(02)~16~中，控制单元经历3个步骤

> •取出存储内存单元(02)~16~中的指令，放入到IR中，PC的值加1
> •译码指令(3201)~16~为R2<--R0+R1
> •执行指令，寄存器R0的内容被加到寄存器R1的内容上（由ALU完成），结果放在R2中

![image-20211109133959019](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109133959019.webp)



##### 4. 周期4：

 开始时，PC指向程序的第四条指令，它在内存单元(03)~16~中，控制单元经历3个步骤

> •取出存储内存单元(03)~16~中的指令，放入IR中，PC的值加1
> •译码指令(2422)~16~为M42<--R2
> •执行指令，寄存器R2中整数的副本被存储到内存单元(42)~16~中

![image-20211109134033272](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109134033272.webp)



##### 5. 周期5：

 开始时，PC指向程序的第五条指令，它在内存单元(04)~16~中，控制单元经历3个步骤

> •取出存储内存单元(04)~16~中的指令，放入到IR中，PC的值加1
> •译码指令(0000)~16~为HALT
> •执行指令，计算机停止

![image-20211109134100917](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109134100917.webp)