---
title: 计算机科学导论（第3版）_2
date: 2023-01-29 10:41:02
permalink: /pages/3e50f5/
categories:
  - studynotes
  - 计算机基础
  - 计算机导论
tags:
  - 
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---
## 第6章 计算机网络和因特网

网络：是一系列可用于通信的设备相互连接构成的

设备：

```properties
-  主机（终端），如台式机、笔记本电脑、工作站、手机等
-  连接设备
	-  路由器：将一个网络与另一个网络相连
	-  交换机：将不同设备连接在一起
	-  调制调节器：可以改变数据形式
```

### 6.1 网络分类

- 局域网（LAN）通常是与单个办公室、建筑或校园内的几个主机相连的私有网络

- 在一个局域网中，每台主机都有作为这台主机在局域网中唯一定义的一个标识和一个地址

- 一台主机向另一台主机发送的数据包中包括**源主机**和**目标主机的地址**

- 局域网将主机相连，广域网则将交换机、路由器或调制调节器之类的连接设备互连

- 局域网为机构私有，广域网则有通信公司创建并运营

**广域网**

- 点对点广域网：通过传输媒介（电缆或无线）连接两个通信设备的网络

- 交换广域网：**至少两个端**的网络，交换广域网用于当今全球通信的骨干网，是几个点对点广域网通 过开关连接产生的结合体

![image-20211109135916902](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109135916902.webp)

两个或多个网络（通常是局域网和广域网）相互连接时，它们构成一个互联网络（网际网）

> 骨干网：在顶层，为**通信公司拥有**，通过一些复杂的交换系统相互连接，这些交换系统称为**网络对等汇点**
>
> 供应商网络：在第二层，规模较小的网络，**付费使用骨干网**上的一些服务，与骨干网相连,有时也连接其他供应商网络
>
> 客户网络：在边缘，真正使用基于因特网服务的网络，**向供应商网络付费**得到服务
>
> 骨干网和供应商网络也被称为**因特网服务供应商（ISP）**，骨干网被称为**国际因特网服务供应商**，供应商网络被称为**国内或地域性因特网服务供应商**

![image-20211109140232162](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109140232162.webp)



### 6.2 协议分层

- 协议：定义了发送器、接收器以及**所有中间设备**必须遵循的以保证有效**通信的规则**

- **协议分层**：简单的通信可能只需要一条简单的协议，当通信变得复杂，可能需要将任务分配到不同的协议层，那么在**每一个协议层都需要一个协议**

- 协议分层可以将大任务简化成几个**更小、更简单的任务**。优点：可以将服务和实施分开，每层使用更低层的服务，并向较高一层提供服务

#### 6.2.1 协议分层的原则

- 第一条原则：想要达到**双向通信**，需要保证每一个协议层都可以进行两个对立且方向相反的工作

- 第二条原则：两个站点中每一层的**两个对象**必须**完全相同**，如两个站点中第三层的对象都是明文信件，第二层对象都是密文信件，第一层都是一封信



#### 6.2.2 TCP/IP协议族

- 因特网中使用的协议集（一组通过不同分层进行组织的协议）被称为TCP/IP协议族

- TCP/IP协议族是一个**分层协议**，由特定功能的**交互式模块**组成，层次这个术语说明每一个高层协议都基于一个或多个底层协议提供服务

![image-20211109145322401](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109145322401.webp)

- 每个设备涉及的层组都由其在网络上扮演的角色所涉及的层组决定，两台主机涉及**5个协议层**，源主机A在**应用层**创建消息通过协议层向下发送到**物理层**，目标主机B在物理层接收消息，通其他协议层发送至应用层

- 路由器只涉及3个层，路由器只用来路由，没有传输层和应用层。链路层开关只涉及2个层：数据链路层和物理层

任何涉及**两步校验的通信**需要两个地址：**源地址和目标地址**。每个协议层都需要一组地址，但物理层不需要地址，因为物理层的数据交换的单位是**位**，无法得到地址

```properties
- 应用层：使用名称来定义提供服务的站点，如jzstudio.com或邮箱地址等
- 传输层：地址被称为端口号，端口号作用是在源和目标之间定义应用层程序，通过各程序的本地地址
来区分多个同时运行的本地程序
- 网络层：在整个因特网范围是全球化的，独一无二地定义了该设备与因特网的连接
- 链路层：有时称为MAC地址，每个链路层地址在计算机网络中定义一个特定的主机或路由器
```

![image-20211109145601448](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109145601448.webp)



##### 1. 应用层

应用层是协议层中的最高层，应用层不向其他协议层提供服务，只接收传输层协议提供的服务。

**应用层模式：**
客户机—服务器模式（Client/Server模式）
万维网（WWW、web）和它的超文本传输协议（HTTP）、文件传输协议（FTP）、安全外壳协议（SSH）、邮件服务等

```properties
服务器端程序需要一直运行，客户端程序只在需要的时候运行
客户端不能提供服务
服务器端通信负荷压力大，服务器费用昂贵
```

端到端模式（P2P模式）

```properties
不需要一个一直运行并等待客户端程序连接的服务器程序
终端可以同时提供服务也可以接收服务
易于扩展，不需要专门的服务器，分散服务器压力，成本低
安全性相对要差
适应性差，并不是所有的应用都可以使用端对端模式
```



##### 2. 标准化C/S应用

###### 1. 超文本传输协议（HTTP）

```properties
分布式：分布在世界上的每一个Web服务器都可以往这个存储库中添加新的网页
超文本：文档中链接的另一个文档，可以检索到被链接的文档，编辑这种文档的语言称为HTML（超文本标记语言）
站点：客户通过浏览器访问服务器的服务，提供的服务分布在许多地方，称为站点
网页：每个站点存储一个或多个文档称为网页，每个网页之间可以通过超文本进行链接
```

![image-20211109153257301](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109153257301.webp)

**客户端（浏览器）**

```properties
控制器：接收键盘或鼠标的输入，使用客户端程序存取文档，在文档被存取后，控制器使用一个解释器在屏幕上显示文档
客户端协议：HTTP协议、FTP协议等
解释器：HTML、Java、JavaScript等
```

**服务器**：存储网页，每当客户端请求到达时，相应的文档会发送至客户端

**统一资源定位器（URL）**：作为文件，网页需要唯一的标识来区分

```properties
协议：HTTP、FTP等
主机：服务器的IP地址或域名
端口号：服务器应用程序的预定义的16位整数
路径：在服务器操作系统中文件目录和名字
```

**超文本传输协议（HTTP）**：是用来定义如何编写C/S程序以便于从网络中检索网页的协议，HTTP客户端发送请求，服务端返回响应，服务端使用的默认端口号为80，而客户端使用临时端口。



###### 2. 文件传输协议（FTP）

是TCP/IP提供的标准协议，用于从一台计算机复制文件到另一台计算机

```properties
客户端有三部分组成：用户接口、客户端控制进程、客户端数据传输进程
服务端有两部分组成：服务器控制进程、服务器数据传输进程
控制连接建立在控制进程间，数据连接建立在数据传输进程间
```

![image-20211109153709525](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109153709525.webp)

两个连接有不同的生命周期

-  控制连接在整个交互式FTP会话中都保持打开

-  数据连接为每个文件传输打开和关闭，每次涉及使用文件传输命令时，它就打开，文件传输结束后，它就关闭



###### 3. 电子邮件

![image-20211109154529823](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109154529823.webp)

> UA：用户代理，如浏览器
>
> 一个邮件服务器包含了发送邮件的流程，肯定也会包含接收邮件的流程。只是图中没表现出来而已



###### 4. TELNET和SSH

```properties
TELNET（Terminal Network）
终端网络，最早的远程登录协议之一
	TELNET以明文的（没有加密）发送所有数据，包括密码，不安全

SSH（安全外壳）
是一个可以用作多个目的（如远程登录和文件传输）的安全应用程序
最初是为了替代TELNET而设计
```



###### 5. 域名系统（DNS）

- 使用IP地址唯一的标识主机与网络之间的连接，但是我们更愿意使用名字而不是数字化的地址，需要一个可以将名称映射到地址的目录系统。dns是域名与IP地址的一一对应映射关系

```properties
中央目录系统
早期中央目录系统承担所有的映射工作，随着计算机网络的发展，中央目录系统压力很大，一旦出现故障，整个通信网络就会瘫痪。

分布式目录系统
将目录映射的工作分布到世界上的很多专门的计算机上
```

域名分层：第一部分定义组织的本质；第二部分定义组织的名称；第三部分定义组织中的部门。

在网络中，域名空间（树）分为三个不同部分：

* 一般域
* 国家域
*  反向域：作用是设置IP地址时找到该主机的名称，由于随着网络的快速发展，跟踪反向域变得极为困难，**已不再使用**





##### 3. 传输层

传输层服务：提供**进程间通信**，一个进程是使用传输层服务的应用层实体（运行中的程序）

> 传输层的责任是将消息送抵相应的进程

端口号作用：是用于**区分进程**，在TCP/IP协议中端口号范围是**0~65535（16位）**

> 从windows上，随便打开一个本地应用，就会启动一个进程，分配随机的端口号。而服务端上的进程端口号一般是不会变化的。应该有的软件有固定的端口号。

###### 1. 用户数据报协议（UDP协议）

不可靠的**无连接传输协议**，是一个极其简单同时**开销最少**的协议。

用户数据报：有一个固定大小为8字节的头，由于UDP用户数据报是存储在总长度为65535字节的IP数据报中的，所以整体长度比较短。

![image-20211109164307566](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109164307566.webp)



###### 2. 传输控制协议（TCP协议）

面向连接的**可靠协议**，明确定义了连接设施、数据传输和连接拆卸段以提供面向连接的服务

> 面向连接的服务：来自应用层的同一消息中所以数据包（段）之间有连接（关联）
>
> TCP使用序列号来定义段的顺序，序列号与的每一段的字节数有关

段： TCP协议将一些字节组合成一个叫做段的数据包，在每一段之前加上一个**头**（目的是方便控制），并将这些段发送到网络层进行传输，这些段都封装在IP数据报里

![image-20211109164505895](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109164505895.webp)

```properties
tcp会判断数据可不可靠有无丢失，如果丢失要求重发数据。图片与消息传输可用tcp
udp只管把数据发过去就行了，不管接收过程有无丢失。视频与音频传输可以用udp
```





##### 4. 网络层

负责源主机到目的主机的数据传输，所有的路由器都涉及网络层。

```properties
打包：在源主机的网络层数据包中封装有效负荷（从上一层接收的数据），并且从来自目的主机网络层的数据包中解封有效负荷
负责将数据包从发送者送至接收者，同时保证数据包的内容不被改变
传输层的有效负荷可以封装在几个网络层数据包中
```

> 好像从应用层向下发送数据时，每一层都会给予一个有效头封装一下，然后在接收的时候每一层再分别解析一下

![image-20211109171208147](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109171208147.webp)

数据包传递：不可靠传递；无连接传递

![image-20211109171228010](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211109171228010.webp)

**路由**

> 网络层为将数据包从源主机传输到目的主机负责
>
> 网络层在可能的路由路线中找到**最优路线**，需要一些特定的策略来定义最优路线



###### 1. 网络层协议

网络层有很多协议，但最主要的协议是**网际协议（IP协议）**，其他协议都是辅助协议，帮助IP完成职责

> 两类网络协议：IPv4和IPv6

```properties
IPv4地址：用来标记每个设备和互联网之间的连接的标识符，也叫作网络地址，是一种32位的地址，唯一但又通用地定义了主机或路由器与网络之间的连接

IP地址是连接的地址而非主机或路由器的地址，当一个设备移到另外的网络中，它的IP地址可能会改变

IPv4地址是独一无二的，每个地址定义一个且只有一个与网络之间的连接，如果一个设备（如路由器）有多个网络连接，那么就有多个IPv4地址。
```

![image-20211110102918610](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110102918610.webp)

```properties
地址的第一部分叫做前缀，定义网络
地址的第二部分叫做后缀，定义节点（设备和网络的连接）
前缀和后缀的长度取决于网络（组织）的站点
```

- IPv4数据报：IP使用的数据包叫做数据报，数据报是一种长度不一的数据包

- 数据包包括两部分：

​		头：长度是20~60字节，包含路由和传递时必要的信息

​		有效负荷（数据）

![image-20211110103011479](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110103011479.webp)

**第6版网际协议（IPv6）**：扩大IPv4的地址空间，同时重新设计IP数据包的格式，并修改一些辅助性协议

IPv6使用128位来定义任何连接到网络中的设备。IPV6地址分级：站点（组织）、子网、连接（到主机的连接）

![image-20211110103345990](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110103345990.webp)

> 前缀找到属于哪个站点(网络)，正网标识找到网络中的具体子网，接口标识找到具体电脑





##### 5. 数据链路层

TCP/IP协议没有定义数据链路层中的任何协议。源和目标主机只包含一个数据链路层，每个路由器有两个数据链路层

> 数据链路层的通信是节点对节点的

**有线LAN：以太网**：数据发送以帧的形式

> 帧：包含负荷（数据）、源地址（6字节）、目的地址（6字节）、数据类型（2字节）、循环校验位（4位，校验数据完整性）

![image-20211110112219391](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110112219391.webp)

无线LAN：空气作为传输媒介，通过**电磁波**传播。有两种技术：无线以太网和蓝牙

```properties
无线以太网（WiFi，wireless fidelity）定义了两种服务：基本服务集（BSS）和扩展服务集（ESS）

蓝牙
用于连接不同功能的设备，如电话、笔记本、照相机、打印机等
蓝牙发覆盖范围有限
应用：无线鼠标、无线键盘、蓝牙音箱等
```





##### 6. 物理层

从数据链路层接收的位转换成用于传输的电磁信号，信号通过媒介进行传输。

![image-20211110112445979](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110112445979.webp)

> 模拟信号通过采样就成了模拟数据

**数字化传输(有线传输)：**

**数数转换技术：将数字数据转换为数字信号的方法**

![image-20211110112517132](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110112517132.webp)

**模数转换技术：将模拟数据转换为数字信号的方法**

![image-20211110112535432](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110112535432.webp)

**模拟传输(wifi)，即无线传输**

**数模转换技术：基于数字数据的信息改变模拟信号的某个特征的过程**

![image-20211110112702350](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110112702350.webp)

**模模转换技术：基于模拟数据的信息改变模拟信号的某个特征的过程**

![image-20211110112716747](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110112716747.webp)

在物理层产生的电子信号需要传输介质来从一端传输到另一端。传输介质通常在物理层之下，并且受到物理层的直接控制

![image-20211110113015740](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110113015740.webp)

```properties
传输介质分为两大类：
导向介质：双绞线、同轴电缆、光纤

无导向介质：自由空间（电磁波）
	不通过物理上的导体来传播电磁波，即无线通信，信号通常在自由空间中传播，任何有能接收信号的设备都能使用
```

![image-20211110113115166](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110113115166.webp)





## 第7章 操作系统

### 7.1 操作系统的定义与自举

```properties
计算机系统由两个主要部分组成：硬件和软件
硬件：计算机物理设备
软件：使硬件能够正常工作的程序集合
	操作系统：控制计算机系统用户对硬件的访问
	应用程序：使用计算机硬件来解决用户问题
```

定义：操作系统是**计算机硬件**和**用户**（程序和人）的一个接口，它使得其他程序更加方便有效地运行，并能方便地对计算机硬件和软件资源进行访问

操作系统的两个主要目标：有效使用硬件； 有效使用资源

#### 7.1.1 操作系统调入内存的自举过程

操作系统负责把其他程序装入内存，以便运行，但是操作系统本身也是程序，也需要装入内存和运行，这个问题如何解决？

![image-20211110114750485](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110114750485.webp)

> 使用ROM技术把操作系统存储（由制造商完成）在内存中，即可解决。
>
> 首先内存(RAM)断电清空所有数据，PC指向0了。可将操作系统通过**ROM技术**(断电不清空)存储在内存中，此时内存就有了操作系统的程序指令，PC指向了它就可以执行从而运行操作系统了。
>
> 但是操作系统很大，所以ROM只存储操作系统的一部分程序(启动程序)，然后PC执行了ROM的这块自举程序，操作系统就启动起来，然后操作系统自己将需要用到的数据加载到内存，然后就可以引导一些软件的启动，然后其他软件就可以在操作系统上启动。





### 7.2 操作系统的演化

#### 7.2.1 批处理系统

早期的操作系统，用穿孔卡进行输入数据，行式打印机输出结果，磁带作为存储设备

**每一个要运行的程序叫做一个作业**。它们保证计算机所有资源从一个作业转换到另一个作业

> 当执行某个作业时 所有的资源都给此作业来使用，所以作业们需要排队。



#### 7.2.2 分时系统

为了有效的使用资源，**多道程序的概念**被引入。它可以**将多个作业同时装入内存**，并且仅当该资源可用时分配给需要它的作业。

- 多道程序的分时概念：资源可以被不同的作业分享。每个作业可以分到一段时间来使用资源。

> 在单CPU的电脑中，多个任务同时被加载到内存，然后CPU会在每个时钟期限执行某个任务，然后切换到下个任务执行。由于CPU执行速度，切换速度过快，从而让我们以为是并行执行的，其实对于CPU还是串行执行。

**调度**：给不同的程序分配资源并决定哪一个程序什么时候使用哪一种资源

**进程**：一个作业是一个要运行的程序，一个进程则是在**内存中等待分配资源的程序**(运行中的程序)



#### 7.2.3 个人系统

单用户操作系统，如DOS（磁盘操作系统）

> 可能如表明意思，只能有单个用户登录和执行操作系统



#### 7.2.4 并行系统

在同一计算机中安装了**多个CPU**，每个CPU可以处理一个程序或者一个程序的一部分，意味着很多任务可以**并行处理**而**不再是串行处理**，当然比单CPU的操作系统复杂得多。

> 并行系统也是分时系统，不过比分时多了几个CPU。这样的话，每个CPU在一定的时钟期限内执行，未被执行的作业。



#### 7.2.5 分布式系统

网络和互联网的发展，扩大了操作系统的内涵，一个运行的作业可以由相隔千里的多台计算机共同完成。程序可以在一台计算机上运行一部分而在另一台计算机上运行另一部分

> 即，可以将一个比较大的作业分成几个部分，通过网络，可能由许多不同地区的许多计算机运行作业的不同部分计算结果。从而提高效率



#### 7.2.6 实时系统

指在特定**时间限制内**完成任务





### 7.3 操作系统的组成部分

**用户界面**：用来接收用户（程序）的输入并向操作系统解释这些请求的程序

一些操作系统（如Unix、Linux）的用户界面，被称作命令解释程序（Shell），在Windows中则称为窗口

#### 7.3.1 存储管理(内存管理)

内存管理器：分为单道程序和多道程序

> 单道程序：大多数内存用来装载**单一**的程序，整个程序装入内存运行，运行结束后，程序区域由其他程序取代
>
> 问题：1. 程序必须能够载入内存，如果内存容量比程序小，程序无法运行
>
> 2. 当一个程序正在运行时，其他程序不能运行，一个程序经常需要从输入设备得到数据，并且把数据发送至输出设备。但输入/输出设备的速度远远小于CPU，当输入/输出设备运行时，CPU处于空闲状态，而此时其他程序不在内存中，CPU不能为其服务，性能很低

```properties
多道程序：同一时刻可以装入多个程序到内存，并且能同时被执行CPU轮流为其服务

多道程序的分类
	非交换：程序在运行期间始终驻留在内存中
        分区调度
        分页调度
	交换：在运行过程中，程序可以在内存和硬盘之间多次交换数据
        请求分页调度
        请求分段调度
        请求分页和分段调度
```

> 非交换：当多个程序加载到内存，会将多个程序的整个指令代码全部加载到内存

##### 1. 非交换多道程序

###### 1. 分区调度

内存被分为不定长的几个分区，每个分区保存一个程序，CPU在各个程序间交替服务

![image-20211110142641772](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110142641772.webp)

```properties
每个程序完全载入内存，并占用连续的地址，分区调度改进了单道CPU的执行效率，但还有以下问题：
1.分区大小必须由内存管理器预先决定，分区小了程序装不进，分区大了出现空闲区
2.即使分区在刚开始分配合理，但随着新程序的交换载入内存后可能出现空闲区
3.当空闲区过多时，内存管理器能够紧缩分区并删除空闲去和创建新区，但会增加系统额外开销
```



###### 2. 分页调度

内存被分成大小相等的若干个部分，称为**帧**，程序被分为大小相等的部分，称为**页**，通常**帧和页的大小一样**

> 程序在内存中不必是连续的
>
> 问题：分页调度在一定程度上提高了效率，但整个程序任然需要**全部载入内存**运行

![image-20211110143556697](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110143556697.webp)





##### 2. 交换多道程序

###### 1. 请求分页调度

程序被分成页，但页可以依次载入内存运行和替换，程序**不需要全部载入内存**

来自同一个程序的连续页可以不必载入同一个帧，一个页可以载入任何一个空闲帧

![image-20211110143950124](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110143950124.webp)

>跟分页调度相比，区别就是没有一次性将程序全部载入内存，这样增加了内存的利用率。将程序分为几页，当执行完一页后，此帧就是空闲状态，就可以请求下一段页加载进来



###### 2. 请求分段调度

程序通常由主程序和子程序组成，程序将按程序员的角度划分为**段**，它们载入内存中执行，然后被来自同一程序或其他程序的模块所替代

![image-20211110144836069](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110144836069.webp)



###### 3. 请求分页和分段调度

- 请求分页和分段调度：结合了两者的优点以提高系统效率。

- 一个段可能太大而不能载入内存中的空闲区，内存可以分成很多帧，一个模块可以分成很多页，依次装入内存执行

> 大概就是，将段也分成页，然后依次装入内存执行吧





##### 3 虚拟内存

- 在请求分页调度和请求分段调度时，一部分程序驻留在内存中，一部分程序则放在硬盘上

![image-20211110144956127](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110144956127.webp)

> 执行任务时，如果内存足够就会一次性将作业加载到内存。如果内存不够，会在磁盘上开辟一段虚拟内存，物理内存加载一部分，虚拟内存加载一部分。这个请求交换主要就是物理内存与虚拟内存相互交换的。即物理内存执行完后，请求虚拟内存交换下一帧任务。







#### 7.3.2 进程管理

##### 1. 程序、作业和进程

- 程序：是由程序员编写的一组稳定的指令，存在磁盘上，它可能会也可能不会成为**作业**

- 作业：从一个程序被选中执行，到其运行结束并再次成为一个程序的这段过程中，该程序称为作业

- 进程：是一个运行中的程序，该程序开始运行但还未结束，**只要作业装入内存就成为进程**

> 程序时程序员编写的一组指令，没有被运行就只能被称为程序
>
> 当执行某个程序，程序会先由程序变成一个作业，然后等待被os装入到内存。当作业一旦装入到内存就可称为进程了



##### 2. 程序、作业和进程之间的状态图

![image-20211110154713835](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110154713835.webp)

> 当作业A通过作业调度器从保持状态变成就绪状态，即装入内存成为进程A。如果cpu在执行其他程序，等时间片耗尽才会执行下一帧程序(分时系统)。只有被CPU执行时才由就绪状态变为运行状态，当CPU执行的时间片被耗尽，会重新进入就绪状态。(进程之间的竞争)
>
> 如果CPU执行程序A，需要调用IO请求打印，如果打印机没准备之类的，程序A会主动放弃CPU执行权进入等待状态，等打印机准备好了，重新进入就绪状态等cpu分配时间片。当程序A所有的指令代码全部执行完毕，就进入了退出状态



##### 3. 调度器

将一个作业或进程**从一个状态**改**变为另一个状态**，进程管理器使用了两个调度器

- 作业调度器：将一个作业从**保持状态**转入**就绪状态**，或从**运行状态**转入**终止状态**

![image-20211110155831952](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110155831952.webp)

- 进程调度器：实现进程状态之间的转换

![image-20211110155838231](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110155838231.webp)



##### 4. 队列

很多作业和进程相互竞争计算机资源，为处理多个进程和作业，**进程管理器使用队列（等待列表）**

- 与每个作业或进程相关的是存有这些作业和进程信息的**作业控制块**和**进程控制块**

- 队列中存的不是作业和进程本身，而是**作业块或进程块**，作业或进程仍保存在内存或硬盘中

> 如：银行办业务，排队只需要取一个信息，然后就可以随便休息了，并不需要站窗口排队，所以这些个作业块或进程块存储的是标识信息



操作系统可以有多个队列，如作业和进程在三个队列里循环：作业队列、就绪队列、和I/O队列

```properties
作业队列：保存等待内存的作业
就绪队列：保存已在内存中准备好运行但在等待CPU的进程
I/O队列：保存正在等待I/O设备的进程（可以有多个I/O队列）
```

进程管理器可以用**多种策略**从队列中选择下一个作业或进程执行，可以是先入先出（FIFO）、最短时间优先、最高优先级等

![image-20211110161236943](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211110161236943.webp)

> 注意：队列里面存的是，作业块或进程块，即作业或进程的标识信息，实际上的作业或进程仍保存在内存或硬盘中。这个图的执行与状态图差不多，只是多了个队列的展示，执行过程还是差不多的



##### 5. 进程同步

所有进程管理的思想都是使的拥有不同资源的不同进程同步，只要资源可以被**多个进程同时使用**，那么它就可能有两种有问题的状态：**死锁**和**饿死**

###### 1. 死锁

发生在操作系统允许一个进程运行，而不用首先检查它所需资源是否准备好，是否允许这个进程占有资源直到它不需要为止

```properties
死锁解决方案：
方案一：当所需资源不空闲时，不允许进程运行
方案二：限制进程占有资源的时间
```

死锁的4个必要条件：(**只要破坏其中一条，可以避免死锁**)

```properties
互斥：一个资源只能被一个进程占用
资源占用：一个进程占有一个资源，即使在获取其他资源之前无法使用它
抢先：操作系统不能临时对资源重新分配
循环等待：所有的进程和资源包含在一个循环里
```

###### 2. 饿死

当操作系统对进程分配资源有太多限制时，该进程可能饿死





#### 7.3.3 设备管理

设备管理器负责访问输入/输出设备。文件管理器控制对文件的访问

主流的操作系统：Unix、Linux、Windows





## 第8章 算法





## 第9章 程序设计语言

### 9.1 演化与翻译

#### 9.1.1 演化

**计算机语言**是指编写程序时，根据事先定义的**规则（语法）**而写出预定语句集合

**机器语言**：计算机发展早期，唯一的 程序设计语言是机器语言，每一台计算机有其自己的机器语言，这种机器语言由0和1序列组成

**计算机唯一能识别的语言是机器语言**

```properties
依赖于计算机
编写程序容易出错  
```

**汇编语言**：**带符号或助记符**的指令和地址代替二进制码的机器语言

> **汇编语言最终要翻译成机器语言执行**

![image-20211111095549273](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111095549273.webp)

**高级语言**：高级语言可以移植到不同的机器上，编写理解简单

高级语言和汇编语言有一个**共性**：必须**转化为机器语言**，这个转化过程称为**解释或编译**



#### 9.1.2 翻译

当今程序通常是用一种高级语言来编写，为了在计算机上运行程序，程序要被**翻译成**它要运行的在计算机的**机器语言**

- 高级语言程序被称为**源程序**，**被翻译成的机器语言程序称为目标程序**

- 有两种方法用于翻译：**编译**和**解释**

##### 1. 编译

**编译程序**（编译器）通常把**整个源程序**翻译成**目标程序**。只需要编译一次就行



##### 2. 解释

有些计算机语言使用**解释器**把源程序翻译成目标程序。翻译一行执行一行。

> 解释是指把源程序中的**每一行翻译**成目标程序中相应的行，**并执行**它的过程

```properties
解释中的两种趋势
	在Java语言之前被有些程序使用的解释
	Java使用的解释
```

###### 1. 第一种解释

源程序的每一行被翻译成被其使用的计算机上的机器语言，该机器语言被**立即执行**

如果在翻译和执行中有任何错误，过程就显示消息，其余过程就被终止，程序需要被改正，再次从头解释和执行

第一种方法被看成是一种**慢**的过程，这就是大多数语言使用编译而不是解释的原因

###### 2. Java的解释过程

随着Java的到来，一种新的解释过程被引入。Java语言能向任何计算机移植，为了取得**可移植性**，源程序到目标程序的翻译分成两步进行：**编译和解释**

**Java源程序**首先被编译成**Java的字节码**，字节码看起来像机器语言中的代码，但不是任何特定计算机的目标代码，它是一种**虚拟机的目标代码**，该虚拟机称为Java虚拟机（JVM），

字节码能被任何运行JVM的计算机编译和解释

> Java源代码->Java的字节码(虽然是01串，但cpu不认得)，然后通过jvm解释成cpu可识别的机器码
>
> java字节码又称为中间码





#### 9.1.3 翻译过程(如何从源->目标)

编译和解释的不同在于，**编译**在执行前翻译整个源代码，而**解释**一次只翻译和执行源代码中的一行，但编译和解释都遵循**相同的翻译过程**

![image-20211111102459617](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111102459617.webp)

**词法分析器**：
	一个符号接一个符号地读源代码，创建源程序中的**助记符表**
	如5个符号w、h、i、l、e被读入，组合起来就形成了C、C++或Java中的助记符while

**语法分析器**：
	分析一组助记符，找出指令
	如语法分析器使用助记符 “x”、“=”、“0”创建C语言中的赋值语句“x=0”

**语义分析器**：检查语法分析器创建的句子，确保它们**不含二义性**

**代码生成器**：在无二义性指令被语义分析器创建之后，每条指令将**转化为**一组要在其上运行的计算机的**机器语言**





### 9.2 编程模式

模式是计算机语言看待要解决问题的一种方式

- 计算机语言可以分成4种模式：1. 过程性（强制性）；2. 面向对象；3. 函数式；4. 说明式

![image-20211111103950441](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111103950441.webp)

**过程模式**：大概就是 做什么东西，都需要自己去完成与实现。反正看C是咋样，就行了

**面向对象模式**：三大特性：封装、继承、多态

> 我个人理解 面向过程：对数据的操作和数据的定义是分开的，每种数据有不同的操作过程 ；面向对象：数据的操作和数据的定义是放在一起的，一个对象包含对数据的操作和对象的定义，使用该对象时可以触发相应的操作



**函数式模式**：程序被看成是一个**数学函数**，函数是把一组输入映射到一组输出的黑盒子。

- 主要实现以下功能

​	函数式语言**预定义**一系列可供任何程序员调用的**原始（原子）函数**

​	函数式语言允许程序员**通过若干个原始函数的组合创建新的函数**

![image-20211111105417852](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111105417852.webp)

> 通过多个原始函数，组合组装成新的函数。
>
> first原始函数是取列表的第一个元素，rest原始函数是取列表除第一个元素外的所有元素。所以我们可以通过这两个原始函数组合成一个新的函数，取列表任意位置的元素

**一些函数式语言**

- LIST：表处理解释语言，是一种把表作为处理对象的语言

- Scheme：定义了一系列原始函数来解决问题。函数名和函数的输入列表写在括号内，结果是一个可用于其他函数输入的列表



**说明式模式**：依据**逻辑推理**的原则响应查询

说明性语言有自生的缺憾，就是有关特殊领域的程序由于要**收集大量的事实**信息而变得非常庞大。

说明性语言迄今为止**只局限于人工智能领域**

![image-20211111110401562](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111110401562.webp)





### 9.3 共同概念

**标识符**：![image-20211111114331514](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111114331514.webp)

**数据类型**：定义了一系列值及应用于这些值的一系列操作。

- 简单数据类型：（有时称为原子类型、基本类型）是**不能分解成更小数据类型**的数据类型

```properties
整数类型：不包括小数部分 的整数
实数类型：带小数部分的数字
字符类型：被语言使用的潜在字符集（ASCII或Unicode）中的符号
布尔类型：只取两个值（真或假）的数据类型
```

- 复合数据类型：是**一组**元素，其中每个元素都是简单数据类型或复合数据类型

```properties
数组：是一组元素，其中每个元素具有相同类型
记录(对象)：是一组元素，其中的元素可以具有不同类型
```



**变量**：是存储单元的名字，每个内存单元在计算机中都有一个地址，虽然计算机内部使用地址，但对程序员而言却不方便，使用变量来代替地址，变量具有数据类型。

> 大多数语言要求变量**先声明后使用**。声明告诉计算机被赋予名字和类型的变量将在程序中使用。计算机预留出要求的存储区域，并命名它

- 字面值：是程序中使用的预定义的值。根据这个值就知道是什么类型，干什么用的

- 常量：是一个可以存储值的命名的位置，但常量在程序开始处被定义后就不能改变



**输入和输出**：几乎所有的程序都需要输入或输出数据，大多数程序设计语言使用一些**预先定义好的函数**完成输入和输出







## 第10章 软件工程

软件工程是建立在这样一个基础上，即**利用合理的工程方法**和**原则**来获得在真实机器上工作的**可靠软件**

### 10.1 软件生命周期

![image-20211111140006154](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111140006154.webp)





### 10.2 开发过程

开发过程包括4个阶段：分析、设计、实现和测试

- 最常见的两种开发过程模型：瀑布模型、增量模型（迭代模型）

#### 10.2.1 开发过程模型

##### 1. 瀑布模型

开发过程只有一个方向的流动，这意味着**前一个阶段不结束，后一个阶段不能开始**

> 优点：在下一个阶段开始前每个阶段已经完成
>
> 缺点：如果过程中一部分有问题，必须检查整个过程

##### 2. 增量模型（迭代）

软件的开发要经历一系列步骤。开发者首先完成整个系统的一个**简化版本**，这个版本表示了整个系统，但不包括具体的细节。

第二个版本中，更多的细节被加入，而有些还没完成，然后再次测试系统。如果这时有问题，开发者知道问题出于新功能。直到现有系统工作正确后，才增加新的功能，这个过程一直继续下去，直到所有功能全部被加入





#### 10.2.2 分析阶段

分析阶段：整个开发过程始于分析阶段，这个阶段生成规格说明文档，这个文档说了软件要做什么，而没有说明如何去做

分析阶段的两种独立方法

- 面向过程分析：依赖于实现阶段使用过程编程语言

- 面向对象分析：依赖于实现阶段使用面向对象编程语言

##### 1. 面向过程分析

如果实现阶段使用过程式语言，那么面向过程分析（也称为结构化分析或经典分析）就是分析阶段使用的方法。

这种情况下的规格说明有使用多种建模工具

```properties
数据流图
实体关系图（在第12章再讨论）
状态图
```

###### 1. 数据流图

![image-20211111141741110](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111141741110.webp)



###### 2. 状态图

![image-20211111141802787](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111141802787.webp)



##### 2. 面向对象分析

如果实现阶段使用面向对象语言，那么面向对象分析就是分析阶段使用的方法。

###### 1. 用例图

![image-20211111143116834](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111143116834.webp)

###### 2. 类图与状态图

![image-20211111143157355](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111143157355.webp)





#### 10.2.3 设计阶段

设计阶段定义系统**如何完成**在分析阶段所定义的需求。在设计阶段，系统所有的**组成部分**都被定义。

面向过程设计中，既要设计过程，也要设计数据，整个系统被分解成一组过程或**模块**

- 结构图：说明**模块间关系**的常用工具

![image-20211111143359904](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111143359904.webp)

##### 1. 面向过程设计

模块化：将大项目分解成较小的部分，以便能容易理解和处理，当系统被分解成模块时，主要关心两点：**耦合和内聚**

- 耦合：是对两个模块**相互绑定紧密程度**的度量，越紧耦合的模块，独立性越差，所以设计时，尽量**松散耦合**

```properties
松散耦合的模块更可能被重用
松散耦合的模块不容易在相关模块中产生错误
系统需要修改时，松散耦合只需要修改一部分模块，而不影响其他模块
```

**软件系统中模块间的耦合必须最小化**

- 内聚：是程序中**处理过程相关紧密度**的度量。软件系统模块间的内聚必须最大化

**高内聚松耦合**



##### 2. 面向对象设计

在面向对象设计中，设计阶段通过详细描述**类的细节**来继续

- 类是由一组变量（属性）和一组方法组成，面向对象设计阶段列出这些属性和方法细节

![image-20211111143619496](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111143619496.webp)





#### 10.2.4 实现阶段

- 语言的选择

- 软件质量

![image-20211111144142264](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111144142264.webp)



#### 10.2.5 测试阶段

测试阶段的目的就是**发现错误（bug）**，良好的测试策略能发现**最多的错误**

##### 1. 白盒测试（或玻璃盒测试）

- 基于知道软件内部结构的。测试的目的是检查软件所有部分是否全部设计出来，白盒测试假定测试者知道有关软件的一切，程序就像一个玻璃盒子，其中的每件事情都是可见的。

- 白盒测试的4个标准

```properties
每个模块中的所有独立的路径至少被测试过一次
所有的判断结构（两路或多路的）每个分支都被测试
每个循环都被测试
所有数据结构都被测试
```

- 基本路径测试是一种软件中每条语句至少被执行一次的方法

![image-20211111150622031](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111150622031.webp)

- 控制结构测试

![image-20211111150638741](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111150638741.webp)

##### 2. 黑盒测试

在不知道程序的内部也不知道程序是怎么工作的情况下测试程序，程序就像一个**看不见内部的黑盒**，**黑盒测试按照软件应该完成的功能来测试**

```properties
穷尽测试：最好的黑盒测试方法就是输入域中的所有可能的值去测试软件
随机测试：选择输入域的值的子集来测试，子集的选择方式是非常重要的。功能很多的话费时间，这个就是抽取比较重要的功能来测试
边界测试：范围的边界测试，比如金钱：看看能不能输入负数。
```





### 10.3文档

用户文档，系统文档，技术文档





## 第11章 数据结构





## 第12章 抽象数据类型

- 抽象数据类型（ADT，Abstract Data Type）：定义**数据类型和对数据的操作**，包含了一组对数据操作的定义，而数据和操作的实现是隐藏的（封装）

- 抽象数据类型的模型

![image-20211111154429116](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111154429116.webp)

### 12.1 限制线性表

栈：先进后出

队列：先进先出



### 12.2 广义线性表

没有被限制的线性表(类似与数组了)

广义表的特性(也是与数组等普通线性表的区分)

```properties
元素具有相同的类型
元素顺序排列，意味着有第一个元素和最后一个元素
除第一个元素外，每个元素都有唯一的前驱，除最后一个元素外，每个元素都有唯一的后继
每个元素是一个带有关键字段的记录
元素按关键字值排序
```

- 插入操作：由于广义线性表中的数据是有序的，那么插入元素必须保持顺序





## 第13章 文件结构

文件存储在辅助存储设备或二级存储设备中，如磁盘和磁带等

在设计一个文件时，关键问题是**如何从文件中检索信息**（一个特定的记录），有时需要一个接一个处理记录，有时需要快速存取特定数据

### 13.1 存取方法

#### 13.1.1 顺序存取

如果需要顺序存取记录（一个接一个，从头到尾），使用**顺序文件结构**。一个一个记录的找，效率慢。

##### 1. 顺序文件

顺序文件：记录只能按照顺序从头到尾一个接一个地进行存取

- EOF：文件末尾标志

![image-20211111160335024](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111160335024.webp)

##### 2. 更新顺序文件的过程(有点意思)

顺序文件需要定期更新，以反映信息的变化

```properties
需要更新的文件：和更新相关的4个文件
    - 新主文件：新的永久数据文件
    - 旧主文件：需要更新的永久文件
    - 事务文件：包含对主文件的改变
        - 添加事务：包含将要追加到主文件中的新数据
        - 删除事务：将要从文件中删除的记录标记出来
        - 更改事务：包含对文件特定记录的修改
	- 错误报告文件：文件更新过程中出现的错误清单
```

![image-20211111160500917](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111160500917.webp)

> 旧主文件：需要被更新的文件。例如一个100条学生记录的文件，需要新增一个学生。这个100条学生记录的文件就是旧主文件
>
> 事务文件：对旧主文件的更新操作。添加事务：例如，新增学生小明到旧主文件.....
>
> 错误报告文件：事务记录更新失败从而生成的文件
>
> 新主文件：在当前事务中，旧主文件被更新完毕后保存的文件。当进入下个事务(想下次更新文件时，新主文件就变成了旧主文件)

- **键**：文件中一个或多个能**唯一标识**数据的字段

```properties
文件更新过程：要使文件更新过程有效率，所有文件都必须按同一个键排序，步骤：
    1，如果事务文件的键小于主文件的键，事务就是增加（A），则将事务增加到新文件中
    2，如果事务文件的键与主文件相同，则
        a 如果事务是修改（C）则修改主文件数据
        b 如果事务是删除（D）则将数据从主文件中删除
    3，如果事务文件的键大于主文件的键，将旧文件记录写入新主文件
    4，错误报告：事务添加新文件的键已存在旧文件，事务修改或删除的键不存在旧文件
```

![image-20211111161816312](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111161816312.webp)

> 旧主文件更新过程图解：1. 事务文件对旧主文件进行更新操作，首先旧主文件中是按照键的顺序排序的。图中旧主文件以按照键的顺序排序了
>
> 2.读取事务文件，(操作+键)，发现是A(增加)31，表示需要在旧主文件中添加一个记录，其键为31，会在旧主文件中寻找比31小的键，然后将此记录添加到后面。
>
> 3.读取事务文件第二行，C25，表示修改旧主文件记录，会去旧主文件中寻找键为25的记录，并替代。
>
> 最后事务文件更新完旧主文件后，生成的就是新主文件，其文件中键还是保持着顺序的





#### 13.1.2 随机存取

如果需要存取某一个特定记录而不用检索之前的所有记录，则使用随机存取的文件结构

有两种文件结构都允许随机存取：**索引文件**和**散列文件**

##### 1. 索引文件

- 在文件中随机存取记录，需要知道记录的地址

- **索引文件**由**数据文件**组成，它是**带索引的顺序文件**，索引本身非常小，只占两个字段：顺**序文件的键和磁盘的相应记录的地址**

![image-20211111170157901](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111170157901.webp)



![image-20211111170207913](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211111170207913.webp)

> 索引文件的数据文件类似于顺序文件，有键(但键可以是不排序的)，有记录。在额外的索引文件中，键必须是排序的，索引文件中存储着记录的键与地址值。
>
> 通过(比如折半查找)找到了记录对应的键，然后直接通过键对应的地址值去数据文件中拿到对应记录。从而进行修改，打到随机存取的效果



##### 2. 散列文件

- 散列文件用一个**数学函数（散列函数/哈希函数）**来完成映射，用户给出一个键(key)，**函数将键映射成地址**

- 散列文件无需额外的索引文件

![image-20211112101528400](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112101528400.webp)

> 索引文件的方式：需要一个索引文件和一个数据文件共存，会先将索引文件载入内存，然后根据索引文件索引到的地址去数据文件中取值。
>
> 散列函数需要**通过key算出地址值** 也需要通过地址值得出原来的key

**散列方法**

###### 1. 直接散列法(一般不用)：

 键是未经算法处理的数据文件地址。**即直接将文件的key映射为地址值**，一般不会这么搞

缺点：地址空间浪费

![image-20211112101709070](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112101709070.webp)

###### 2. 求模法（除余散列法）

用文件大小去除键后，将余数加1作为地址值：address = (key mod listSize ) + 1

尽量使用**素数作为列表的大小**，将产生更少的冲突

![image-20211112101910695](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112101910695.webp)

> 这个listSize是自己定义的素数。素数：只能被1和它本身整除的数

###### 3. 数字析取散列法

选择**键**中析取的数字作为地址，如从6位的学号中析取3位地址（000~999），可以选择（从左数）第一、第三和第四位数作为地址，如下

**1**2**58**70 --> 158

**1**2**28**01 --> 128

###### 4. 散列地址冲突

冲突的产生是在散列算法为插入键产生地址时，发现该地址已被占用。

![image-20211112103536764](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112103536764.webp)

**(1) 解决冲突：开放寻址(一般不用)**

 把要插入的数据存储在下一个地址（地址+1）

![image-20211112103608841](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112103608841.webp)

**(2) 解决冲突：链表解决法(Java的Map)**

![image-20211112103716378](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112103716378.webp)

> 参考Java8之前的Map结构，就是**数组串链表**。如果地址冲突了，那么就在冲突的地址那里串链表。Java8的Map结构是，如果链表长度超过了8，就会转为红黑树

**(3) 解决冲突：桶散列法(类似链表解决法)**

![image-20211112104129817](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112104129817.webp)

> 把链表串的形式，改为了存放在一个桶中，即某个桶中存放了地址为214的所有冲突记录。不过涉及到桶的都比较耗内存空间







### 13.2 目录

- 目录是大多数操作系统提供的，用来组织文件

- 在大多数操作系统中，**目录被组织成像树**的抽象数据类型（ADT）

```properties
UNIX中操作系统中的目录
    根目录：文件系统层次结构最高层
    主目录：每个用户都有一个主目录
    工作目录：即当前目录
    父目录：是工作目录的直接上层目录
```

![image-20211112105210634](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112105210634.webp)

- 路径和路径名：文件系统的每个目录和文件都必须有一个名字

- 有些文件与其他目录的文件具有相同的名字，为了唯一的标识一个文件，需要指明从根目录到文件的文件路径

- 绝对路径：根目录到文件的文件路径

- 相对路径：相对于工作目录的文件路径



**文本文件**：通过字符集解析

**二进制文件**：图像、音频、视频、**文本**等

![image-20211112105301800](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112105301800.webp)







## 第14章 数据库

### 14.1 数据库管理系统

**DBMS（Database Manager System）**是定义、创建、维护数据库的一种**工具**，DBMS允许用户来控制数据库中数据的存取

```properties
DBMS由5部分组成：
    - 硬件：物理上存取数据的计算机硬件
    - 软件：用户存取、维护和更新物理数据的实际程序
    - 数据（库）：数据是独立于软件的一个实体
    - 用户
        - 最终用户：数据库管理员DBA和普通用户
        - 应用程序
    - 规程
```

![image-20211112112449590](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112112449590.webp)

> 我们平常安装的MySQL属于DBMS，只是现在的DBMS都绑定了DB而已。DB实质上只是一些文件。
>
> DB没了就真没了；DBMS没了，DB还在的话，重新安装个DBMS就行





### 14.2 数据库体系结构

- 美国国家标准协会/标准计划和需求委员会（**ANSI**/SPARC）为数据库管理系统建立了**三层体系结构：内层、概念层和外层**

![image-20211112113225801](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112113225801.webp)

> **内层**：决定了数据在存储设备中的实际位置，处理底层的数据存取方法和如何在存储设备间传输字节，**内层直接与硬件交互**
>
> **概念层**：定义数据的**逻辑视图**DBMS的主要功能（如**增删改查**）都在该层，概念层是中介层，使得用户不必与内层打交道
>
> **外层**：**直接与用户（最终用户或应用程序）交互**，将来自概念层的数据转化为用户熟悉的格式和视图







### 14.3 数据库模型

数据库模型定义了数据的逻辑设计，描述了不同数据之间的联系

#### 14.3.1 层次模型(过时)

**层次模型：数据被组织成一棵倒置的树**，每个**实体**可以有不同的节点，但只能有一个双亲，层次的最顶端有一个实体，称为根。

**层次模型已过时，不再描述**

![image-20211112114254789](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112114254789.webp)

> 一个实体对应一张表



#### 14.3.2 网状模型(过时)

网状模型：**实体**通过**图**来组织。图中的部分实体可以通过多条路径来访问

**网状模型已过时，不再描述**

![image-20211112114426710](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112114426710.webp)





#### 14.3.3 关系模型(重点)

- 在关系数据库模型中，数据是通过**关系的集合**来表示的，从表面上看，**关系就是二维表**，数据的外部视图是关系和表的集合，但不代表数据以表的形式存储，数据的物理存储与数据的逻辑组织方式毫无关系

```properties
关系的特征
    名称：每种关系都有唯一的名称
    属性(字段)：关系中的每一列都称为属性，属性在表中是列的头，关系中属性的总数称为关系的度
    元组(记录)：关系中的行叫做元组，元组定义了一组属性值
```

关系(表)的操作

​	- 插入、删除、更新、选择/查询、投影、连接、并、交、差

​	- 这些操作通过数据库查询语言SQL（结构化查询语言）来定义





### 14.4 数据库设计

#### 14.4.1 E-R图

#### 14.4.2 规范化







## 第15章 数据压缩

数据压缩：通过部分**消除**数据中内在的**冗余**来减少发送或存储的数据量

- 压缩方法分为无损压缩和有损压缩

![image-20211112143315011](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112143315011.webp)

### 15.1 无损压缩

在无损压缩中，数据的**完整性**是受到保护的，原始数据与压缩和解压后的数据**完全一样**

压缩和解压算法是完全相反的两个过程，在处理过程中没有数据丢失，冗余数据在压缩时被删除，在解压时再被加回去

-  三种无损压缩方法：**游程长度编码、赫夫曼编码、LZ算法**

#### 15.1.1 游程长度编码

用来压缩由任何符号组成的数据，当数据中由0和1表示时十分有效

- 思想：将数据中**连续重复出现的符号用一个字符和这个字符重复的次数来代替**，如AAAAAAAA用A08来代替

![image-20211112143506971](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112143506971.webp)

> 对于一些不是连续重复的字符，就没必要用这个了，可能会出现越压缩越大的情况

![image-20211112143638322](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112143638322.webp)

> 如果只记录0个个数，不晓得1的各种情况该如何处理？
>
> 这里将14个连续的0的个数 14化为二进制进行存储。如果是16个0，采用两个4位二进制存储：1111(15)  0001(1) =>16。如果是40个0，采用3个4位二进制存储。



#### 15.1.2 赫夫曼编码(重)

对**出现更为频繁**的字符分配较短的编码，对出现较少的字符分配较长的编码

- 示例：假设一篇文章只有ABCDE五个字符组成

![image-20211112145626321](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112145626321.webp)

- 步骤

**1，构造赫夫曼树。找出权值最小的两个节点合成第三个节点**

![image-20211112145657186](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112145657186.webp)

**2，给各个字符分配编码，从根开始，给左分支分配0，右分支分配1**

![image-20211112145723762](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112145723762.webp)

> 这个编码系统中，没有一个编码是其他编码的前缀**（无二义性）**
>
> 无二义性表示，读取解码时只会找到唯一的对应。例：每读一位去编码表匹配，找到了唯一的对应就展示。如读00，直接对应了A，如果读的去编码表匹配不到，多读1位去匹配。如读01，没对应，再读1位，010，对应到了B。

**3，编码**

![image-20211112150214866](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112150214866.webp)

**4，译码**

![image-20211112150243001](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112150243001.webp)

> **赫夫曼编码是一种即时编码**
>
> 假如，小明给小红发消息，小明通过赫夫曼压缩信息后通过数据包传到小红电脑上。小红可以每读一位就译码成对应的字符，如果没译码到，多接收1位再次译码。无需等小明将所有的字符数据包传送过来才译码，小明一边传小红可以一边译码。







#### 15.1.3 LZ编码(有点意思)

**压缩和解压都是需要自己建立字典及其字典索引的**

Lempel Ziv编码：（由Abraham Lempel和Jacob Ziv命名）是**基于字典的编码**，在通信的时候如果它将产生一个字符串字典（一个表），如果接收和发送双方都有这样的字典，那么字符串可以由字典中的**索引**代替，以减少通信的数据传输量

> 将要压缩的字符转换为字典并创建索引，然后通过字典的索引进行替代。难点：如何生成字典？
>
> 容易理解的例子：一本新华字典，“你”索引为“101”，“好”->“121”，那么“你好”=>"101 121"



- 示例：对字符串BAABABBBAABBBBAA进行LZ编码

- Lempel Ziv压缩：需要**建立字典索引和压缩字符串。**

> 算法从**未压缩的字符串**中选取**最小的子字符串**，这些子字符串在字典中**不存在**
>
> 然后将子字符串复制到字典中并**分配索引值**
>
> 压缩时，除了**最后一个字母外**，其他所有字符被字典中的**索引替代**
>
> 然后将索引和最后一个字母插入压缩字符串

- **Lempel Ziv压缩图解**

![image-20211112152743307](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112152743307.webp)



![image-20211112152718670](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112152718670.webp)

> 1.首先**在未压缩的字符串中寻找最小的子字符串**。即从"BAABABBBAABBBBAA"找最小的子字符串"B"，将其存入字典并记录索引。-- 压缩了第一个字符
>
> 2.从"AABABBBAABBBBAA"找最小子字符串(因为第一个B已经压缩完了)。"A"存入字典并记录索引。--压缩了第二个字符
>
> 3.从"ABABBBAABBBBAA"找最小子字符串。发现A已经存在于字典索引为2，找"AB"不存在于字典。然后将其存入字典，记录索引。同时在压缩后的字符显示为**(除最后一个字符，其余字符用字典索引替代)**，即"AB"存于字典为："AB"=>3，压缩后为：2(索引)B => 字典索引2存的是A。



**Lempel Ziv解压**：是压缩的**逆过程**，从压缩字符串中取出子字符串，尝试按照字典中所列出的记录还原相应的索引号为对应的字符串

字典开始为空，之后会逐渐的建立起来，当索引号被接收时，在字典中已经存在了相应的记录



- Lempel Ziv解压图解

![image-20211112154226138](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112154226138.webp)

> 没索引直接插字典并生成索引并解压。如果有索引，通过索引找到对应字符，然后存入字典并生成索引，并解压。
>
> 读取"B"，字典中没有，插入字典并生成索引并解压为"B"。"A"也是一样。
>
> 读取"2B"，索引为2，去字典通过索引找到对应字符为A，然后插入到字典并生成索引：AB=>3，并将其解码为"AB"





### 15.2 有损压缩(不明白原理)

- 联合图像专家组（JPEG）用来压缩图片和图像

- 运动图像专家组（MPEG）用来压缩视频

- MPEG第三代音频压缩格式（MP3）用来压缩声音

> 哎，JZ没讲，看书又不懂，有数学公式





## 第16章 安全

### 16.1 引言

安全目标：机密性、完全性和可用性

- 攻击：三个安全目标会受到安全攻击的威胁，按照安全目标将攻击分为三类

![image-20211112155943014](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112155943014.webp)



![image-20211112163605135](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112163605135.webp)



![image-20211112160150907](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112160150907.webp)



![image-20211112160155778](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112160155778.webp)



![image-20211112160201611](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112160201611.webp)

**应对：**

1. 密码术：将一些容易看懂并猜测的，经过特定规则的混淆和扰乱，从而变得难以猜测。
2. 隐写术：在消息上覆盖其他内容而隐藏消息。如一段文字，藏在了一张普通的图片里面。



### 16.2 机密性

密码术可以分为两大类：对称秘钥密码术和非对称秘钥密码术

#### 16.2.1 对称秘钥密码术

使用同一个秘钥进行加密和解密，并且这个秘钥可以用来进行双向通信

![image-20211112160545799](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112160545799.webp)

- 我们把加密和解密的算法称为**密码**

- **秘钥**是密码（一个算法）操作中的一组值（数字）

- 对称秘钥密码对**加密和解密**使用**同一个秘钥**

```properties
加密算法和解密算法时互逆的
    - 如果P是明文，C是密文，K是秘钥，加密算法Ek(x)从明文建立了密文，而解密算法Dk(x)从密文建立了明文
    - 推断Ek(x)和Dk(x)是互逆的：如果对一个输入依次施加Ek(x)和Dk(x)，它们的作用会相互抵消，则：
        - 加密：C=Ek(P)	解密：P=Dk(C) --加密原文变成密文后，此密文必定可以解密成原文
        - Dk(Ek(x)) = Ek(Dk(x))=x 
```

**对称秘钥密码分成两大类：传统对称秘钥密码和现代对称秘钥密码**



##### 1. 传统对称秘钥密码

###### 1. 替换密码

**用一个符号替换另一个符号**，如果在明文中的符号是字母表的字符，用另一个字符来代替，如使用字母D代替字母A，替换密码分为：**单字母密码**和**多字母密码**

> 如：love，使用z来替代l，=>zove
>
> 如果出现频率过高，容易猜测出原文。毕竟字母表就26个。



**单字母密码**

明文中相同的字符在密文中用相同的字符替换，与该字符在明文中的位置无关，明文和密文中的字符关系是一一对应的。

- 最简单的单字母密码就是加法密码，假设明文由小写字母（a~z）构成，密文中包括大写字母（A~Z），为了使数学的计算操作可以施加在明文和密文上，向每一个字母（无论大小写）都进行赋值

![image-20211112162214236](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112162214236.webp)

- 每个字母都赋予了一个模26中的整数

![image-20211112163746110](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112163746110.webp)

**解密：**

![image-20211112162317439](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112162317439.webp)

> 加密规则可以自己定义，这个是比较简单的一种加密方式了。



**多字母密码**

- **字符每一次出现都使用不同的替换码**，明文中字符和密文中字符的关系是**一对多**，如“a”可以在文本开头加密成“D”，也可以在中间加密成“N”

- 多字母密码具有隐藏原有语言的字母频率的作用，及时通过单字母频率统计都无法破解密文

```properties
每个密文字符的确定不仅取决于相对应的明文字符，还与该明文字符在原来文本中的位置有关，这意味着秘钥应该是"子秘钥流"，子秘钥流中的每一个子秘钥都在某种程度上取决于使用该子秘钥进行加密的明文字符的位置，换句话说，我们需要有一个秘钥流k=（k1，k2，k3...），在这里ki用来对明文中第i项的字符加密并创造密文中的第i项字符
```



例子：

- 为了更好解释秘钥的位置依赖性，先讨论一个叫做**自动秘钥密码**的**简单多字母密码**，在这个密码中，秘钥是一个子秘钥流，子秘钥流中的每一个子秘钥都用来对明文文本中的对应字符进行加密

- 第一个子秘钥是Alice和Bob事先同意并秘密设定的值，第二个子秘钥是明文中第一个字符的值（0~25之间对应字母的a-z），第三个子秘钥是第二个明文字符的值，依次类推

![image-20211112163320374](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112163320374.webp)

- 自动秘钥密码说明了这些**秘钥都是在加密过程中通过明文密码字符自动创造的**

![image-20211112164508536](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211112164508536.webp)

> 本次的多字母加密规则为：除第一次密钥规定为k=12，后续的密钥规定为上一次原文字符的值。然后相加取模得到加密后的字符。其明文密文字符数字对应参照图16-4



###### 2. 移位密码

不是用一个符号代替另一个符号，而是**改变符号的位置**。

- 明文第一个位置上的符号可能出现在密文的第十个位置上，而明文第八个位置上的符号可能出现在密文中的第一个位置上，换言之，**移位密码就是符号的重新排序**

- 假设Alice需要向Bob发送消息“Enemy attacks tonight”，加密和解密过程如图

<!-- 在消息的末尾加上一个额外的字符（z）这样字符个数就是5的倍数 -->

![image-20211115091444386](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115091444386.webp)

> 加密过程是，先摆成矩阵形式(一行一行的写)，将第3列数据放到第1列，第1列数据放到第2列。然后(一列一列的读)成为一串密文

![image-20211115092700138](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115092700138.webp)



![image-20211115092706443](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115092706443.webp)



##### 2. 现代对称秘钥密码

![image-20211115094451364](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115094451364.webp)

> 传统是面对字符的加密，现代是面向bit流的加密

###### 1. 现代分组密码

![image-20211115094608456](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115094608456.webp)

> i like xuan 每个字符是8bit的话。需要8*9=72bit，如果一个分组为512位，会补充信息到512位。如果需要加密513bit，会分为两个512位的分组。

###### 2. 现代流密码

![image-20211115094614974](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115094614974.webp)



![image-20211115094828321](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115094828321.webp)



![image-20211115094834347](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115094834347.webp)





#### 16.2.2 非对称秘钥密码术

- 在**对称秘钥密码术**中，**秘钥必须在双方之间共享**，在**非对称秘钥密码术**中，**秘钥是个人独有**（非共享）的，每个人创造并保守个人的秘钥

- 与对称秘钥密码术基于符号（字符或位）的替换和排列不同，非对称秘钥密码术基于**数学函数**在数字上的应用

- 在对称秘钥密码术中，明文和密文被看作符号的组合，加密和解密是对这些符号的排列和替换，在非对称秘钥密码术中，明文和密文都是**数字**，加密和解密的过程是对数字应用数学函数创造其他数字的过程

<!-- 将明文转换为数字，然后对数字进行加密 -->

- 在非对称秘钥密码术中使用两个分开的秘钥：**私钥和公钥**

![image-20211115100303524](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115100303524.webp)



![image-20211115100313239](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115100313239.webp)

> 公钥上锁，私钥解锁。
>
> Bob先生成公钥与私钥信息，然后将公钥分发到通道，以便别人可以给自己发信息。当Alice拿到公钥之后，用此公钥对明文加密，然后就能发给Bob。而Bob的私钥就是用来解锁公钥锁住的东东。
>
> 这个过程，由于私钥全程在自己手上，当公钥或明文被截取到。他人也无法破译出来(私钥才能解锁)，也无法进行篡改，因为私钥只能解锁自己统一生成的公钥加密信息。

- 非对称秘钥密码术意味着Bob只需要一个私钥就能从团体中的任何人那里接收信息。但Alice需要n个公钥与团体中的n个人进行通信，一人一个公钥，总之Alice需要一个公钥环

> 即，每跟不同的人通信，都需要拿到对方的公钥才行。同时对多个人通信，需要拿到多人的公钥，从而组成一个公钥环。

- 明文/密文：与对称秘钥密码术不同，在非对称秘钥密码术中，明文和密文被当作整数来看待。非对称秘钥密码术通常用来加密或解密**小段信息**

<!-- 非对称加密比对称加密慢 -->

- 加密/解密：密文可以被看成C=f(K~public~ , P)，明文可以被看成g(K~private~ , C)

> 密文 = 加密算法(公钥, 明文)     明文=解锁(私钥, 密文)



##### 1.RSA 密码系统

![image-20211115102305427](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115102305427.webp)



![image-20211115102319166](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115102319166.webp)



![image-20211115102323346](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115102323346.webp)

> Bob先随便选两素数，然后通过计算，再随便选择满足公式的e与d。此时Bob的公钥就是n和e可以分享给任何人，而d作为自己的私钥。

![image-20211115102532932](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115102532932.webp)







### 16.3 消息完整性

- 消息和消息摘要：保证文档的完整性的一种方法是通过指纹，文档和指纹的电子等价物就消息和摘要对比

#### 16.3.1 密码散列函数

- 为了保证消息完整性，消息要通过一个称为**密码散列函数**的算法，函数建立消息的压缩影像称为**摘要**

**消息摘要需要保证安全，免受篡改**

![image-20211115103249046](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115103249046.webp)

> 将消息发给Bob，然后将消息通过散列函数生成的摘要通过非对称加密的方式，传给Bob。Bob收到消息后，通过同一个散列函数生成的摘要与Alice发过来的摘要进行对比，如果不一致，就说明消息被篡改了。

![image-20211115103443411](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115103443411.webp)





#### 16.3.2 消息验证

![image-20211115103854011](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115103854011.webp)



#### 16.3.3 数字签名

- 数字签名：保证消息完整性和消息验证，使用一组公私钥，签名对接收者来说是文档来自正确实体的证据

```properties
对比普通签名和数字签名的不同点
    包括：普通签名包括在文档中，是文档的一部分，数字签名可以作为单独的文档来发送
    验证手段：普通签名接收者需要一个文件上的签名副本进行比较，是否可信任，数字签名接收者收到消息和签名，签名副本不再保存，需要使用验证技术来组合消息和签名进行验证
    关系：普通签名，一个人使用相同的签名签署许多文件，数字签名，每条消息对应它自己一个数字签名
    复制性：普通签名允许签署文档的副本与文件中的原始件有点不同，数字签名，没有这样的不同
```

- 数字签名的过程

- 发送者使用签名算法签署消息，消息和签名被发送给接收者，接收者收到消息和签名，对收到的内容应用验证算法，如果验证为真，消息被接收，否则消息被拒绝

![image-20211115104708558](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115104708558.webp)

> **密码系统使用接收者的私钥和公钥，数字签名使用发送者的私钥和公钥**，即：与非对称加密的传输刚好是相反的。
>
> 比如，在联想买了台电脑，电脑上贴着联想官方的私钥信息，联想也在官网上公布了其公钥信息。确保是不是联想官方正品，只需要拿联想公开的公钥与电脑上的私钥验证一下就知道了。





#### 16.3.4 签署摘要

- 在处理较长消息时，非对称秘钥密码系统效率低下，在数字签名系统中，消息通常较长，但我们不得不使用非对称秘钥模式，解决方案是使用**数字签名签署消息的摘要**，摘要比消息本身要短得多

![image-20211115105554889](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115105554889.webp)

- 消息验证、消息完整性、**不可抵赖性**、机密性

![image-20211115105612536](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115105612536.webp)

> 如果双方先采用同一公私钥通信，而后Alice突然重新生成了公私钥，导致原私钥失效。这就产生了抵赖性。
>
> 如：Alice找Bob(银行)借了100，(双方采用Alice的公私钥进行通信)，Alice借了之后就重新生成了公私钥，然后说，你看我没找你借钱，证据都匹配不上。
>
> 可信中心，拿到Alice的公钥，对其公钥通过算法生成可信中心的私钥，并记录Alice的公钥，然后将可信中心生成的私钥发给Bob进行验证。这样当Alice重新生成了公私钥，可信中心验证不通过，就会认为Alice做出了抵赖行为。





#### 16.4 防火墙

- 通过防火墙控制对系统的访问

- 防火墙是一个安装在一个组织的内部网络和因特网其他部分之间的设备（通常是一个路由器或计算机）

- 防火墙是为了推进一些数据包而过滤其他数据包而设计的

- 防火墙可能会**过滤**所有到来的目标为特定主机或服务器的数据包，也可以用来**阻拦**对组织内特定主机或服务的访问

![image-20211115110630071](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115110630071.webp)

##### 16.4.1 包过滤防火墙

包过滤防火墙：是一个使用**过滤表单**决定哪些数据包应该**丢弃**（不推进）的**路由器**，用作数据包过滤器，基于**网络层的信息**和**传输层的头部**：源和目标IP地址，源和目标端口地址以及协议的种类（TCP或UDP）来推进或阻拦数据包

![image-20211115110750690](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115110750690.webp)

> 1：是指过滤从外部到内部的访问。第一条规则：外部主机为131.34.0.0的ip访问内部网络时被过滤(即不允许访问)。第二条规则：不允许访问内部网络的23端口。第三条规则：不允许访问内部网络的194.78.20.8主机
>
> 2：是指过滤从内部到外部的请求。第一条规则：内部不允许访问外部的80端口



##### 16.4.2 代理防火墙

是使用代理计算机（也称为**应用网关**）基于**消息自身携带的信息**（应用层上）进行过滤，代理计算机位于客户计算机和组织计算机之间，当用户客户进程发送消息时，应用网关运行服务器进程来接收请求，服务器在应用层**打开数据包并且查找这个请求是否合法**，如果是，那么服务器运行客户端进程并将消息发给组织内真正的服务器，否则丢弃消息。外部用户的请求基于内容在应用层进行筛选

![image-20211115111753938](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115111753938.webp)

> 从外部发过的信息经过一层包过滤防火墙的筛选。进入了代理防火墙，代理防火墙会校验外部来的请求是否合法，不合法丢弃，合法就转发给真实的服务器从而成功请求数据。







## 第17章 计算理论(不甚了解)

### 17.1 简单语言(有点意思)

- 首先介绍一种语言，称为**简单语言**，通过它可以看到计算机解决任何问题所需要的**最少语句是三条**

- 介绍一种称为图灵机的计算机模型，简单语言可以解决的问题也可以通过图灵机解决

- 证明没有任何程序可以知道另一个程序终止与否：A不终止执行  B用来测试A是否会终止



#### 17.1.1 简单语言的初始条件(为了便于理解)

1. 我们可以仅用**三条语句**来定义一种语言，它们是：**递增语句**、**递减语句**和**循环语句**

   递增语句：对变量加1，如**incr(X)**

   递减语句：对变量减1，如**decr(X)**

   循环语句：在变量值不为0时，重复执行一个动作（或一系列动作），如

   ​           **while(X)**

   ​           **{**

   ​             **decr(X)**

   ​             **Body of the loop**

   ​           **}** 

2. 在该语言中，只能使用**非负整数数据类型**

3. 该语言使用少数的几个符号，如“{”和“}”



#### 17.1.2 简单语言造宏(重)

**证明**只使用三种语句的简单程序设计语言和现在使用的任何一种复杂语言（如C语言）一样强大

> 宏：三种简单语句组成的新语句

![image-20211115115207827](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115115207827.webp)



![image-20211115115348215](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115115348215.webp)



![image-20211115115358791](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115115358791.webp)



![image-20211115115404712](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115115404712.webp)



![image-20211115115416926](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115115416926.webp)



![image-20211115115421839](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115115421839.webp)



![image-20211115115426037](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115115426037.webp)





### 17.2 图灵机

图灵机由三部分组成：磁带、控制器和读/写头

![image-20211115135930375](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115135930375.webp)

- **磁带**：任何时候只能保存一系列顺序字符，该字符来自计算机所

能接收的字符集中

- 假设图灵机只能接收两个符号：**空白(b)和数字1**

左边的空白b定义整数的开始，右边空白b定义整数的结束

![image-20211115140000926](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115140000926.webp)

假设磁带处理一元算术中的正整数，在一元算术中，正整数仅由1组成，如整数4表示为1111（4个1），7表示为1111111，没有1的地方表示0

- **读/写头**：任何时刻总是指向磁带上的一个符号，我们称这个符号为当前符号，读/写头每次在磁带上读写一个符号。每读写完一次后，它向左移、向右移。读、写和移动都是在控制器的指令下进行的

- **控制器**：是理论上功能作用类似于CPU的一个部件，它是**有限状态自动机**，即该机器有预定的有限个状态并能根据输入从一个状态转移到另一个状态，但任何时刻它只能处于这些状态中的一种

![image-20211115140052226](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115140052226.webp)

- 建立一个每一行代表一个状态和状态转移表

![image-20211115140104425](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115140104425.webp)



![image-20211115140111136](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115140111136.webp)



#### 17.2.1 图灵机对简单语言的模拟

##### 1. 递增语句

**incr(X)语句的图灵机**，控制器有4个状态：从S1到S4，S1：开始状态，S2：右移状态，S3：左移状态，S4：停机状态，如果到达停机状态，机器就停止，没有指令从这个状态开始

incr(X)语句有5条指令

![image-20211115140230162](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115140230162.webp)



![image-20211115140247036](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115140247036.webp)

> 读取1位写入1位，成功的多写入了1个1(代表递增成功)，读写头会返回原点表示读写结束。



##### 2. 递减语句

**decr(X)语句的图灵机**，控制器有三个状态，S1、S2、S3，S1:开始状态，S2：**检查语句**，检查当前符号是1还是b，如果是b，语句进入停机状态，如果下一个符号是1，第二条语句把它改写成b，然后进入停机状态，S3：停机状态

![image-20211115140723378](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115140723378.webp)



![image-20211115140727425](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115140727425.webp)



##### 3. 循环语句

为了模拟循环，假定X和循环体处理的数据存储在磁带上，中间以单个空白符号相隔

- 三个状态S1、S2和S3控制循环，通判断X的值，如果**X=0**，退出循环

```properties
状态MR：把读写头移过在每次重复中在处理数据开始时定义了数据开始位置的空白符号
状态ML：把读写头移过在每次重复中在处理数据结束时定义了X的开始位置的空白符号
状态BS：定义了循环体的开始状态
状态BH：定义了循环体的停机状态
```

![image-20211115141648579](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115141648579.webp)



![image-20211115141700130](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115141700130.webp)

**邱奇-图灵论题**：如果存在一个能完成一个符号操纵任务的算法，那么也存在一台完成这个任务的图灵机

> - 这是论题不是定理。即存在一个能用简单语言完成任务的算法，那么完成这个任务也可以用图灵机实现





### 17.3 歌德尔数

在计算机科学理论中，一个无符号数能被分配给任何用特定语言编写的程序，通常称为**歌德尔数**

![image-20211115142412350](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115142412350.webp)



![image-20211115142417490](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115142417490.webp)



![image-20211115142427942](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115142427942.webp)

> 将简单语言指令转换为无符号整数的表示形式

![image-20211115142520034](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115142520034.webp)



#### 17.3.1 停机问题

- 一个典型的编程问题：我们能编写一个程序来**测试**任何可以用歌德尔数表示的程序是否会终止？

- 证明：停机问题是不可解决的

- 反证法：假设这样的测试程序存在，然后证明它的存在将产生一个矛盾。

- 第一步

![image-20211115143125080](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115143125080.webp)

> 程序P的作用是：如果P终止了，返回的x为1.如果P不会终止，返回的x为0.

- 第二步

![image-20211115143245643](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115143245643.webp)

> 程序Strange是另一个程序，它接收一个参数X(参数X从程序P的返回结果值来的)。如果X为1则程序Strange一直循环，如果x为0则不循环。
>
> 即：P程序如果终止，返回x为1，则Strange一直循环。P程序如果不终止(一直执行)，返回x为0，则Strange不会循环(不会执行)

- 第三步

![image-20211115144728890](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115144728890.webp)



#### 17.3.2 问题的复杂度

在计算机科学领域，一般来说问题可以分为两类

- **可解问题**：多项式问题；非多项式问题

- **不可解问题**：无法用计算机解决的问题无穷无尽，停机问题只是其中一个，要证明一个问题是无法解决的，方法是证明如果它可以解决，那么停机问题也同样可以解决，换句话说，证明一个问题能否解决等同于证明停机问题能否解决

- 可解问题：对于可解问题，我们关心计算机需要**花多长时间**去解决一个问题

```properties
可解问题的复杂度：衡量一个可解问题复杂度的一个方法是找出计算机运行该程序要执行的运算数量

- 大O表示法：相对于计算机速度，我们关心的是程序总体的数量级而不是精确的数字，在该表示法中，运算数量表示为输入量的函数，如符号O(n)表示有n个输入，执行n次运算，符号O(n的2次方)表示有n个输入，执行n的2次方运算
```

![image-20211115144911531](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115144911531.webp)



![image-20211115144921536](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/image-20211115144921536.webp)





## 第18章 人工智能(略)