---
title: nacos
date: 2023-01-29 14:17:23
permalink: /pages/c02184/
categories:
  - studynotes
  - 中间件
  - SpringCloudAlibaba
tags:
  - 
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---
## nacos - 配置管理

> 服务注册：每个微服务将自己注册到服务发现中心；服务发现：微服务从服务发现中心中获取对方的IP地址进行调用

### 1. 什么是配置中心 

nacos作为微服务配置中心的一种解决方案，对应用程序的配置信息进行统一管理，从而组成了一个配置中心。

#### 1.1 什么是配置 

应用程序在启动和运行的时候往往需要读取一些配置信息，配置基本上伴随着应用程序的整个生命周期，比如：数据库连接参数、启动参数等。

配置主要有以下几个特点：

- **配置是独立于程序的只读变量**
  - 配置对于程序是只读的，程序通过读取配置来改变自己的行为，但是程序不应该去改变配置
- **配置伴随应用的整个生命周期**
  - 配置贯穿于应用的整个生命周期，应用在启动时通过读取配置来初始化，在运行时根据配置调整行为。比如：启动时需要读取服务的端口号、系统在运行过程中需要读取定时策略执行定时任务等。
- **配置可以有多种加载方式**
  - 常见的有程序内部hard code，配置文件，环境变量，启动参数，基于数据库等
- **配置需要治理**
  - 同一份程序在不同的环境（开发，测试，生产）、不同的集群（如不同的数据中心）经常需要有不同的配置，所以需要有完善的环境、集群配置管理
  - 配置多，管理起来也麻烦，所以需要治理



#### 1.2 什么是配置中心

 在微服务架构中，当系统从一个单体应用，被拆分成分布式系统上一个个服务节点后，配置文件也必须跟着迁移（分割），这样配置就分散了，不仅如此，分散中还包含着冗余，如下图：

![image-20220505195019548](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505195019548.webp)

> 每个服务一份配置文件，不好管理啊。所以我们考虑将配置单独构建成一个配置中心，构建成一个配置中心，从而让其他的微服务都从配置中心中拉取、读取配置文件

下图显示了配置中心的功能，**配置中心将配置从各应用中剥离出来，对配置进行统一管理，应用自身不需要自己去管理配置。**

![image-20220505195000948](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505195000948.webp)

> 配置中心已成为了一个独立的服务了，所以从配置中心获取配置，需要通过网络协议。配置中心的配置更新后，会通知各个服务，然后各个服务就会去配置中心获取最新的配置

配置中心的服务流程如下：

- 1、用户在配置中心更新配置信息。
- 2、服务A和服务B及时得到配置更新通知，从配置中心获取配置。

**总得来说，配置中心就是一种统一管理各种应用配置的基础服务组件。**

在系统架构中，配置中心是整个微服务基础架构体系中的一个组件，如下图，它的功能看上去并不起眼，无非就是配置的管理和存取，但它是整个微服务架构中不可或缺的一环。

![image-20220505195352564](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505195352564.webp)

总结一下，在传统巨型单体应用纷纷转向细粒度微服务架构的历史进程中，配置中心是微服务化不可缺少的一个系统组件，在这种背景下中心化的配置服务即配置中心应运而生，一个合格的配置中心需要满足如下特性：

- 配置项容易读取和修改
- 分布式环境下应用配置的可管理性，即提供远程管理配置的能力
- 支持对配置的修改的检视以把控风险
- 可以查看配置修改的历史记录
- 不同部署环境下应用配置的隔离性



### 2. Nacos简介 

#### 2.1 主流配置中心对比

目前市面上用的比较多的配置中心有：Spring Cloud Conﬁg、Apollo、Nacos和Disconf等。

由于Disconf不再维护，下面主要对比一下Spring Cloud Conﬁg、Apollo和Nacos。

| 对比项目     | Spring Cloud Conﬁg     | Apollo                   | Nacos                    |
| ------------ | ---------------------- | ------------------------ | ------------------------ |
| 配置实时推送 | 支持(Spring Cloud Bus) | 支持(HTTP长轮询1s内)     | 支持(HTTP长轮询1s内)     |
| 版本管理     | 支持(Git)              | 支持                     | 支持                     |
| 配置回滚     | 支持(Git)              | 支持                     | 支持                     |
| 灰度发布     | 支持                   | 支持                     | 不支持                   |
| 权限管理     | 支持(依赖Git)          | 支持                     | 不支持                   |
| 多集群       | 支持                   | 支持                     | 支持                     |
| 多环境       | 支持                   | 支持                     | 支持                     |
| 监听查询     | 支持                   | 支持                     | 支持                     |
| 多语言       | 只支持Java             | 主流语言，提供了Open API | 主流语言，提供了Open API |
| 配置格式校验 | 不支持                 | 支持                     | 支持                     |
| 单机读(QPS)  | 7(限流所致)            | 9000                     | 15000                    |
| 单击写(QPS)  | 5(限流所致)            | 1100                     | 1800                     |
| 3节点读(QPS) | 21(限流所致)           | 27000                    | 45000                    |
| 3节点写(QPS) | 5(限流所致)            | 3300                     | 5600                     |

从配置中心角度来看，性能方面Nacos的读写性能最高，Apollo次之，Spring Cloud Conﬁg依赖Git场景不适合开放的大规模自动化运维API。功能方面Apollo最为完善，nacos具有Apollo大部分配置管理功能，而Spring Cloud Conﬁg不带运维管理界面，需要自行开发。Nacos的一大优势是整合了注册中心、配置中心功能，部署和操作相比Apollo都要直观简单，因此它简化了架构复杂度，并减轻运维及部署工作。

 综合来看，Nacos的特点和优势还是比较明显的，下面我们一起进入Nacos的世界。

 

#### 2.2 Nacos简介 

Nacos是阿里的一个开源产品，**它是针对微服务架构中的服务发现、配置管理、服务治理的综合型解决方案。**

官方介绍是这样的：

> Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您实现动态服务发现、服务配置管理、服务及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。
>
> Nacos 是构建以“服务”为中心的现代应用架构的服务基础设施。

官网地址：https://nacos.io



#### 2.3 Nacos特性 

Nacos主要提供以下四大功能：

1. **服务发现与服务健康检查**
Nacos使服务更容易注册，并通过DNS或HTTP接口发现其他服务，Nacos还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求。
2. **动态配置管理**
动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos消除了在更新配置时重新部署应用程序，这使配置的更改更加高效和灵活。
3. **动态DNS服务**
    Nacos提供基于DNS 协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以域名的方式暴露端点，让三方应用方便的查阅及发现。
4. **服务和元数据管理**
    Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略。

这里动态配置管理的特性说明了Naocs的配置管理能力。



### 3. Nacos快速入门 

#### 3.1 安装Nacos Server 

##### 3.1.1 预备环境准备 

Nacos 依赖 Java 环境来运行。如果您是从代码开始构建并运行Nacos，还需要为此配置 Maven环境，请确保是在以下版本环境中安装使用:

 ```
1. 64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。
2. 64 bit JDK 1.8+；下载 & 配置。
3. Maven 3.2.x+；下载 & 配置。
 ```

##### 3.1.2 下载源码或者安装包 

你可以通过源码和发行包两种方式来获取 Nacos。

**从 Github 上下载源码方式**

```asm
git clone https://github.com/alibaba/nacos.git
cd nacos/
mvn ‐Prelease‐nacos clean install ‐U  
ls ‐al distribution/target/
 
// change the $version to your actual path
cd distribution/target/nacos‐server‐$version/nacos/bin
```

**下载编译后压缩包方式**

您可以从 最新稳定版本 下载 `nacos-server-$version.zip` 包，本教程使用nacos-server-1.1.3版本。

下载地址：https://github.com/alibaba/nacos/releases

下载后解压：

```asm
unzip nacos‐server‐$version.zip 或者 tar ‐xvf nacos‐server‐$version.tar.gz
cd nacos/bin
```



##### 3.1.3 启动服务器 

nacos的默认端口是8848，需要保证8848默认端口没有被其他进程占用。

进入安装程序的bin目录：

**Linux/Unix/Mac**

启动命令(standalone代表着单机模式运行，非集群模式):

```asm
sh startup.sh -m standalone
```

如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：

```asm
bash startup.sh -m standalone
```

**Windows**

启动命令(standalone代表着单机模式运行，非集群模式):

```asm
startup.cmd -m standalone
```

启动成功，可通过浏览器访问 http://127.0.0.1:8848/nacos ，打开如下nacos控制台登录页面：

使用默认用户名：nacos，默认密码：nacos 登录即可打开主页面。



##### 3.1.4 OPEN API 配置管理测试 

启动nacos成功后，可通过nacos提供的http api验证nacos服务运行是否正常。下边我们通过 curl工具来测试nacos的open api：

curl 是开发中常用的命令行工具，可以用作HTTP协议测试。

本教程下载curl的windows版本：curl-7.66.0_2-win64-mingw，下载地址：https://curl.haxx.se/windows/

下载完成进入curl-7.66.0_2-win64-mingw的bin目录，进行下边的测试，通过测试可判断nacos是否正常工作：



**发布配置**

```asm
curl -X POST "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&group=test&content=HelloWorld"
```

上边的命令表示向nacos发布一个配置：

上边的命令表示向nacos发布一个配置：

![image-20220505203913099](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505203913099.webp)

> 我使用的是postman



**获取配置**

向nacos发布配置成功，就可以通过客户端从nacos获取配置信息，执行下边的命令：

```asm
curl -X GET "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&group=test"
```

通过测试发现，可以从nacos获取前边发布的配置：HelloWorld



##### 3.1.5.关闭服务器 

**Linux/Unix/Mac**

```
sh shutdown.sh
```

**Windows**

```
shutdown.cmd
```

或者双击shutdown.cmd运行文件。



##### 3.1.6.外部mysql数据库支持 

**单机模式时nacos默认使用嵌入式数据库实现数据的存储**，若想使用外部mysql存储nacos数据，需要进行以下步骤：

- 1.安装数据库，版本要求：5.6.5+ ，mysql 8 以下

- 2.初始化mysql数据库，新建数据库nacos_conﬁg，数据库初始化文件：${nacoshome}/conf/nacos-mysql.sql
  
- 即将解压的nacos目录中的 conf/nacos-mysql.sql 导入到MySQL中
  
- 3.修改${nacoshome}/conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。

  - 修改 nacos解压后目录  conf/application.properties文件

  - ```properties
    # 拷贝到 application.properties
    spring.datasource.platform = mysql
    
    db.num = 1
    db.url.0 = jdbc:mysql://11.162.196.16:3306/nacos_config?characterEncoding = utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
    db.user = nacos_devtest
    db.password = youdontknow
    ```

> mysql版本太高的加上时区就可以了。我用的MySQL5.7连接报错，解决方案：conf目录中的 application.properties 改为 bootstrap.properties 。bootstartp 加载顺序优先于 application



#### 3.2 Nacos配置入门 

##### 3.3.1 发布配置 

首先在nacos发布配置。

浏览器访问 http://127.0.0.1:8848/nacos ，打开nacos控制台，并点击菜单配置管理->配置列表：

在Nacos添加如下的配置：

```yml
# Data ID:    nacos‐simple‐demo.yaml	这个不行
Data ID:    nacos.simple.demo.yaml		# 需要把 - 改成 . 才可以发布成功。
Group  :    DEFAULT_GROUP
配置格式:    YAML		# data id  后缀改为yml既可发布成功
配置内容：   common:
             config1: something
```

> Note： 注意dataid是以 properties(默认的文件扩展名方式)为扩展名，这里使用yaml。

第一步：点击新增配置

![image-20220505214836328](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505214836328.webp)

第二步：配置信息

![image-20220505215530569](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505215530569.webp)

第三步：发布配置

在第二步点击“发布”，如下图，点击确定发布成功。

![image-20220505215615373](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505215615373.webp)



##### 3.3.2 nacos客户端获取配置 

我们需要在IDEA中新增一个名为 nacos-simple-demo 的项目，坐标如下：

```xml
<groupId>com.itheima.nacos</groupId>
<artifactId>nacos‐simple‐demo</artifactId>
<version>1.0‐SNAPSHOT</version>
```

添加group ID 为 com.alibaba.nacos 和 artifact ID 为 nacos-client 的 starter。用于实现项目中使用 Nacos 来实现应用的外部化配置。

```xml
<dependency>
  <groupId>com.alibaba.nacos</groupId>
  <artifactId>nacos‐client</artifactId>
  <version>1.1.3</version>
</dependency>
```

**（1）完整的pom.xml配置如下**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>nacos-simple-demo</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>com.alibaba.nacos</groupId>
            <artifactId>nacos-client</artifactId>
            <version>2.1.0</version>
        </dependency>
    </dependencies>

    <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.36</version>
    </dependency>
</project>
```

**（2）获取外部化配置**
新增java执行类，并在执行过程中获取配置信息：

```java
public class SimpleDemoMain {
    public static void main(String[] args) throws NacosException {
        // 使用 nacos client 远程获取nacos服务上的配置信息
        // nacos server地址
        String serverAddr = "127.0.0.1:8848";
        // Data Id
        String dataId = "nacos.simple.demo.yaml";
        // Group
        String group = "DEFAULT_GROUP";

        // 获取配置信息
        Properties properties = new Properties();
        properties.put("serverAddr", serverAddr);
        ConfigService configService = NacosFactory.createConfigService(properties);

        // 获取配置  String dataId, String group, long timeoutMs
        String content = configService.getConfig(dataId, group, 5000);
        System.out.println(content);
    }
}
```

> 需要的参数，直接参考 新建配置的必填项

启动SimpleDemoMain，控制台得到以下内容：

```yml
common:
      config1: something
```

说明获取配置成功。



### 4 Nacos配置管理基础应用

#### 4.1 Nacos配置管理模型 

对于Nacos配置管理，**通过Namespace、group、Data ID能够定位到一个配置集。**

![image-20220505222915249](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505222915249.webp)

**配置集(Data ID)**

在系统中，**一个配置文件通常就是一个配置集**，一个配置集可以包含了系统的各种配置信息，例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。每个配置集都可以定义一个有意义的名称，就是配置集的ID即DataID。

**配置项**

**配置集中包含的一个个配置内容就是配置项。**它代表一个具体的可配置的参数与其值域，通常以 key=value 的形式存在。例如我们常配置系统的日志输出级别（logLevel=INFO|WARN|ERROR） 就是一个配置项。

**配置分组(Group)**

**配置分组是对配置集进行分组**，通过一个有意义的字符串（如 Buy 或 Trade ）来表示，不同的配置分组下可以有相同的配置集（Data ID）。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置分组的常见场景：可用于区分不同的项目或应用，例如：学生管理系统的配置集可以定义一个group为：STUDENT_GROUP。

> 比如将多个配置分为一个组。一般而言，我们将系统规定为一个组，一般组定义为项目名称

**命名空间(Namespace)**

**命名空间（namespace）可用于进行不同环境的配置隔离。**例如可以隔离开发环境、测试环境和生产环境，因为它们的配置可能各不相同，或者是隔离不同的用户，不同的开发人员使用同一个nacos管理各自的配置，可通过namespace隔离。不同的命名空间下，可以存在相同名称的配置分组(Group) 或 配置集。

> 通常将环境定义为不同的命名空间



**最佳实践**

Nacos抽象定义了Namespace、Group、Data ID的概念，具体这几个概念代表什么，取决于我们把它们看成什么，这里推荐给大家一种用法，如下图：

- **Namespace：代表不同环境**，如开发、测试、生产环境。
- **Group：代表某项目**，如XX医疗项目、XX电商项目
- **DataId：每个项目下往往有若干个工程，每个配置集(DataId)是一个工程的主配置文件**

![image-20220505223539163](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505223539163.webp)

获取某配置集的代码：
获取配置集需要指定：
1、nacos服务地址，必须指定
2、namespace，如不指定默认public
3、group，如不指定默认 DEFAULT_GROUP
4、dataId，必须指定

代码如下：看懂即可不用运行。

```java
// 初始化配置服务，
String serverAddr = "127.0.0.1:8848";
String namespace = "ee247dde‐d838‐425c‐b371‐029dab26232f"; //开发环境
String group = "DEFAULT_GROUP";                            //默认组
String dataId = "nacos‐simple‐demo.yaml";
Properties properties = new Properties();
properties.put("serverAddr", serverAddr);
properties.put("namespace", namespace);
ConfigService configService = NacosFactory.createConfigService(properties);
// 获取配置，并输出控制台
String content = configService.getConfig(dataId, group, 5000);
System.out.println(content);
```

**以上代码说明将从地址为127.0.0.1:8848的nacos配置中心获取配置**，通过以下信息定位配置集：
namespace：ee247dde-d838-425c-b371-029dab26232f
注意：namespace 需要指定id。
group：DEFAULT_GROUP
Data Id：nacos-simple-demo.yaml  



#### 4.2 命名空间管理 

##### 4.2.1 namespace 隔离设计

namespace 的设计是 nacos 基于此做多环境以及多租户（多个用户共同使用nacos）数据(配置和服务)隔离的。

- **从一个租户(用户)的角度来看，如果有多套不同的环境，那么这个时候可以根据指定的环境来创建不同的 namespce，以此来实现多环境的隔离。**例如，你可能有开发，测试和生产三个不同的环境，那么使用一套 nacos 集群可以分别建以下三个不同的 namespace。如下图所示：

![image-20220505223752831](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505223752831.webp)

- 从多个租户(用户)的角度来看，每个租户(用户)可能会有自己的 namespace, 每个租户(用户)的配置数据以及注册的服务数据都会归属到自己的 namespace 下，以此来实现多租户间的数据隔离。例如超级管理员分配了三个租户，分别为张三、李四和王五。分配好了之后，各租户用自己的账户名和密码登录后，创建自己的命名空间。如下图所示：

![image-20220505224031633](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505224031633.webp)

> 多个用户的话，可以每个用户一个命名空间。所以这个命名空间的使用是很灵活的



##### 4.2.2 命名空间管理

前面已经介绍过，命名空间(Namespace)是用于隔离多个环境的（如开发、测试、生产），而每个应用在不同环境的同一个配置（如数据库数据源）的值是不一样的。因此，我们应针对企业项目实际研发流程、环境进行规划。如某软件公司拥有开发、测试、生产三套环境，那么我们应该针对这三个环境分别建立三个namespace。

![image-20220505224328658](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505224328658.webp)

建立好所有namespace后，在**配置管理**与**服务管理**模块下所有页面，都会包含用于切换namespace(环境)的tab按钮，如下图：

![image-20220505224348359](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505224348359.webp)



如果您在**编写程序**获取配置集过程中没有感知到这个参数的输入，那么 nacos 统一会使用一个默认的 namespace 作为输入，nacos conﬁg 会使用一个**空字符串**作为默认的参数来初始化，对应界面上就是public命名空间。即默认指向public命名空间

> Note: namesace 为 **public** 是 nacos 的一个保留空间，如果您需要创建自己的 namespace，不要和 **public**重名，以一个实际业务场景有具体语义的名字来命名，以免带来字面上不容易区分自己是哪一个namespace。
>
> Note：**在编写程序获取配置集时，指定的 namespace 参数一定要填写命名空间ID，而不是名称**

运行下边的程序测试新建的命名空间：

注意：namespace的值根据自己的环境确定。

```java
// 初始化配置服务，
String serverAddr = "127.0.0.1:8848";
String namespace = "ee247dde‐d838‐425c‐b371‐029dab26232f"; // 开发环境
String group = "DEFAULT_GROUP";                            // 默认组
String dataId = "nacos‐simple‐demo.yaml";
Properties properties = new Properties();
properties.put("serverAddr", serverAddr);
properties.put("namespace", namespace);		// 指定命名空间为 开发环境
ConfigService configService = NacosFactory.createConfigService(properties);
// 获取配置，并输出控制台
String content = configService.getConfig(dataId, group, 5000);
System.out.println(content);
```



#### 4.3 配置管理 

Nacos支持基于Namespace和Group的配置分组管理，以便用户更灵活的根据自己的需要按照环境或者应用、模块等分组管理微服务的大量配置，在配置管理中主要提供了配置历史版本、回滚、订阅者查询等核心管理能力。

##### 4.3.1 配置列表 

点击Nacos控制台的 `配置管理->配置列表` 菜单，即可看到以下界面展示：

![image-20220505225333807](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505225333807.webp)

界面中展示了不同namespace下的**配置集**列表，可点击左上角的不同namespace进行切换。

右上角“+"号或点击某配置集后的 编辑 按钮可进入配置集编辑器。

**多配置格式编辑器**
Nacos支持 YAML、Properties、TEXT、JSON、XML、HTML 等常见配置格式在线编辑、语法高亮、格式校验，帮助用户高效编辑的同时大幅降低格式错误带来的风险。

Nacos支持配置标签的能力，帮助用户更好、更灵活的做到基于标签的配置分类及管理。同时支持用户对配置及其变更进行描述，方面多人或者跨团队协作管理配置。

![image-20220505225338324](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505225338324.webp)

**编辑DIFF**

Nacos支持编辑DIFF能力，帮助用户校验修改内容，降低改错带来的风险。

![image-20220505225352371](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505225352371.webp)

**配置集导出**

勾选若干配置集，点击 导出选中的配置 ，可获得一个压缩包：

![image-20220505225456738](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505225456738.webp)

压缩包内，包含了选中配置集所转换的配置文件：

**配置集导入**

点击右上角的 导入配置 ，可选择导出的压缩包文件，将压缩包内的文件恢复为nacos配置集。

![image-20220505225520417](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505225520417.webp)

**配置集克隆**

点击左下角 克隆 按钮，将会弹出克隆对话框，此功能可用于将配置迁移到其他Namespace。

![image-20220505225812167](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505225812167.webp)



##### 4.3.2 历史版本 

**Nacos通过提供配置版本管理及其一键回滚能力**，帮助用户改错配置的时候能够快速恢复，降低微服务系统在配置管理上的可用性风险。

![image-20220505225919235](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505225919235.webp)

点击回滚：

![image-20220505230148749](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505230148749.webp)

##### 4.3.3 监听查询

 Nacos提供配置订阅者即监听者查询能力，同时提供客户端当前配置的MD5校验值，以便帮助用户更好的检查配置变更是否推送到 Client 端。

![image-20220505230236997](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505230236997.webp)

> 当服务端信息有变，会通知到客户端，前提是客户端在进行监听

通过以下代码可对某配置进行监听：

```java
public static void main(String[] args) throws NacosException {
    // 使用 nacos client 远程获取nacos服务上的配置信息
    // nacos server地址
    String serverAddr = "127.0.0.1:8848";
    // Data Id
    String dataId = "nacos.simple.demo.yaml";
    // Group
    String group = "DEFAULT_GROUP";

    // 获取配置信息
    Properties properties = new Properties();
    properties.put("serverAddr", serverAddr);
    ConfigService configService = NacosFactory.createConfigService(properties);

    // 获取配置  String dataId, String group, long timeoutMs
    String content = configService.getConfig(dataId, group, 5000);
    System.out.println(content);
    
    // 添加监听 String dataId, String group, Listener listener
    configService.addListener(dataId, group, new Listener() {
        public Executor getExecutor() {
            return null;
        }
		// 当配置有变化时获取通知
        public void receiveConfigInfo(String s) {
            // 当配置发生变化时的响应
            System.out.println(s);
        }
    });
    // 主要目的是让主线程不退出(终止)，因为订阅配置是守护线程，主线程退出守护线程就会退出。 正式代码中无需下面代码
    while (true) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



#### 4.4 登录管理(现在界面可以直接改密码了)

Nacos当前版本支持简单的登录功能，默认用户名/密码为： nacos/nacos 。

**修改默认用户名/密码方法**

生成加密密码，在入门程序中加入如下代码：

```xml
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring‐security‐core</artifactId>
    <version>5.1.4.RELEASE</version>
</dependency>
```

编写 PasswordEncoderUtil 类，生成加密后的密码，采用 BCrypt 加密方法在每次生成密码时会加随机盐，所以生成密码每次可能不一样。

```java
public class PasswordEncoderUtil {
    public static void main(String[] args) {
        System.out.println(new BCryptPasswordEncoder().encode("123"));
    }
}
```

创建用户名或者密码的时候，用指定用户名密码即可。将上边程序输出的密码更新到数据库。

```sql
INSERT INTO users (username, password, enabled) VALUES ('nacos1', '$2a$10$SmtL5C6Gp2sLjBrhrx1vj.dJAbJLa4FiJYZsBb921/wfvKAmxKWyu', TRUE);
INSERT INTO roles (username, role) VALUES ('nacos1', 'ROLE_ADMIN');
```

> 也就是说，修改密码的话，先用 BCrypt 进行加密，然后将加密后的密码修改到users表中



**关闭登录功能**

由于部分公司自己开发控制台，不希望被nacos的安全ﬁlter拦截。因此nacos支持定制关闭登录功能找到配置文件`${nacoshome}/conf/application.properties `， 替换以下内容即可。

```properties
## spring security config
### turn off security
spring.security.enabled=false
management.security=false
security.basic.enabled=false
nacos.security.ignore.urls=/**
 
#nacos.security.ignore.urls=/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.webp,/**/*.ico,/console‐fe/public/**,/v1/auth/login,/v1/console/health,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**
```



### 5 Nacos配置管理应用于分布式系统(重)

#### 5.1 从单体架构到微服务 

##### 5.1.1 单体架构 

 Web应用程序发展的早期，大部分web工程师将所有的功能模块打包到一起并放在一个web容器中运行，所有功能模块使用同一个数据库，同时，它还提供API或者UI访问的web模块等。

![image-20220505232018640](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505232018640.webp)

尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用，**这种将所有功能都部署在一个web容器中运行的系统就叫做单体架构**（也叫：巨石型应用）。

单体架构有很多好处：

- **开发效率高**：模块之间交互采用本地方法调用，并节省微服务之间的交互讨论时间与开发成本。
- **容易测试**：IDE都是为开发单个应用设计的、容易测试——在本地就可以启动完整的系统。
- **容易部署**：运维成本小，直接打包为一个完整的包，拷贝到web容器的某个目录下即可运行。

但是，上述的好处是有条件的，它适用于小型简单应用，对于大规模的复杂应用，就会展现出来以下的不足：

- **复杂性逐渐变高，可维护性逐渐变差** ：所有业务模块部署在一起，复杂度越来越高，修改时牵一发动全身。
- **版本迭代速度逐渐变慢**：修改一个地方就要将整个应用全部编译、部署、启动时间过长、回归测试周期过长。
- **阻碍技术创新**：若更新技术框架，除非你愿意将系统全部重写，无法实现部分技术更新。
- **无法按需伸缩**：通过冗余部署完整应用的方式来实现水平扩展，无法针对某业务按需伸缩。



##### 5.1.2 微服务 

许多大型公司，通过采用微服务架构解决了上述问题。其思路不是开发一个巨大的单体式的应用，而是将应用分解为小的、互相连接的微服务。

一个微服务一般完成某个特定的功能，比如订单服务、用户服务等等。每一个微服务都是完整应用，都有自己的业务逻辑和数据库。一些微服务还会发布API给其它微服务和应用客户端使用。

 比如，根据前面描述系统可能的分解如下：

![image-20220505232753133](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505232753133.webp)

每一个业务模块都使用独立的服务完成，这种微服务架构模式也影响了应用和数据库之间的关系，不像传统多个业务模块共享一个数据库，微服务架构每个服务都有自己的数据库。

微服务架构的好处：

- 分而治之，职责单一；易于开发、理解和维护、方便团队的拆分和管理
- 可伸缩；能够单独的对指定的服务进行伸缩
- 局部容易修改，容易替换，容易部署，有利于持续集成和快速迭代
- 不会受限于任何技术栈



#### 5.2 分布式应用配置管理 

下图展示了如何通过Nacos集中管理多个服务的配置：

![image-20220505232829085](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505232829085.webp)

- 用户通过Nacos Server的控制台集中对多个服务的配置进行管理。
- 各服务统一从Nacos Server中获取各自的配置，并监听配置的变化。



##### 5.2.1 发布配置

首先在nacos发布配置，我们规划了两个服务service1、service2，并且想对这两个服务的配置进行集中维护。

浏览器访问 http://127.0.0.1:8848/nacos ，打开nacos控制台，并点击菜单**配置管理->配置列表**：

在Nacos添加如下的配置：

```yml
# service1
Namespace: c67e4a97‐a698‐4d6d‐9bb1‐cfac5f5b51c4  #开发环境
Data ID:    service1.yaml
Group  :    TEST_GROUP
配置格式:    YAML
配置内容：   common:
             name: service1 config
```

![image-20220505233347256](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505233347256.webp)

```yml
# service2
Namespace: c67e4a97‐a698‐4d6d‐9bb1‐cfac5f5b51c4 #开发环境
Data ID:    service2.yaml
Group  :    TEST_GROUP		# 一般同一个项目 在同一个组中
配置格式:    YAML
配置内容：   common:
             name: service2 config
```

![image-20220505233421184](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220505233421184.webp)



##### 5.2.2 创建父工程 

为了规范依赖的版本，这里创建父工程，指定依赖的版本。

父工程pom.xml如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>2.nacos-distribute-demo</artifactId>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>service1</module>
        <module>service2</module>
    </modules>
    <packaging>pom</packaging>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2.1.0.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.SR4</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.2.1.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

##### 5.2.3 微服务service1配置 

 本小节，我们将演示如何使用 Spring Cloud Alibaba Nacos Conﬁg 在Spring Cloud应用中集成Nacos，通过Spring cloud原生方式快捷的获取配置内容。

Spring Cloud是什么：

> Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，集成最多的组件要属Netﬂix公司，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。

Spring Cloud Alibaba Nacos Conﬁg是什么：

> Spring Cloud Alibaba Nacos Discovery是Spring Cloud Alibaba的子项目，而Spring Cloud Alibaba是阿里巴巴公司提供的开源的基于Spring cloud的微服务套件合集，它致力于提供微服务开发的一站式解决方案，可以理解为spring cloud是一套微服务开发的 标准 ，spring cloud alibaba与spring cloud Netﬂix是实现。使用 Spring Cloud Alibaba方案，开发者只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。

由于Nacos是阿里的中间件，因此，若开发Spring cloud微服务应用，使用Spring Cloud Alibaba Nacos Conﬁg来集成Nacos的配置管理功能是比较明智的选择。



**（1）新建项目service1**
首先新增一个名为service1工程，并添加group ID 为 com.alibaba.cloud 和 artifact ID 为 spring-cloud-starter-alibaba-nacos-config 的 starter。

```xml
<artifactId>service1</artifactId>

<dependencies>
    <!-- 由于配置中心发布消息，客户端监听，nacos-config就是一个客户端 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-alibaba-nacos-config</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <version>2.0.1.RELEASE</version>
    </dependency>
</dependencies>
```

> 新增一个名为service2工程，其依赖也如上。这里service1与service2作为微服务模块

**（2）bootstrap.yml配置(Service1与Service2配置一样 除端口名称不一样)**
 一般来说，spring boot的配置将在application.yml(也可以是application.properties)文件中编写， 由于使用外部配置中心，必须将原先的application.yml重命名为bootstrap.yml，bootstrap.yml如下所示：

> **注意：由于 bootstrap.yml 的加载顺序优先于 application.yml。针对nacos配置管理的配置一定要写在 bootstrap.yml 中**，优先且不会被后续覆盖

spring.cloud.nacos.conﬁg.server-addr 指定了Nacos Server的网络地址和端口号。

```yml
server:
  port: 56010 # 启动端口 命令行注入
spring:
  application:
    name: service1
  cloud:
    nacos:
      config:
      	# 这里如果不指定file-extension的话默认是properties  即nacos的dataID需要为：service1.properties
        file-extension: yaml  # 文件扩展名。注意nacos界面的dataID的名称就是：application的name+file-extension：service1.yaml
        # 所以这里虽然没有配置dataid，不过可以通过 application.name+file-extension 组合为dataid
        # 所以：dataid+namespace+group 可以定位到具体的配置集了
        server-addr: 127.0.0.1:8848 # 配置中心地址
        namespace: 4da75722-a371-4f29-9db9-5616248b4316 # 开发环境  指定具体的namespace
        group: TEST_GROUP # 测试组
```

以上配置文件说明该应用将从地址为127.0.0.1:8848配置中心获取配置，通过以下信息定位配置集：

```yml
namespace：c67e4a97‐a698‐4d6d‐9bb1‐cfac5f5b51c4 # 开发环境
group：TEST_GROUP # 测试组
Data Id：service1.yaml  
```

> Note：spring-cloud-starter-alibaba-nacos-conﬁg 在加载配置的时候，加载了以 dataid 为`${spring.application.name}.${file-extension:properties}` 的基础配置。对应以上的配置，它会去 nacos server中加载data id为service1.yaml的配置集。
>
> Note: 若没有指定spring.cloud.nacos.conﬁg.group配置，则默认为DEFAULT_GROUP。

**（3）启动配置客户端(Service1与Service2配置一致)**
新增Spring Boot 启动类，并增加获取配置的web访问端点/conﬁgs，通过标准的spring @Value 方式。

```java
package com.itheima.nacos;
 
@SpringBootApplication
@RestController
public class Service1Bootstrap {
    public static void main(String[] args) {
        SpringApplication.run(Service1Bootstrap.class, args);
    }
 
    // @Value("${配置文件中的key}")  可以通过这种方式拿到配置文件的key对应的value值
    // 通过value注解读取在nacos中创建的配置信息
    // 由于nacos-config与spring整合了，于是@Value是能拿到读取的配置信息
    @Value("${common.name}")
    private String config1;

    @GetMapping(value = "/configs")
    public String getConfigs() {
        // 读取配置信息
        return config1;
    }
}
```

> 试试NacosValue；这部分启动不起来的，父级pom里的UTF-8的-是不是英文，以及子pom的版本号；启动不了报的是@value注解的问题,其实spring-cloud版本的问题

但是我们发现，这种方式，在nacos中对配置进行了修改，这里读取配置文件信息还是旧的？其实nacos是通知了客户端的，只是value注解并没有将最新的配置信息赋到这个属性中。所以我们需要支持配置的动态更新



##### 5.2.3 支持配置的动态更新 

基于上面快速上手的例子，若要实现配置的动态更新，只需要将原代码改造如下：

```java
// 注入配置文件上下文
@Autowired
private ConfigurableApplicationContext applicationContext;
 
@GetMapping(value = "/configs")
public String getConfigs(){
    // 通过上下文动态的获取nacos的配置信息
    return applicationContext.getEnvironment().getProperty("common.name");
}
```
我们通过nacos控制台更新common.name的配置值，再次访问web端点/conﬁgs，发现应用程序能够获取到最新的配置值，说明spring-cloud-starter-alibaba-nacos-conﬁg 支持配置的动态更新。

> Controller上使用@RefreshScope就行了，不用上下文    @RefreshScope 刷新作用域
>
> Note： 可以通过配置spring.cloud.nacos.conﬁg.refresh.enabled=false来关闭动态刷新



##### 5.2.4 自定义 namespace与group配置 

**支持自定义 namespace的配置**

在没有明确指定 `${spring.cloud.nacos.config.namespace}` 配置的情况下， 默认使用的是 Nacos 上 Public 这个namespace。如果需要使用自定义的命名空间，可以通过以下配置来实现：

```yml
spring:
    cloud:
        nacos:
            config:
                namespace: b3404bc0‐d7dc‐4855‐b519‐570ed34b62d7
```

Note：该配置必须放在 bootstrap.yml文件中。此外 `spring.cloud.nacos.config.namespace` 的值是 namespace对应的 id，id 值可以在 Nacos 的控制台获取。并且在添加配置时注意不要选择其他的 namespae，否则将会导致读取不到正确的配置。

**支持自定义 Group 的配置**

在没有明确指定 `${spring.cloud.nacos.config.group}` 配置的情况下， 默认使用的是 DEFAULT_GROUP 。如果需要自定义自己的 Group，可以通过以下配置来实现：

```yml
spring:
    cloud:
        nacos:
            config:
                group: DEVELOP_GROUP
```

Note：该配置必须放在 bootstrap.properties 文件中。并且在添加配置时 Group 的值一定要和 `spring.cloud.nacos.config.group` 的配置值一致。



如果说我们想：一个微服务不仅仅只对应一个配置文件，可能对应多个配置文件时 该如何处理？比如一个配置文件放公共数据，service1需要引用、service2需要引用；也有可能每个微服务本身就需要多个配置文件(比如将连接数据库的配置独立放)

所以，我们需要研究研究 自定义扩展DataID。在上个例子中，每个微服务对应一个 `application.name+file-extension：service1.yaml`。可知dataID就是配置文件的名称，那么我们该如何去扩展呢？让每个微服务对应多个dataID呢？

##### 5.2.5 自定义扩展的 Data Id 配置(推荐 一服务对多配置)

Spring Cloud Alibaba Nacos Conﬁg可支持自定义 Data Id 的配置。 一个完整的配置案例如下所示：

下边我们在service2微服务下配置扩展。**同一个微服务对应多个dataID(一个dataID代表nacos中的一个配置文件)**

```yml
spring:
    application:
        name: service2
    cloud:
        nacos:
            config:
                server‐addr: 127.0.0.1:8848
# config external configuration
# 1、Data Id 在默认的组 DEFAULT_GROUP,不支持配置的动态刷新，没有指定group组就默认在DEFAULT_GROUP
				# 注意：新版用的是extension-configs[xxx]  比如：spring.cloud.nacos.config.extension-configs[0]
                ext‐config[0]:		# 既然是扩展，必然可以扩展多个，所以扩展config的配置以数组的形式来配置的。从0开始
                    data‐id: ext‐config‐common01.properties
 
# 2、Data Id 不在默认的组，不支持动态刷新  即每次修改了nacos中的配置，本程序需要重启
                ext‐config[1]:
                    data‐id: ext‐config‐common02.properties
                    group: GLOBALE_GROUP
 
# 3、Data Id 既不在默认的组，也支持动态刷新
                ext‐config[2]:
                    data‐id: ext‐config‐common03.properties
                    group: REFRESH_GROUP
                    refresh: true	# 动态刷新配置
```

> 这样就可以将公共的配置信息放在一个文件中，然后让多个微服务进行引用

可以看到:

- 通过 spring.cloud.nacos.config.ext-config[n].data-id 的配置方式来支持多个 Data Id 的配置。
- 通过 spring.cloud.nacos.config.ext-config[n].group 的配置方式自定义 Data Id 所在的组，不明确配置的话，默认是 DEFAULT_GROUP。
- 通过 spring.cloud.nacos.config.ext-config[n].refresh 的配置方式来控制该 Data Id 在配置变更时，是否支持应用中可动态刷新， 感知到最新的配置值。默认是不支持的。

> Note ： spring.cloud.nacos.config.ext-config[n].data-id 的值必须带文件扩展名，文件扩展名既可支持properties，又可以支持 yaml/yml。 此时 spring.cloud.nacos.config.file-extension 的配置对自定义扩展配置的 Data Id 文件扩展名没有影响。

通过自定义扩展的 Data Id 配置，既可以解决多个应用间配置共享的问题，又可以支持一个应用有多个配置文件。

测试：
配置 `ext-conﬁg-common01.properties`：

![image-20220506092233024](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506092233024.webp)

配置`ext-conﬁg-common02.properties`

![image-20220506092248963](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506092248963.webp)

配置`ext-conﬁg-common03.properties`

![image-20220506092301729](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506092301729.webp)

编写测试代码：

```java
@GetMapping(value = "/configs2")
public String getConfigs2(){
    // 项目名+扩展名的方式得出的默认DataID：application.name+file-extension
    String name = applicationContext.getEnvironment().getProperty("common.name");
    // ext-conﬁg-common01.properties 的配置
    String age =  applicationContext.getEnvironment().getProperty("common.age");
    String address =  applicationContext.getEnvironment().getProperty("common.address");
    // ext-conﬁg-common02.properties 的配置
    String birthday=  applicationContext.getEnvironment().getProperty("common.birthday");
    // ext-conﬁg-common03.properties 的配置
    String fullname =  applicationContext.getEnvironment().getProperty("common.fullname");
    
    return name + "+" + age + "+" + address + "+" + birthday + "+" + fullname;
}
```

重启应用，访问 http://localhost:56011/conﬁgs2 ，观察配置是否成功获取。
输出：

```
service2 config+12+beijing+1990‐1‐1+zhangsansanff
```



##### 5.2.6 自定义共享 Data Id 配置(不推荐)

为了更加清晰的在多个应用间配置共享的 Data Id ，你可以通过以下的方式来配置：

```yml
spring: 
  cloud: 
    nacos: 
      config: 
		 shared‐dataids: ext‐config‐common01.properties,ext‐config‐common02.properties
		 # 动态刷新指定的配置文件
         refreshable‐dataids: ext‐config‐common01.properties 
```

虽然也可以做到一个微服务对应多个配置。但我们发现，**这种方式它只支持读取DEFAULT_GROUP 组下的配置信息。**如果这两个配置文件不在DEFAULT_GROUP下，则读取不到任何信息。

可以看到：

- 通过 `spring.cloud.nacos.config.shared-dataids` 来支持多个共享 Data Id 的配置，多个之间用逗号隔开。
- 通过 `spring.cloud.nacos.config.refreshable-dataids` 来支持哪些共享配置的 Data Id 在配置变化时，应用中是否可动态刷新， 感知到最新的配置值，多个 Data Id 之间用逗号隔开。如果没有明确配置，默认情况下所有共享配置的 Data Id 都不支持动态刷新。

> Note：通过 `spring.cloud.nacos.config.shared-dataids` 来支持多个共享配置的 Data Id 时， 多个共享配置间的一个优先级的关系，我们约定：按照配置出现的先后顺序，即后面的优先级要高于前面。
>
> Note：通过 `spring.cloud.nacos.config.shared-dataids` 来配置时，Data Id 必须带文件扩展名，文件扩展名既可支持 properties，也可以支持 yaml/yml。 此时 `spring.cloud.nacos.config.file-extension` 的配置对自定义扩展配置的 Data Id 文件扩展名没有影响。
>
> Note： `spring.cloud.nacos.config.refreshable-dataids` 给出哪些需要支持动态刷新时，Data Id 的值也必须明确给出文件扩展名。

测试输出：

```java
service2 config+12+beijing+null+null 
```

为什么后边两个值为null?

**共享DataId的配置使用默认的group即DEFAULT_GROUP**，`ext-conﬁg-common02.properties`不属于DEFAULT_GROUP。

共享DataId的配置相比扩展的 Data Id 配置，它把group固定为DEFAULT_GROUP，建议使用扩展的 Data Id 配置，因为扩展的 Data Id 配置也可以实现共享DataId配置。



##### 5.2.7 配置的优先级(需要好好测试)

Spring Cloud Alibaba Nacos Conﬁg 目前提供了三种配置能力从 Nacos 拉取相关的配置。

- A: 通过 `spring.cloud.nacos.config.shared-dataids` 支持多个**共享 Data Id 的配置**
- B: 通过 `spring.cloud.nacos.config.ext-config[n].data-id` 的方式支持多个**扩展 Data Id 的配置**，多个 Data Id 同时配置时，他的优先级关系是 `spring.cloud.nacos.config.ext-config[n].data-id` 其中 **n 的值越大，优先级越高。**
  - 即，如果 [0]中name=张三，[1]中name=李四。那么会采用李四
  - 官网写得是ext-config[index] 的优先级，index越小，优先级越高，从0开始？？？
  - 那这样想，由于这里加载多个配置文件的话，属于重复赋值，即优先级高的先赋值过去，然后优先级低的会覆盖优先级高的赋值
- C: 通过内部相关规则(应用名、扩展名 )自动生成相关的 Data Id 配置
  - 即 通过 项目名+扩展名的方式得出的默认DataID。所谓项目名+扩展名：`application.name+file-extension`

当三种方式共同使用时，他们的一个优先级关系是: **C > B >A**

> 同一个组里面不能出现相同的dataId。加载优先级指的是谁会先被加载，而后的就不管了，不会重复加载也就没有覆盖一说。

测试，屏蔽共享dataId，放开ext-conﬁg，如下：

```yml
spring: 
  application: 
    name: service2 
  cloud: 
    nacos: 
      config: 
        server‐addr: 127.0.0.1:8848 # 配置中心地址 
        file‐extension: yaml 
        namespace: c67e4a97‐a698‐4d6d‐9bb1‐cfac5f5b51c4 # 开发环境 
        group: TEST_GROUP  
#        shared‐dataids: ext‐config‐common01.properties,ext‐config‐common02.properties 
        # config external configuration 
        # 1、Data Id 在默认的组 DEFAULT_GROUP,不支持配置的动态刷新 
        ext‐config[0]: 
          data‐id: ext‐config‐common01.properties 
 
        # 2、Data Id 不在默认的组，不支持动态刷新 
        ext‐config[1]: 
          data‐id: ext‐config‐common02.properties 
          group: GLOBALE_GROUP 
 
        # 3、Data Id 既不在默认的组，也支持动态刷新 
        ext‐config[2]: 
          data‐id: ext‐config‐common03.properties 
          group: REFRESH_GROUP 
          refresh: true 
```

修改ext-conﬁg-common03.properties：

![image-20220506094353336](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506094353336.webp)

在`common01.properties与common03.properties`中配置均配置了age参数，最终输出的是配置3的配置信息。输出：

```java
service2 config aaa+ 15 +beijing+1990‐1‐1+zhangsansanff 
```

通过测试发现多个 Data Id 同时配置时，他的优先级关系是 `spring.cloud.nacos.config.ext-config[n].data-id`其中 n 的值越大，优先级越高。

修改：service1.yaml

![image-20220506094537044](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506094537044.webp)

输出：

```
service2 config aaa+ 25 +beijing+1990‐1‐1+zhangsansanff 
```

通过测试发现：B和C同时存在，C优先级高。这里采用了 `application.name+file-extension` 的配置输出

> 没事，就这么思考：**主配置不可被覆盖，扩展配置后的覆盖前的。**



##### 5.2.8 完全关闭配置 

通过设置 `spring.cloud.nacos.conﬁg.enabled = false` 来完全关闭 Spring Cloud Nacos Conﬁg



#### 5.3 Nacos集群部署 

##### 5.3.1 集群部署 

3个或3个以上Nacos节点才能构成集群(因为有节点选举的问题，即投票选择谁作为主节点)

**（1）安装3个以上Nacos**

 我们可以复制之前已经解压好的nacos文件夹，分别命名为nacos、nacos1、nacos2(因为每个nacos文件夹就是一个nacos服务)

**（2）配置集群配置文件**

 在所有nacos目录的conf目录下，有文件 `cluster.conf.example` ，将其命名为 `cluster.conf` ，并将每行配置成 ip:port。（请配置3个或3个以上节点）

```asm
# ip:port 即每个nacos都改一下ip和端口。从而指向不同ip服务器指定端口的nacos
# 其实这里就是在配置3台nacos，注册服务列表。只是我们暂时只在一台电脑上，于是ip相同端口不同而已
# 3台nacos都要注册服务列表，即修改cluster.conf为如下
127.0.0.1:8848 
127.0.0.1:8849 
127.0.0.1:8850 
```

由于是单机演示，需要更改nacos/的conf目录下application.properties中server.port，防止端口冲突。

如果服务器有多个ip也要指定具体的ip地址，如：nacos.inetutils.ip-address=127.0.0.1

例如

```properties
server.port=8850 
nacos.inetutils.ip‐address=127.0.0.1 
```

**（3）集群模式启动**
分别执行nacos目录的bin目录下的startup：

```asm
startup ‐m cluster
```

![image-20220506101035247](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506101035247.webp)

在任意一个nacos的控制台中，可以看到如下内容：

![image-20220506101044511](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506101044511.webp)

##### 5.3.2 客户端配置 

所有客户端，分别指定nacos集群中的若干节点：

```yml
spring:
  application:
    name: xxxx
  cloud:
    nacos:
      config:
        server‐addr: 127.0.0.1:8848,127.0.0.1:8849,127.0.0.1:8850
```

测试，使用快速上手的例子：
（1）关掉127.0.0.1:8848 nacos Leader实例，发现Leader被成功选举至127.0.0.1:8850
（2）紧接着重新启动Provider，这时马上请求consumer的/service出现错误，发现consumer与provider通信已经出现问题。但经过短暂的时间后，通信恢复。

通过测试，我们可以看到，通过以上的集群部署已经达到了高可用的效果。



##### 5.3.3 生产环境部署建议 

下图是官方推荐的集群方案，通过域名 + VIP模式(虚拟IP)的方式来实现。客户端配置的nacos，当Nacos集群迁移时，客户端配置无需修改。

![image-20220506101204598](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506101204598.webp)

> 即生产环境，只需要在nacos这里配置一个虚拟IP就行，然后虚拟IP会绑定多个nacos节点，当某一台nacos节点宕机了，会自动负载到其他的nacos节点上

至于数据库，生产环境下建议至少主备模式。通过修改`${nacoshome}/conf/application.properties`文件，能够使nacos拥有多个数据源。

```properties
spring.datasource.platform=mysql
 
db.num=2
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&autoReconnect=true
db.url.1=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&autoReconnect=true
db.user=root
db.password=root
```





## nacos - 服务发现(各服务间远程调用 我怎么知道服务的地址+端口)

就是将每个服务的IP地址与端口统一管理起来，建立一个服务列表，然后消费者需要调用生产者的接口，实时的去服务中心获取生产者的ip，从而发起远程调用。
同时服务中心还要负责起各个服务的健康状态，如果某个服务挂了，服务中心还将此ip提供给消费者显然是不合适的。

### 1. 概览 

#### 1.1 什么是服务发现

在微服务架构中，整个系统会按职责能力划分为多个服务，通过服务之间协作来实现业务目标。这样在我们的代码中免不了要进行服务间的远程调用，服务的消费方要调用服务的生产方，为了完成一次请求，消费方需要知道服务生产方的网络位置(IP地址和端口号)。

我们的代码可以通过读取配置文件的方式读取服务生产方网络位置，如下：

![image-20220506105721970](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506105721970.webp)

> 服务发现就是消费方要知道生产方的地址去调用生产方的服务

我们通过Spring boot技术很容易实现：

**Service B（服务生产者）**

Service B是服务的生产方，暴露/service服务地址，实现代码如下：

```java
@SpringBootApplication
@RestController
public class SpringRestProviderBootstrap {
    public static void main(String[] args) {
        SpringApplication.run(SpringRestProviderBootstrap.class, args);
    }
    @GetMapping(value = "/service") //暴露服务
    public String service(){
        return "provider invoke";
    }
}
```

服务生产方暴露端口，配置文件：

```properties
server.port = 56010
```

**Service A（服务消费者）**

实现代码：

```java
@SpringBootApplication
@RestController
public class SpringRestConsumerBootstrap {
    public static void main(String[] args) {
        SpringApplication.run(SpringRestConsumerBootstrap.class, args);
    }
 
    @Value("${provider.address}")
    private String providerAddress;
 
    @GetMapping(value = "/service")
    public String service(){
        RestTemplate restTemplate = new RestTemplate();
        //调用服务
        String providerResult = restTemplate.getForObject("http://" + providerAddress + "/service", String.class);
        return "consumer invoke | " + providerResult;
    }
}
```

服务消费方需要远程调用服务生产方，所以需要知道生产方的IP+端口。配置文件：

```properties
server.port = 56020
# 服务生产方地址
provider.address = 127.0.0.1:56010 
```

访问http://127.0.0.1:56020/service，输出以下内容：

```
consumer invoke | provider invoke
```

 看上去很完美，但是，仔细考虑以下，此方案对于微服务应用而言行不通。就是不能将固定死的将生产方的IP放到配置文件中

首先，微服务可能是部署在云环境的，服务实例的网络位置或许是动态分配的。另外，每一个服务一般会有多个实例来做负载均衡，由于宕机或升级，服务实例网络地址会经常动态改变。再者，每一个服务也可能应对临时访问压力增加新的服务节点。正如下图所示：

![image-20220506110247499](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506110247499.webp)

 基于以上的问题，服务之间如何相互感知？服务如何管理？这就是服务发现的问题了。如下图：

![image-20220506110309025](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506110309025.webp)

上图中服务实例本身并不记录服务生产方的网络地址，所有服务实例内部都会包含**服务发现客户端**。

（1）在每个服务启动时会向**服务发现中心**上报自己的网络位置。这样，在服务发现中心内部会形成一个**服务注册表**，服务注册表是服务发现的核心部分，是包含所有服务实例的网络地址的数据库。

 （2）**服务发现客户端会定期从服务发现中心同步服务注册表** ，并缓存在客户端。

 （3）当需要对某服务进行请求时，服务实例通过该注册表，定位目标服务网络地址。若目标服务存在多个网络地址，则使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。

总结一下，在微服务环境中，由于服务运行实例的网络地址是不断动态变化的，服务实例数量的动态变化 ，因此无法使用固定的配置文件来记录服务提供方的网络地址，必须使用动态的服务发现机制用于实现微服务间的**相互感知**。各服务实例会上报自己的网络地址，这样服务中心就形成了一个完整的服务注册表，各服务实例会通过**服务发现中心**来获取访问目标服务的网络地址，从而实现**服务发现**的机制。



#### 1.2 主流服务发现与配置中心对比 

目前市面上用的比较多的服务发现中心有：Nacos、Eureka、Consul和Zookeeper。

| 对比项目        | Nacos                  | Eureka           | Consul            | Zookeeper  |
| --------------- | ---------------------- | ---------------- | ----------------- | ---------- |
| 一致性协议      | 支持AP和CP模型         | AP模型           | CP模型            | CP模型     |
| 健康检查        | TCP/HTTP/MYSQL/Client  | Beat Client Beat | TCP/HTTP/gRPC/Cmd | Keep Alive |
| 负载均衡策略    | 权重/metadata/Selector | Ribbon           | Fabio             | -          |
| 雪崩保护        | 有                     | 有               | 无                | 无         |
| 自动注销实例    | 支持                   | 支持             | 不支持            | 支持       |
| 访问协议        | HTTP/DNS               | HTTP             | HTTP/DNS          | TCP        |
| 监听支持        | 支持                   | 支持             | 支持              | 支持       |
| 多数据中心      | 支持                   | 支持             | 支持              | 不支持     |
| 跨注册中心同步  | 支持                   | 不支持           | 支持              | 不支持     |
| SpringCloud集成 | 支持                   | 支持             | 支持              | 不支持     |
| Dubbo集成       | 支持                   | 不支持           | 不支持            | 支持       |
| k8s集成         | 支持                   | 不支持           | 支持              | 不支持     |

从上面对比可以了解到，Nacos作为服务发现中心，具备更多的功能支持项，且从长远来看Nacos在以后的版本会支持SpringCLoud+Kubernetes 的组合，填补 2 者的鸿沟，在两套体系下可以采用同一套服务发现和配置管理的解决方案，这将大大的简化使用和维护的成本。另外，Nacos 计划实现 Service Mesh，也是未来微服务发展的趋势。



#### 1.3 Nacos特性 

Nacos主要提供以下四大功能：

1. **服务发现与服务健康检查**
Nacos使服务更容易注册，并通过DNS或HTTP接口发现其他服务，Nacos还提供服务的实时健康检查，以防止向不健康的主机或服务实例发送请求。就是心跳确认你还活没活着
2. **动态配置管理**
动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos消除了在更新配置时重新部署应用程序，这使配置的更改更加高效和灵活。

3. **动态DNS服务**
Nacos提供基于DNS 协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以域名的方式暴露端点，让三方应用方便的查阅及发现。
4. **服务和元数据管理**
Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略。

这里1、3、4说明了服务发现的功能特性。



### 2. Nacos 服务发现快速入门 

本小节，我们将演示如何使用`Spring Cloud Alibaba Nacos Discovery`为Spring cloud 应用程序与 Nacos 的无缝集成。 通过一些**原生的spring cloud注解**，我们可以快速来实现Spring cloud微服务的服务发现机制，并使用Nacos Server作为服务发现中心，统一管理所有微服务。

#### 2.1 Spring Cloud服务协作流程 

现在，我们对Spring cloud内的一些组件还不了解，为了能够完全理解快速入门程序，我们需要学习以下内容。

Spring Cloud 常见的集成方式是使用 Feign+Ribbon 技术来完成服务间远程调用及负载均衡的，如下图：

![image-20220506111349068](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506111349068.webp)

> nginx是服务端负载均衡，ribbon是客户端负载均衡么。
>
> nginx是前端请求后端服务的负载均衡，而ribbon是将微服务中消费者的请求平摊到各个生产者(服务实例)上
>
> 然后springcloud的微服务之间的调用都是基于http的，所以ServiceA通过http方式调用ServiceB 这里采用Feign组件

（1）在微服务启动时，会向服务发现中心上报自身实例信息，这里ServiceB 包含多个实例。每个实例包括：IP地址、端口号信息。

（2）微服务会定期从Nacos Server(服务发现中心)获取服务实例列表。

（3）当ServiceA调用ServiceB时，ribbon组件从本地服务实例列表中查找ServiceB的实例，如获取了多个实例如Instance1、Instance2。这时ribbon会通过用户所配置的负载均衡策略从中选择一个实例。（请求流量均摊）

（4）最终，Feign组件会通过ribbon选取的实例发送http请求。（远程调用）

采用Feign+Ribbon的整合方式，是由Feign完成远程调用的整个流程。而Feign集成了Ribbon，Feign使用Ribbon完成调用实例的负载均衡。

 

##### 2.1.1 负载均衡的概念 

在SpringCloud服务协议流程中，ServiceA通过负载均衡调用ServiceB，下边来了解一下负载均衡：

负载均衡就是将用户请求（流量）通过一定的策略，分摊在多个服务实例上执行，它是系统处理高并发、缓解网络压力和进行服务端扩容的重要手段之一。它分为**服务端负载均衡和客户端负载均衡**。

**服务器端负载均衡：**

![image-20220506113026372](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506113026372.webp)

在负载均衡器中维护一个可用的服务实例清单，当客户端请求来临时，负载均衡服务器按照某种配置好的规则(负载均衡算法)从可用服务实例清单中选取其一去处理客户端的请求。这就是服务端负载均衡。

> 例如Nginx，通过Nginx进行负载均衡，客户端发送请求至Nginx，Nginx通过负载均衡算法，在多个服务器之间选择一个进行访问。即在服务器端再进行负载均衡算法分配。

**客户端服务负载均衡：**

![image-20220506113134502](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506113134502.webp)

> 我们接下来要讲的Ribbon，就属于客户端负载均衡。在ribbon客户端会有一个服务实例地址列表，在发送请求前通过负载均衡算法选择一个服务实例，然后进行访问，这是客户端负载均衡。即在客户端就进行负载均衡算法分配。



Ribbon是一个客户端负载均衡器，它的责任是从一组实例列表中挑选合适的实例，如何挑选？取决于**负载均衡策略** 。

Ribbon核心组件IRule是负载均衡策略接口，它有如下实现，大家仅做了解：

- RoundRobinRule(默认)：轮询，即按一定的顺序轮换获取实例的地址。
- RandomRule：随机，即以随机的方式获取实例的地址。
- AvailabilityFilteringRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，以及并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问；
- WeightedResponseTimeRule：根据平均响应时间计算所有服务的权重，响应时间越快，服务权重越大，被选中的机率越高; 
  刚启动时，如果统计信息不足，则使用RoundRobinRule策略，等统计信息足够时，会切换到 WeightedResponseTimeRule
- RetryRule: 先按照RoundRobinRule的策略获取服务，如果获取服务失败，则在指定时间内会进行重试，获取可用的服务;
- BestAvailableRule: 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务;
- ZoneAvoidanceRule: 默认规则，复合判断server所在区域的性能和server的可用性选择服务器;

可通过下面方式在spring boot 配置文件中修改默认的负载均衡策略：

```properties
account‐service.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadbalancer.RandomRule
```

account-service 是调用的服务的名称，后面的组成部分是固定的。



##### 2.1.2 Feign 介绍 

Feign是Netﬂix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。Feign的英文表意为“假装，伪装，变形”， 可以理解为将HTTP报文请求方式伪装为简单的java接口调用方式。

参考第1章节的ServiceA调用ServiceB的例子，我们使用Feign实现这个过程，代码如下：

Service B暴露"/service"服务端点，如下：

```java
@SpringBootApplication
@RestController
public class SpringRestProviderBootstrap {
    public static void main(String[] args) {
        SpringApplication.run(SpringRestProviderBootstrap.class, args);
    }
    
    @GetMapping(value = "/service") //暴露服务
    public String service(){
        return "provider invoke";
    }
}
```

**Feign调用方式如下：**
（1）声明Feign客户端

```java
// 定义一个接口，用FeignClient标注，需要调用哪个服务，就标注哪个服务名。这里我们需要调用ServiceB
// 这个服务名，在使用了服务注册中心后，Feign就可以根据这里写的服务名从服务中心获取实例的地址，从而可以进行远程调用
@FeignClient(value = "serviceB")
public interface ServiceBAgent {
  /** 然后需要调用生产者的哪个方法，就直接在这里声明一下。然后服务消费方最终会生成一个动态代理对象，代理对象会根据注解中指明的地址，发起http的远程调用
   * 根据用户名查询账号信息
   * @param username 用户名
   * @return 账号信息
   */
  @GetMapping(value = "/service")
  public String service();
}
```

（2）业务调用

```java
@Autowired
private ServiceBAgent serviceBAgent.;
 
//....略
 
serviceBAgent.service();
 
//....略
```

是不是非常简单？并且在业务调用时，减少了与业务无关的http请求相关代码的编写，使业务逻辑清晰。咱们分析一下Feign帮我们做了哪些事儿：

- 在 `声明Feign客户端` 之后，Feign会根据@FeignClient注解使用java的动态代理技术生成代理类，在这里我们指定@FeignClient value为serviceB，则说明这个类的远程目标为spring cloud的服务名称为serviceB的微服务。

- serviceB的具体访问地址，Feign会交由ribbon获取，若该服务有多个实例地址，ribbon会采用指定的负载均衡策略选取实例。
- Feign兼容spring的web注解（如：@GetMapping），它会分析声明Feign客户端方法中的Spring注解，得出Http请求method、参数信息以及返回信息结构。
- 当业务调用Feign客户端方法时，会调用代理类，根据以上分析结果，由代理类完成实际的参数封装、远程http请求，返回结果封装等操作。

另外，别忘了，若在在Spring cloud中使用Feign，需要引入以下依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring‐cloud‐starter‐openfeign</artifactId>
</dependency>
```

> Feign默认集成了Ribbon，可以直接使用。

还需要在spring cloud 启动类中标注@EnableFeignClients，表明此项目开启Feign客户端:

```java
@SpringBootApplication
@EnableDiscoveryClient 
@EnableFeignClients		// 开启feign
public class SpringRestConsumerBootstrap {
    public static void main(String[] args) {
        SpringApplication.run(SpringRestConsumerBootstrap.class, args);
    }
}
```

总结：通过上面的学习，我们已经了解Spring cloud的微服务是如何协作的，通过哪些组件的配合能够完成服务间协作？我们了解了什么是负载均衡，**Feign用于服务间Http调用，Ribbon用于执行负载均衡算法选取访问实例，而Ribbon的实例列表来源是由Spring cloud的服务发现中心提供（当前实现为Nacos）**，更详细的内容请学习Spring Cloud的相关课程 。



#### 2.2 搭建Nacos服务端(看以前的)

略...

#### 2.3 创建父工程 

为了规范依赖的版本，这里创建父工程，指定依赖的版本。

父工程pom.xml如下：

```xml
<artifactId>1.nacos‐discovery</artifactId>
<packaging>pom</packaging>

<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    <java.version>1.8</java.version>
</properties>

<dependencyManagement>
    <dependencies>
        <!-- SpringCloud Alibaba 微服务 -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>2.1.0.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
		<!-- SpringCloud 微服务 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Hoxton.SR4</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
		<!-- SpringBoot 依赖配置 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.2.1.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

#### 2.4 服务生产者 

以下步骤演示了如何将一个服务生产者注册到 Nacos。

1、pom.xml的配置。
包括Spring Cloud Feign组件、Spring Cloud Alibaba Nacos Discovery组件以及Spring boot web相关组件依赖。

```xml
<artifactId>quickstart‐provider</artifactId>

<dependencies>
    <!-- nacos的服务注册 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
	<!-- mvc -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <version>2.0.1.RELEASE</version>
    </dependency>
	<!-- feign -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>
</dependencies>
```

2、application.yml配置。一些关于 Nacos 基本的配置也必须在application.yml(也可以是application.properties)配置，如下所示： application.yml

```yml
server:
  port: 56010

spring:
  application:
    name: quickstart‐provider
  cloud:
    nacos:
      discovery:  # 将nacos用作于服务注册 服务注册与配置管理可以共存
        server-addr: 127.0.0.1:8848

logging:
  level:
    root: info
    org.springframework: info
```

> Note: spring.cloud.nacos.discovery.server-addr 指定了Nacos Server的网络地址和端口号。

3、Provider(生产者)服务实现

```java
@RestController
public class ProviderController {
    private static final Logger LOG = LoggerFactory.getLogger(ProviderController.class);

    @GetMapping("/service")
    public String service() {
        LOG.info("provider invoke");
        return "provider invoke";
    }
}
```

4、启动Provider(生产者)

```java
@SpringBootApplication      // boot工程
@EnableDiscoveryClient      // 服务发现客户端
@EnableFeignClients         // feign客户端
public class NacosProviderApp {
    public static void main(String[] args) {
        SpringApplication.run(NacosProviderApp.class, args);
    }
}
```

> Note: @EnableDiscoveryClient 在spring cloud项目中表明此项目是一个注册发现客户端，这里注册服务发现使用的是Nacos
>
> Note: @EnableFeignClients 开启FeignClient



#### 2.5 服务消费者 

以下步骤演示了如何结合Nacos对spring cloud rest接口进行消费。

1、pom.xml的配置。

```xml
<artifactId>quickstart‐consumer</artifactId>

<dependencies>
    <!-- nacos的服务注册 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
	<!-- mvc -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <version>2.0.1.RELEASE</version>
    </dependency>
	<!-- feign -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>
</dependencies>
```

2、application.yml配置

```yml
server:
  port: 56020

spring:
  application:
    name: quickstart‐consumer
  cloud:
    nacos:
      discovery:  # 将nacos用作于服务注册
        server-addr: 127.0.0.1:8848
```

3、Provider(生产者)远程代理定义

```java
@FeignClient(value = "quickstart‐provider")
public interface ProviderClient {
    /**
     * 远程调用 quickstart‐provider 服务的service方法
     * @return 字符串
     */
    @GetMapping("/service")
    public String service();
}
```

4、Consumer(消费者)服务实现

```java
@RestController
public class ConsumerController {
    private static final Logger LOG = LoggerFactory.getLogger(ConsumerController.class);

    /**
     * 注入 FeignClient 进行远程调用。动态代理对象，内部远程调用服务生产者
     */
    @Autowired
    private ProviderClient providerClient;

    @GetMapping("/service")
    public String service() {
        LOG.info("consumer invoke");
        // 远程调用
        String providerResult = providerClient.service();
        return "consumer invoke" + "|" + providerResult;
    }
}
```

5、启动Consumer(消费者)

```java
@SpringBootApplication      // boot工程
@EnableDiscoveryClient      // 服务发现客户端
@EnableFeignClients         // feign客户端
public class NacosConsumerApp {
    public static void main(String[] args) {
        SpringApplication.run(NacosConsumerApp.class, args);
    }
}
```

访问地址：http://127.0.0.1:56020/service

![image-20220506151023582](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506151023582.webp)

调用成功。

浏览器访问 http://127.0.0.1:8848/nacos ，打开nacos控制台，并点击菜单服务管理->服务列表，可展示出刚刚注册的两个服务：

![image-20220506151038753](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506151038753.webp)



#### 2.6 测试多实例负载均衡 

修改`quickstart-provider`工程的`application.yaml`，**实现port动态传入**：

```yml
server:
  # 我们会传入一个port的参数，如果没有传port参数则默认56010，传了就以port入参为主
  port: ${port:56010} #启动端口
```

那么这个参数怎么传进来呢？设置启动参数：

![image-20220506151616286](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506151616286.webp)

[将配置复制一份，只有端口不一样，这样就是两个启动实例了](https://www.bilibili.com/video/BV1VJ411X7xX?p=22&spm_id_from=pageDriver)

![image-20220506151745302](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506151745302.webp)

然后启动quickstart-provider两个实例。再去nacos服务列表看一看

![image-20220506151941625](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506151941625.webp)

点击详情

![image-20220506151956691](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506151956691.webp)

此时，我们就可以测试负载均衡了

请求http://127.0.0.1:56020/service测试负载均衡。

跟踪quickstart-provider两个实例的控制台的日志输出，默认负载均衡策略是轮询。



### 3. Nacos服务发现基础应用

#### 3.1 服务发现数据模型 

Nacos在经过阿里内部多年生产经验后提炼出的数据模型，则是一种服务-集群-实例的三层模型，这样基本可以满足服务在所有场景下的数据存储和管理。

![image-20220506152755051](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506152755051.webp)

**命名空间(Namespace)**

用于进行租户粒度的配置隔离，命名空间不仅适用于nacos的配置管理，同样适用于服务发现。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。

**服务**
提供给客户端的软件功能，通过预定义接口网络访问。

**服务名**
服务提供的标识，通过该标识可以唯一确定其指代的服务。

**实例**
提供一个或多个服务的具有可访问网络地址（IP:Port）的进程，启动一个服务，就产生了一个服务实例。

> 远程调用需要指定服务名，而实际调用的是服务中的实例

**元信息**
Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。可以定制个性化信息

> 服务列表 -> 详情 -> 编辑，里面就有元数据

![image-20220506153009131](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506153009131.webp)

<!-- 元信息能够让nacos更具备扩展性，用户可以自定义数据用于描述实例、服务、集群等- -->

**集群**
服务实例的集合，服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群，相同集群下的实例才能相互感知。相同集群下的应用可以相互调用、感知

 

应用通过Namespace、Service、Cluster(DEFAULT)的配置，描述了该服务向哪个环境（如开发环境）的哪个集群注册实例。

```yml
spring:
  application:
    name: transaction‐service
  cloud:
    nacos:
      discovery:
        server‐addr: 127.0.0.1:7283  # 注册中心地址
        namespace: a1f8e863‐3117‐48c4‐9dd3‐e9ddc2af90a8  # 将服务注册到 开发环境 中
        cluster‐name: DEFAULT # 默认集群，可不填写
```

> Note: 集群作为实例的隔离，相同集群的实例才能相互感知。
>
> Note: namespace、cluster-name若不填写都将采取默认值，namespace的默认是public命名空间，cluster-name的默认值为DEFAULT集群。



#### 3.2 服务管理 

开发者或者运维人员往往需要在服务注册后，通过友好的界面来查看服务的注册情况，包括当前系统注册的所有服务和每个服务的详情。并在有权限控制的情况下，进行服务的一些配置的编辑操作。Nacos在目前最新版本开放的控制台的服务发现部分，主要就是提供用户一个基本的运维页面，能够查看、编辑当前注册的服务，这些功能集中在Nacos控制台的服务管理一级菜单内。

##### 3.2.1 服务列表管理 

 服务列表帮助用户以统一的视图管理其所有的微服务以及服务健康状态。整体界面布局是左上角有服务的搜索框和搜索按钮，页面中央是服务列表的展示。服务列表主要展示服务名、集群数目、实例数目、健康实例数目和详情按钮五个栏目。

![image-20220506153513986](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506153513986.webp)

在服务列表页面点击详情，可以看到服务的详情。可以查看服务、集群和实例的基本信息。



##### 3.2.2 服务流量权重支持及流量保护 

 Nacos 为用户提供了流量权重控制的能力，同时开放了服务流量的阈值保护，以帮助用户更好的保护服务服务提供者集群不被意外打垮。如下图所以，可以点击实例的编辑按钮，修改实例的权重。**如果想增加实例的流量，可以将权重调大，如果不想实例接收流量，则可以将权重设为0。**

![image-20220506153619276](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506153619276.webp)

> 这个权重跟负载均衡有关

##### 3.2.3 服务元数据管理 

 Nacos提供多个维度的服务元数据的暴露，帮助用户存储自定义的信息。这些信息都是以K-V的数据结构存储，在控制台上，会以k1=v1,k2=v2这样的格式展示。类似的，编辑元数据可以通过相同的格式进行。例如服务的元数据编辑，首先点击服务详情页右上角的“编辑服务”按钮，然后在元数据输入框输入：version=1.0。

![image-20220506153752172](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506153752172.webp)

点击确认，就可以在服务详情页面，看到服务的元数据已经更新了。



##### 3.2.4 服务优雅上下线 

 Nacos还提供服务实例的上下线操作，在服务详情页面，可以点击实例的“上线”或者“下线”按钮，被下线的实例，将不会包含在健康的实例列表里。

![image-20220506154006077](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506154006077.webp)

> **这个下线的作用就跟把权重设置0的效果是一样的，下线就表示不再参与负载均衡**

上下线测试：
（1）分别启动快速上手中的quickstart-consumer与quickstart-provider工程，更改quickstart-provide中的启动端口，再次启动quickstart-provider，让quickstart-provider服务拥有两个实例。

![image-20220506154025983](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506154025983.webp)

（2）多次访问http://127.0.0.1:56020/service ，让consumer调用provider时触发负载均衡。
（3）观察provider的2个实例控制台，可发现实例调用被均匀负载。
（4）在provider的服务详情页面，让某实例下线。

![image-20220506154036278](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506154036278.webp)

（5）多次访问http://127.0.0.1:56020/service ，观察控制台，发现下线的实例已不再接收流量。
（6）在provider的服务详情页面，让该实例恢复上线状态。
（7）多次访问http://127.0.0.1:56020/service ，观察控制台，发现恢复上线的实例已恢复流量访问。



### 4. Spring Cloud Alibaba 综合集成架构演示(主看其项目结构)

前面说到，Spring Cloud是一个较为全面的微服务框架集，集成了如服务注册发现、配置中心、消息总线、负载均衡、断路器、API网关等功能实现。而在网上经常会发现Spring Cloud与阿里巴巴的Dubbo进行选择对比，这样做其实不是很妥当，前者是一套较为完整的架构方案，而**Dubbo只是服务治理与RPC实现方案**。

> dubbo：只是做rpc远程调用。dubbo作用rpc远程调用的性能非常高

Dubbo在国内有着非常大的用户群体，但是其周边设施与组件相对来说并不那么完善。很多开发者用户又很希望享受Spring Cloud的生态，因此也会有一些Spring Cloud与Dubbo一起使用的案例与方法出现，但是一直以来大部分Spring Cloud整合Dubbo的使用方案都不完善。直到Spring Cloud Alibaba的出现，才得以解决这样的问题。

在此之前，我们已经学了如何使用Spring Cloud Alibaba来集成Nacos与Spring Cloud应用，并且在此之下可以如传统的Spring Cloud应用一样地使用Ribbon或Feign来微服务之间的协作。由于Feign是基于Http Restful的调用，在高并发下的性能不够理想，RPC方案能否切换为Dubbo？Spring Cloud与阿里系的若干组件能否完美集成呢？

可以！本章内容将指引大家集成一个微服务的基础架构，并讨论其合理性。



#### 4.1 总体结构 

系统架构图如下：

![image-20220506154234932](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506154234932.webp)

> 网关会对客户端请求进行统一拦截，从而进行过滤和路由，路由到Application-1服务上。我们将Application称为应用层，因为主要针对用户请求的；应用层的业务处理依赖于微服务层。
>
> 所以网关可以称之为接入层；Application应用层；Service微服务层。
>
> 优点：微服务层的功能相对稳定，应用层单独抽离出来就可以针对用户的需求变更 来快速的进行开发多个应用层，但它们都依赖于下面的微服务层，微服务层功能相对稳定，对应用层提供支撑
>
> 对客户端暴露http协议，但微服务之间的交互采用dubbo(RPC)，就能弥补http交互的性能问题

组件说明：

- API网关 ：系统统一入口，屏蔽架构内部结构，统一安全拦截，采用Zuul实现。
- application-1 ：应用1，模拟应用，提供http接口服务。
- service-1 ：微服务1，模拟微服务，提供dubbo接口服务。
  service-2 ：微服务2，模拟微服务，提供dubbo接口服务。
- 调用流程：
  - 所有访问系统的请求都要经过网关，网关转发Http请求至application-1，application-1使用dubbo调用service1完成自身业务，而后sevice1调用service2完成自身业务。至此，完成所有组件贯穿。

架构中application与sevice的区别是什么？

- service提供了基础服务功能；application组装基础服务功能，提供给用户直接可用的业务。
- service服务粒度小、功能基础，不易发生改变；application提供上游业务功能，紧贴业务需求，容易发生改变。
- 形成service支撑application的整体架构，增加多变的application甚至不需要变动service。



#### 4.3 工程结构说明 

采用maven工程，结构如下：

```
nacos‐micro‐service   整体父工程
 
├─api‐gateway         API网关，端口：56010
 
├─application‐1       应用1，端口：56020
 
├─service‐1          服务1 父工程
 
│  ├─service‐1‐api    服务1 API
 
│  └─service‐1‐server 服务1实现，端口：56030    
 
└─service‐2          服务2 父工程
 
   ├─service‐2‐api    服务2 API
 
   └─service‐2‐server 服务2 实现，端口：56040
```

> application 暴露的是http接口，service暴露的是dubbo协议接口。通常会将dubbo协议接口服务单独抽成一个独立的API工程，这个API工程是以jar包的形式被其他工程引用

创建目录结构时就看这个就行，新建一个工程(`nacos‐micro‐service`)作为最顶级的父亲，然后下面有模块：`api‐gateway、application‐1、service‐1、service‐2`
然后 service‐1与service‐2 又作为一个父工程，下面分布包含模块：`service‐1‐api、service‐1‐server`与`service‐2‐api、service‐2‐server`



#### 4.4 创建父工程 

创建 artifactId 名为 nacos-micro-service 的 Maven 工程，此父工程继承nacos-discovery父工程，间接指定了Spring boot、spring cloud 以及spring-cloud-alibaba的依赖版本。

```xml
<parent>
    <artifactId>nacos‐discovery</artifactId>
    <groupId>com.itheima.nacos</groupId>
    <version>1.0‐SNAPSHOT</version>
</parent>
<modelVersion>4.0.0</modelVersion>
<artifactId>nacos‐micro‐service</artifactId>
<packaging>pom</packaging>
```

nacos-discovery的pom.xml如下：

```xml
<groupId>org.example</groupId>
<artifactId>2.nacos‐discovery</artifactId>
<version>1.0-SNAPSHOT</version>
<packaging>pom</packaging>

<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
    <java.version>1.8</java.version>
</properties>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>2.1.0.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Hoxton.SR4</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.2.1.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

#### 4.5 实现application1 

application1属于应用层，提供http接口服务。

（1）初始化 application-1 Maven 工程

```xml
<artifactId>application-1</artifactId>

<dependencies>
    <!--nacos配置管理-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--nacos服务中心-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--mvc-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

> 因为这个服务需要注册到nacos，引入nacos客户端及其服务中心。应用层需要暴露http的接口

（2）实现 application-1 功能

```java
package com.drunk.microservice.application1.controller;
// 应用层向外暴露http接口
@RestController
public class Application1Controller {
    // 因为应用层需要引用微服务层，所以需要注入service（基于dubbo协议）
    @GetMapping("/service")
    public String service() {
        return "test";
    }
}
```

（3） application1 配置

纯粹的dubbo服务消费者，配置看起来更简单。

定义bootstrap.yml

```yml
server:
  port: ${port:56020} # 启动端口 命令行注入 如果没传参默认使用56020端口
  servlet:
    context-path: /application1   # 工程的根路径

spring:
  application:
    name: application1  # 项目名称
  main:
    allow-bean-definition-overriding: true  # SpringBoot 2.1 需要设定 防止bean重复 进行覆盖的问题
  cloud:
    nacos:
      discovery:  # 服务发现的配置
        server-addr: 127.0.0.1:8848 #
        namespace: 4da75722-a371-4f29-9db9-5616248b4316 # 采用开发环境DEV
        cluster-name: DEFAULT
      config:   # 配置管理  注意：这里没有使用扩展配置 默认使用的 application.name+file-extension 即需要在nacos添加配置：application1.yaml
        server-addr: 127.0.0.1:8848 #
        file-extension: yaml
        namespace: 4da75722-a371-4f29-9db9-5616248b4316 # 采用开发环境DEV
        group: XIAOWEI_MICROSERVICE_GROUP   # xx业务组
```

![image-20220506230546325](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220506230546325.webp)

（4） application1 启动

当 Service1Bootstrap 启动后，应用 application1 将出现在 Nacos 控制台界面。

```java
package com.drunk.microservice.application1;

@SpringBootApplication
@EnableDiscoveryClient
public class Application1Bootstrap {
    public static void main(String[] args) {
        SpringApplication.run(Application1Bootstrap.class,args);
    }
}
```

然后启动并测试访问：http://localhost:56020/application1/service/



#### 4.6 实现 Service1 

##### 4.6.1 定义父工程 

定义service1父工程，pom.xml如下：

```xml
<parent>
    <artifactId>2.nacos‐micro‐service</artifactId>
    <groupId>org.example</groupId>
    <version>1.0-SNAPSHOT</version>
</parent>
<modelVersion>4.0.0</modelVersion>

<artifactId>service-1</artifactId>
<packaging>pom</packaging>
<modules>
    <module>service-1-api</module>
    <module>service-1-server</module>
</modules>
```

##### 4.6.2 定义service-1-api 

service-1统一将接口写在了service-1-api 模块，以后谁要调用service-1-server这个dubbo服务，只需要直接依赖service-1-api的jar包就行了

**为了方便其它服务调用dubbo服务，专门定义api工程，此工程将作为jar被其它工程依赖。**

定义service-1-api工程，pom.xml如下：

```xml
<parent>
    <artifactId>service-1</artifactId>
    <groupId>org.example</groupId>
    <version>1.0-SNAPSHOT</version>
</parent>
<modelVersion>4.0.0</modelVersion>

<artifactId>service-1-api</artifactId>
```

定义服务接口：

```java
package com.drunk.microservice.service1.api;
// 向外暴露服务接口
public interface ConsumerService {
    String service();
}
```

##### 4.6.3 实现service-1-server 

（1）初始化 service-1-server Maven 工程

与服务提供方 Maven工程类似，需添加相关 Maven 依赖：

```xml
<artifactId>service-1-server</artifactId>

<dependencies>
    <!--service-1-api 接口-->
    <dependency>
        <groupId>org.example</groupId>
        <artifactId>service-1-api</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <!--nacos服务注册-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--nacos配置中心-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--由于微服务层之间的调用都是通过 dubbo协议的RPC方式 引入dubbo依赖-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-dubbo</artifactId>
    </dependency>
</dependencies>
```

（2）实现 Dubbo 服务

```java
package com.drunk.microservice.service1.service;

@org.apache.dubbo.config.annotation.Service     // 注解标记此类的方法暴露为dubbo接口
public class ConsumerServiceImpl implements ConsumerService {
    // dubbo接口实现类
    @Override
    public String service() {
        return "Consumer invoke";
    }
}
```

注意：使用@org.apache.dubbo.conﬁg.annotation.Service标记dubbo服务。由于这个@Service注解与spring中的@Service重名，为了区分这是标记dubbo的，最好写全路径

（3）配置 Dubbo 服务

Service2 作为Dubbo服务消费方配置与服务提供方类似，注意，service1不仅是消费方，同时还是服务提供方：

```yml
server:
  port: ${port:56030} #启动端口 命令行注入,没传port时默认 56030
  servlet:
    context-path: /service1 # 工程的根路径

spring:
  application:
    name: service1
  main:
    allow-bean-definition-overriding: true  # SpringBoot 2.1 需要设定 防止bean重复 进行覆盖的问题
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848 #
        namespace: 4da75722-a371-4f29-9db9-5616248b4316
        cluster-name: DEFAULT
      config:
        server-addr: 127.0.0.1:8848 #
        file-extension: yaml
        namespace: 4da75722-a371-4f29-9db9-5616248b4316 # 采用开发环境DEV
        group: XIAOWEI_MICROSERVICE_GROUP

# 由于service1需要暴露dubbo服务接口
dubbo:
  scan: # dubbo服务扫描基准包,就是告诉dubbo哪些包下的类需要采用dubbo.此时这个包下面标记有 @org.apache.dubbo.config.annotation.Service 的都是dubbo接口
    base-packages: com.xiaowei.service1.service
  protocol:
    # dubbo 协议
    name: dubbo
    # dubbo 协议端口
    port: ${dubbo_port:20881}
  registry:
    # service1也需要注册到nacos的服务中心.可以看出nacos既可以注册http接口 也可以注册dubbo服务的接口
    address: nacos://127.0.0.1:8848
    application:
      qos-enable: false # dubbo运维服务是否开启
    consumer:
      check: false  # 启动时就否检查依赖的服务
```

以上 YAML 内容，dubbo开头的为dubbo服务 的配置：

- `dubbo.scan.base-packages` : 指定 Dubbo 服务实现类的扫描基准包，将`@org.apache.dubbo.conﬁg.annotation.Service`注解标注的service暴露为dubbo服务。

- `dubbo.protocol` : Dubbo 服务暴露的协议配置，其中子属性 name 为协议名称， port 为dubbo协议端口可以指定多协议，如：`dubbo.protocol.rmi.port=1099`

  - dubbo服务指定协议，可以指定多个协议，但是每个协议都需要指定协议端口

- `dubbo.registry` : Dubbo 服务注册中心配置，其中子属性 address 的值 "nacos://127.0.0.1:8848"，说明dubbo服务注册到nacos

  相当于原生dubbo的xml配置中的 <dubbo:registry address="10.20.153.10:9090" />



上半部分为SpringCloud的相关配置：

- `spring.application.name` : Spring 应用名称，用于 Spring Cloud 服务注册和发现。

> 该值在 Dubbo Spring Cloud 加持下被视作 `dubbo.application.name` ，因此，无需再显示地配置`dubbo.application.name`

- `spring.cloud.nacos.discovery` : Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口
- `spring.cloud.nacos.config` : Nacos 配置中心配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口。

（4）启动服务消费方应用



当 `Service1Bootstrap` 启动后，应用 service1 将出现在 Nacos 控制台界面。

启动成功，观察nacos服务列表

![image-20220507100030767](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220507100030767.webp)



#### 4.7 实现 application1调用Service1

现在service1已暴露dubbo服务并注册到nacos中，下边实现application1调用service1

##### 4.7.1 引用service1 

下边在application1中引用service1

在pom.xml中引入service-1-api的依赖

```xml
<!--service1微服务的dubbo接口-->
<dependency>
    <groupId>org.example</groupId>
    <artifactId>service-1-api</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

引入 spring-cloud-starter-dubbo依赖，它会根据接口生成代理对象

```xml
<!--凡是要调用dubbo接口,都需要引入这个依赖-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-dubbo</artifactId>
</dependency>
```

##### 4.7.2 实现远程调用

```java
package com.drunk.microservice.application1.controller;

@RestController
public class Application1Controller {

    // 这个@Reference注解与jdk中的有重名，建议写全路径。这个注解会生成接口代理对象，然后通过代理对象进行远程调用
    // 注入service (基于dubbo协议)
    @org.apache.dubbo.config.annotation.Reference
    private ConsumerService consumerService;

    @GetMapping("/service")
    String service(){
        // 使用dubbo协议进行远程调用
        String target=consumerService.service();
        return "application-1|test|"+target;
    }
}
```

Note：注意：这里的 `@Reference` 注解是 `org.apache.dubbo.config.annotation.Reference`

测试：

请求：http://localhost:56020/application1/service

consumerService正常生成代理对象，service1被调用。

```asm
# 结果 证明service1被成功调用
application-1|test|Consumer invoke
```



#### 4.8 实现 Service2

 如上面设计所示，Service2需要暴露dubbo接口以供service1消费，若想在Spring cloud Alibaba中集成并使用dubbo。

##### 4.8.1 定义父工程 

定义service2父工程，pom.xml如下：

```xml
<artifactId>service-2</artifactId>
<packaging>pom</packaging>
<modules>
    <module>service-2-api</module>
    <module>service-2-server</module>
</modules>
```

##### 4.8.2 定义service-2-api 

 定义service-2-api工程，pom.xml如下：

```xml
<parent>
    <artifactId>service-2</artifactId>
    <groupId>org.example</groupId>
    <version>1.0-SNAPSHOT</version>
</parent>
<modelVersion>4.0.0</modelVersion>

<artifactId>service-2-api</artifactId>
```

并定义服务接口，Dubbo 服务接口是服务提供方与消费方的远程通讯契约，通常由普通的 Java 接口（interface）来声明，如 `ProviderService` 接口：

```java
package com.drunk.microservice.service2.api;
public interface ProviderService {
    String service();
}
```

##### 4.5.3 实现service-2-server 

（1）初始化 `service-2-server Maven` 工程

首先，创建 `artifactId` 名为` service-2-server` 的 Maven 工程，并在其 pom.xml 文件中增添 Dubbo Spring Cloud 必要的依赖：

```xml
<dependencies>
    <!--service-2-api 接口-->
    <dependency>
        <groupId>org.example</groupId>
        <artifactId>service-2-api</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <!--nacos服务注册-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--nacos配置中心-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--由于微服务层之间的调用都是通过 dubbo协议的RPC方式 引入dubbo依赖-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-dubbo</artifactId>
    </dependency>
</dependencies>
```

以上依赖 artifact 说明如下：

- `service-2-api` : 提供 `ProviderService` 接口的 artifact
- `spring-boot-starter-web` : Spring Boot starter artifact ，间接引入 `spring-boot artifact`
- `spring-cloud-starter-dubbo` : Dubbo Spring Cloud Starter artifact ，间接引入 `dubbo-spring-boot-starter` 等 artifact
- `spring-cloud-starter-alibaba-nacos-discovery` : Nacos Spring Cloud 服务注册与发现 artifact



（2）实现 Dubbo 服务

ProviderService 作为暴露的 Dubbo 服务接口，服务提供方 service-2-server 需要将其实现：

```java
import com.drunk.microservice.service2.api.ProviderService;

@org.apache.dubbo.config.annotation.Service
public class ProviderServiceImpl implements ProviderService {
    @Override
    public String service() {
        return "Provider invoke";
    }
}
```

其中，`@org.apache.dubbo.config.annotation.Service` 是 Dubbo 服务注解，仅声明该 Java 服务（本地）实现为 Dubbo 服务。 因此，下一步需要将其配置 Dubbo 服务（远程）。

（3）配置 Dubbo 服务

在暴露 Dubbo 服务方面，推荐开发人员外部化配置的方式，即指定 Java 服务实现类的扫描基准包。

> Dubbo Spring Cloud 继承了 Dubbo Spring Boot 的外部化配置特性，也可以通过标注@DubboComponentScan 来实现基准包扫描。

同时，Dubbo 远程服务需要暴露网络端口，并设定通讯协议，完整的 YAML 配置如下所示：

```yml
server:
  port: ${port:56040} #启动端口 命令行注入,没传port时默认 56030
  servlet:
    context-path: /service2 # 工程的根路径

spring:
  application:
    name: service2
  main:
    allow-bean-definition-overriding: true  # SpringBoot 2.1 需要设定 防止bean重复 进行覆盖的问题
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848 #
        namespace: 4da75722-a371-4f29-9db9-5616248b4316
        cluster-name: DEFAULT
      config:
        server-addr: 127.0.0.1:8848 #
        file-extension: yaml
        namespace: 4da75722-a371-4f29-9db9-5616248b4316 # 采用开发环境DEV
        group: XIAOWEI_MICROSERVICE_GROUP

# 由于service1需要暴露dubbo服务接口
dubbo:
  scan: # dubbo服务扫描基准包,就是告诉dubbo哪些包下的类需要采用dubbo.此时这个包下面标记有 @org.apache.dubbo.config.annotation.Service 的都是dubbo接口
    base-packages: com.drunk.microservice.service2.service
  protocol:
    # dubbo 协议
    name: dubbo
    # dubbo 协议端口(-1 表示自增端口,从20880开始)
    port: ${dubbo_port:20891}
  registry:
    # service1也需要注册到nacos的服务中心.可以看出nacos既可以注册http接口 也可以注册dubbo服务的接口
    address: nacos://127.0.0.1:8848
    application:
      qos-enable: false # dubbo运维服务是否开启
    consumer:
      check: false  # 启动时就否检查依赖的服务
```

（4）启动服务提供方应用

Dubbo Spring Cloud 引导类与普通 Spring Cloud 应用并无差别，如下所示：

```java
package com.drunk.microservice.service2;
@EnableDiscoveryClient
@SpringBootApplication
public class Service2Bootstrap {
    public static void main(String[] args) {
        SpringApplication.run(Service2Bootstrap.class,args);
    }
}
```

在引导 `Service2Bootstrap` 之前，请提前启动 Nacos 服务器。 当 `Service2Bootstrap` 启动后，应用 service2 将出现在 Nacos 控制台界面。



#### 4.9 实现service1调用service2 

##### 4.9.1 引用service2 

在service1(service-1-server)中添加service2的依赖：

```xml
<!--引入service-2-api依赖,从而service1可以通过dubbo协议远程调用service2-->
<dependency>
    <groupId>org.example</groupId>
    <artifactId>service-2-api</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

##### 4.9.2 实现远程调用

```java
package com.drunk.microservice.service1.service;

@org.apache.dubbo.config.annotation.Service     // 注解标记此类的方法暴露为dubbo接口
public class ConsumerServiceImpl implements ConsumerService {

    @org.apache.dubbo.config.annotation.Reference
    ProviderService providerService;

    @Override
    public String service() {
        return "Consumer invoke | " + providerService.service();
    }
}
```

测试：
请求：http://localhost:56020/application1/service
application1调用service1，service1调用service2

```asm
# 测试结果
application-1|test|Consumer invoke | Provider invoke
# Application1："application-1|test|" + consumerService.service();
# service1："Consumer invoke | " + providerService.service();
# service2："Provider invoke";
```



#### 4.10 实现api-gateway 

##### 4.10.1 Zuul介绍 

什么是网关？

原来的单体架构，所有的服务都是本地的，UI可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java进程了。客户端UI如何访问？他的后台有N个服务，前台就需要记住管理N个服务，一个服务下线/更新/升级，前台就要重新部署，这明显不服务我们拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。另外，N个小服务的调用也是一个不小的网络开销。

![image-20220507103700308](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220507103700308.webp)

有了网关作为服务统一入口，就可以避免上述问题，不仅如此，服务网关是在微服务前边设置一道屏障，请求先到服务网关，**网关会对请求进行过虑、校验、路由等处理。**有了服务网关可以提高微服务的安全性，网关校验请求的合法性，请求不合法将被拦截，拒绝访问。

- 提供统一服务入口，让微服务对前台透明
- 聚合后台的服务，节省流量，提升性能
- 提供安全，过滤，流控等API管理功能

什么是Zuul？
Spring Cloud Zuul是整合Netﬂix公司的Zuul开源项目实现的微服务网关，它实现了请求路由、负载均衡、校验过虑等 功能。
官方：https://github.com/Netﬂix/zuul



Zuul与Nginx怎么配合使用？

Zuul与Nginx在实际项目中需要配合使用，如下图，Nginx的作用是反向代理、负载均衡，Zuul的作用是保障微服务的安全访问，拦截微服务请求，校验合法性及负载均衡。

![image-20220507103759955](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220507103759955.webp)



##### 4.10.2 搭建网关工程 

初始化 api-gateway Maven 工程

```xml
<dependencies>
    <!--nacos的服务注册与配置管理-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--mvc-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--zuul组件作为网关-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
    </dependency>
    <!--网关访问应用层需要通过http访问,所以采用feign-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>
</dependencies>
```

##### 4.8.3 api-gateway配置

```yml
server:
  port: 8100 #启动端口 命令行注入

spring:
  application:
    name: api-gateway
  main:
    allow-bean-definition-overriding: true  # SpringBoot 2.1 需要设定 防止bean重复 进行覆盖的问题
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848 #
        namespace: 4da75722-a371-4f29-9db9-5616248b4316
        cluster-name: DEFAULT
      config:
        server-addr: 127.0.0.1:8848 #
        file-extension: yaml
        namespace: 4da75722-a371-4f29-9db9-5616248b4316
        group: XIAOWEI_MICROSERVICE_GROUP
```

网关的**路由配置**采用nacos远程配置，在nacos控制台**开发环境**中新增api-gateway.yaml配置集，配置组为TEST_GROUP，配置内容如下：

```yml
zuul:
  routes:
    application1:	# 路由到哪个服务，这里路由到application1服务
      stripPrefix: false
      path: /application1/**	# 所有请求以 /application1/** 开头的都转发到application1服务
```

> 网关做路由转发：配置一个路由

将请求为 `/application1/` 开头的请求路由至 `application1` 服务，保留请求url中的 `/application1/` 。

在nacos中新增一个针对于网关路由的配置：

![image-20220507111027831](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220507111027831.webp)

（4） api-gateway启动

注意在启动类上使用@EnableZuulProxy注解标识此工程为Zuul网关，启动类代码如下：

```java
package com.drunk.microservice.gateway;
@SpringBootApplication
@EnableDiscoveryClient
@EnableZuulProxy    // 开启网关代理
public class ApiGatewayBootstrap {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayBootstrap.class,args);
    }
}
```

当 `Service1Bootstrap` 启动后，应用 `api-gateway` 将出现在 Nacos 服务列表中。

![image-20220507111247299](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220507111247299.webp)

测试：

通过网关（api-gateway）请求Application1应用，Application1的业务实现又贯穿service1、service2，访问http://127.0.0.1:8100/application1/service ，将得到如下结果：(因为我网关配置的端口就是8100)

![image-20220507112018808](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/SpringCloudAlibaba/nacos/image-20220507112018808.webp)











（4） api-gateway启动

注意在启动类上使用@EnableZuulProxy注解标识此工程为Zuul网关，启动类代码如下：



### 附： Spring Cloud Nacos discovery Starter 配置项信息说明

| 配置项              | Key                                            | 默认值                     | 说明                                                         |
| ------------------- | ---------------------------------------------- | -------------------------- | ------------------------------------------------------------ |
| 服务端地址          | spring.cloud.nacos.discovery.server-addr       | 无 NacosServer             | 启动监听的ip地址和端口                                       |
| 服务名              | spring.cloud.nacos.discovery.service           | ${spring.application.name} | 给当前的服务命名                                             |
| 服务分组            | spring.cloud.nacos.discovery.group             | DEFAULT_GROUP              | 设置服务所处的分组                                           |
| 权重                | spring.cloud.nacos.discovery.weight            | 1                          | 取值范围 1 到 100，数值越大，权重越大                        |
| 网卡名              | spring.cloud.nacos.discovery.network-interface | 无                         | 当IP未配置时，注册的IP为此网卡所对应的IP地址，如果此项也未配置，则默认取第一块网卡的地址 |
| 注册的IP地址        | spring.cloud.nacos.discovery.ip                | 无                         | 优先级最高                                                   |
| 注册的端口          | spring.cloud.nacos.discovery.port              | -1                         | 默认情况下不用配置，会自动探测                               |
| 命名空间            | spring.cloud.nacos.discovery.namespace         | 无                         | 常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。 |
| AccessKey           | spring.cloud.nacos.discovery.access-key        | 无                         | 当要上阿里云时，阿里云上面的一个云账号名                     |
| SecretKey           | spring.cloud.nacos.discovery.secret-key        | 无                         | 当要上阿里云时，阿里云上面的一个云账号密码                   |
| Metadata            | spring.cloud.nacos.discovery.metadata          | 无                         | 使用Map格式配置，用户可以根据自己的需要自定义一些和服务相关的元数据信息 |
| 日志文件名          | spring.cloud.nacos.discovery.log-name          | 无                         |                                                              |
| 集群                | spring.cloud.nacos.discovery.cluster-name      | DEFAULT                    | 配置成Nacos集群名称                                          |
| 接入点              | spring.cloud.nacos.discovery.enpoint           | UTF-8                      | 地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址 |
| 是否集成Ribbon      | ribbon.nacos.enabled                           | true                       | 一般都设置成true即可                                         |
| 是否开启Nacos Watch | spring.cloud.nacos.discovery.watch.enabled     | true                       | 可以设置成false来关闭 watch                                  |

