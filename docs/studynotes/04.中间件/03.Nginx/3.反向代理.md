---
title: 反向代理
date: 2023-01-29 15:42:59
permalink: /pages/d30e01/
categories:
  - studynotes
  - 中间件
  - Nginx
tags:
  - Nginx
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---
## Rewrite功能配置

Rewrite是Nginx服务器提供的一个重要基本功能，是Web服务器产品中几乎必备的功能。主要的作用是用来实现URL的重写。www.jd.com

> 注意：Nginx服务器的Rewrite功能的实现依赖于PCRE的支持，因此在编译安装Nginx服务器之前，需要安装PCRE库。Nginx使用的是ngx_http_rewrite_module模块来解析和处理Rewrite功能的相关配置。
>
> PCRE是正则表达式库



**"地址重写"与"地址转发"**

重写和转发的区别：

- 地址重写浏览器地址会发生变化；而地址转发则不变
- 一次地址重写会产生两次请求而一次地址转发只会产生一次请求
- 地址重写到的页面必须是一个完整的路径而地址转发则不需要
- 地址重写因为是两次请求，所以 request 范围内属性不能传递给新页面，而地址转发因为是一次请求所以可以传递值
- 地址转发速度快于地址重写



Rewrite的相关命令

- set指令
- if指令
- break指令
- return指令
- rewrite指令
- rewrite_log指令

Rewrite的应用场景

- 域名跳转
- 域名镜像
- 独立域名
- 目录自动添加"/"
- 合并目录
- 防盗链的实现



### Rewrite的相关指令

#### set指令

该指令用来设置一个新的变量。（nginx的变量名都要用$声明）

| 语法   | set $variable value; |
| ------ | -------------------- |
| 默认值 | —                    |
| 位置   | server、location、if |

- variable：变量的名称，该变量名称要用"$"作为变量的第一个字符，且不要与Nginx服务器预设的全局变量同名。

- value：变量的值，可以是字符串、其他变量或者变量的组合等。

例如

```nginx
server {
    listen 8081;
    server_name localhost;
    location /server {
        set $name TOM; #声明name变量
        set $age 18;
        default_type text/plain;
        return 200 $name=$age;
    }
}
```

访问 `https://192.168.200.133:8081:server`，返回结果：TOM=18



#### Rewrite常用全局变量

| 变量               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| $args              | 变量中存放了请求URL中的请求参数。比如http://192.168.200.133/server?arg1=value1&args2=value2中的"arg1=value1&arg2=value2"，功能和$query_string一样 |
| $http_user_agent   | 变量存储的是用户访问服务的代理信息(如果通过浏览器访问，记录的是浏览器的相关版本信息) |
| $host              | 变量存储的是访问服务器的server_name值                        |
| $document_uri      | 变量存储的是当前访问地址的URI。比如http://192.168.200.133/server?id=10&name=zhangsan中的"/server"，功能和$uri一样 |
| $document_root     | 变量存储的是当前请求对应location的root值，如果未设置，默认指向Nginx自带html目录所在位置 |
| $content_length    | 变量存储的是请求头中的Content-Length的值                     |
| $content_type      | 变量存储的是请求头中的Content-Type的值                       |
| $http_cookie       | 变量存储的是客户端的cookie信息，可以通过add_header Set-Cookie 'cookieName=cookieValue'来添加cookie数据 |
| $limit_rate        | 变量中存储的是Nginx服务器对网络连接速率的限制，也就是Nginx配置中对limit_rate指令设置的值，默认是0，不限制。 |
| $remote_addr       | 变量中存储的是客户端的IP地址                                 |
| $remote_port       | 变量中存储了客户端与服务端建立连接的端口号                   |
| $remote_user       | 变量中存储了客户端的用户名，需要有认证模块才能获取           |
| $scheme            | 变量中存储了访问协议                                         |
| $server_addr       | 变量中存储了服务端的地址                                     |
| $server_name       | 变量中存储了客户端请求到达的服务器的名称                     |
| $server_port       | 变量中存储了客户端请求到达服务器的端口号                     |
| $server_protocol   | 变量中存储了客户端请求协议的版本，比如"HTTP/1.1"             |
| $request_body_file | 变量中存储了发给后端服务器的本地文件资源的名称               |
| $request_method    | 变量中存储了客户端的请求方式，比如"GET","POST"等             |
| $request_filename  | 变量中存储了当前请求的资源文件的路径名                       |
| $request_uri       | 变量中存储了当前请求的URI，并且携带请求参数，比如http://192.168.200.133/server?id=10&name=zhangsan中的"/server?id=10&name=zhangsan" |

例如：

```nginx
server {
    listen 8081;
    server_name localhost;
    location /server {
        root /usr/local/nginx/abc;
        set $name TOM;
        set $age 18;
        default_type text/plain;
        # 这个$args就是内置全局变量，拿到的是url栏上 ?后面的内容 
        return 200 $name=$age=$args=$http_user_agent=$host=$document_root;
    }
}
```

访问：`http://192.168.200.133:8081/server?username=JERRY&gender=1`

效果如图：

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image6s6hlgez73g0.webp)



上述参数还可以在日志文件中使用，这个就要用到前面我们介绍的`log_format`指令

```nginx
log_format main '$remote_addr - $request - $status-$request_uri  $http_user_agent';
access_log logs/access.log main;
```

**把访问的信息记录在日志中**

```nginx
http{
	# ......
    # 自定义日志格式
	log_format main '$remote_addr - $request - $status - $request_uri - $http_user_agent';
    
    server {
        listen 8081;
        server_name localhost;
        location /server {
        	access_log logs/access.log main; #记录日志并指定使用自定义日志格式
            root /usr/local/nginx/abc;
            set $name TOM;
            set $age 18;
            default_type text/plain;
            return 200 $name=$age=$args=$http_user_agent=$host=$document_root;
        }
    }
}
```

访问：`http://192.168.200.133:8081/server?username=JERRY&gender=1`

然后查看日志，效果如图：

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image23y9h76w29b4.webp)





#### if指令

该指令用来支持条件判断，并根据条件判断结果选择不同的Nginx配置。

| 语法   | if  (condition){...} |
| ------ | -------------------- |
| 默认值 | —                    |
| 位置   | server、location     |

> 我想问下，实际生产环境中什么场景下会用到set和if这俩指令？比如灰度，只对某个IP地址进行路由转发时

if 和括号之间要有空格，condition为判定条件，可以支持以下写法：

1\. 变量名。如果变量名对应的值为空字符串或"0"，if都判断为false，其他条件为true。

```nginx
if ($param){
	
}
```



2\. 使用『 = 』和『 != 』比较变量和字符串是否相等，满足条件为true，不满足为false

```nginx
if ($request_method = POST){
	return 405;
}
```

注意：此处POST和Java不太一样的地方是字符串不需要添加引号，并且等号和不等号前后到需要加空格。



3\. 使用正则表达式对变量进行匹配，匹配成功返回true，否则返回false。变量与正则表达式之间使用 『~ 』，『 ~* 』，『 !~ 』，『 !~* 』来连接。

- 『 ~ 』代表匹配正则表达式过程中区分大小写，进行模糊匹配
- 『 ~* 』代表匹配正则表达式过程中不区分大小写，进行模糊匹配
- 『 !~ 』和『 !~* 』刚好和上面取相反值，如果匹配上返回 false，匹配不上返回 true，进行模糊匹配

```nginx
if ($http_user_agent ~ MSIE){
	#$http_user_agent的值中是否包含MSIE字符串，如果包含返回true
}
```

注意：正则表达式字符串一般不需要加引号，但是如果字符串中包含"}"或者是";"等字符时，就需要把引号加上。



4\. 判断请求的文件是否存在使用『 -f 』和『 !-f 』

- 当使用『 -f 』时，如果请求的文件存在返回 true，不存在返回 false。
- 当使用『 !-f 』时，如果请求文件不存在，但该文件所在目录存在返回 true，文件和目录都不存在返回 false，如果文件存在返回 false。


```nginx
if (-f $request_filename){
	#判断请求的文件是否存在
}
if (!-f $request_filename){
	#判断请求的文件是否不存在
}
```

例如：用户访问的页面不存在，则返回一个友好的提示

```nginx
location / {
    root html;
    default_type text/html;
    # 判断请求的文件是否不存在
    if (!-f $request_filename){
        return 200 '<h1>不好意思，文件资源找不到！</h1>';
    }
}
```



5\. 判断请求的目录是否存在使用『 -d 』和『 !-d 』

- 当使用『 -d 』时，如果请求的目录存在，返回 true，如果目录不存在则返回 false。
- 当使用『 !-d 』时，如果请求的目录不存在但该目录的上级目录存在则返回 true，该目录和它上级目录都不存在则返回 false，如果请求目录存在也返回false。

6\. 判断请求的目录或者文件是否存在使用『-e』和『!-e』

- 当使用『-e』，如果请求的目录或者文件存在时，if返回true，否则返回false.

- 当使用『!-e』，如果请求的文件和文件所在路径上的目录都不存在返回true，否则返回false

7\. 判断请求的文件是否可执行使用『-x』和『!-x』

- 当使用『-x』，如果请求的文件可执行，if返回true，否则返回false

- 当使用『!-x』，如果请求文件不可执行，返回true，否则返回false

> 5、6、7不常用



#### break指令

该指令用于中断当前相同作用域中的其他Nginx配置。**与该指令处于同一作用域的Nginx配置中，位于它前面的指令配置生效，位于后面的指令配置无效**。并且break还有另外一个功能就是**终止当前的匹配并把当前的URI在本location进行重定向访问处理**。

| 语法   | break;               |
| ------ | -------------------- |
| 默认值 | —                    |
| 位置   | server、location、if |

例子:

```nginx
location /testbreak{
	default_type text/plain; #指定返回类型
	set $username TOM; #定义变量
	if ($args){ #拿到get的请求参数
		set $username JERRY; #生效
        break; #if块作用域下，之前的指令生效，之后的指令失效
		set $username ROSE; #失效
	}
	add_header username $username;
	return 200 $username;
}
```

不带参数访问：`http://192.168.200.133:8081/testbreak`

效果如图：

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image2ok6tnbtnx20.webp)

带参数访问：`http://192.168.200.133:8081/testbreak/1`

效果如图：(注意：会重定向到 /html/testbreak/index.html(如果不配置会报错)，重定向之后才会跳出代码块继续执行后续指令)

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image1f6a03pxv4ow.webp)





#### return指令

该指令用于完成对请求的处理，直接向客户端返回。在return后的所有Nginx配置都是无效的。

| 语法   | return code [text];<br/>return code URL;<br/>return URL; |
| ------ | -------------------------------------------------------- |
| 默认值 | —                                                        |
| 位置   | server、location、if                                     |

- code：返回给客户端的 HTTP 状态代理。可以返回的状态代码为 0 ~ 999 的任意 HTTP 状态代理
- text：返回给客户端的响应体内容，支持变量的使用和 JSON 字符串
- URL：跳转给客户端的 URL 地址。

```nginx
location /testreturn {
    default_type text/plain; #将状态码显示到页面
    return 200 success; #页面上展示的是success
}

location /testreturn {
    return https://www.baidu.com; # 302重定向到百度
}
# 与上面那个效果是一致的
location /testreturn {
    # 302临时跳转；301永久跳转
    return 302 https://www.baidu.com;
}

location /testreturn {
    return 302 www.baidu.com; #不允许这么写
}
```



#### rewrite指令（核心）

该指令通过正则表达式的使用来改变URI。可以同时存在一个或者多个指令，按照顺序依次对URL进行匹配和处理。把匹配成功的uri重新为一个新的uri，去返回给用户具体的结果

URL和URI的区别：

- URI：统一资源标识符
- URL：统一资源定位符

| 语法   | rewrite regex replacement [flag]; |
| ------ | --------------------------------- |
| 默认值 | —                                 |
| 位置   | server、location、if              |

- regex：用来匹配 URI 的正则表达式

- replacement：匹配成功后，用于替换 URI 中被截取内容的字符串。如果该字符串是以 『 http:// 』或者『 https:// 』开头的，则不会继续向下对URI 进行其他处理，而是直接返回重写后的 URI 给客户端。

  例如：（括号的值会作为 $1 的值）^ 代表匹配输入字符串的起始位置

```nginx
# ......
listen 8081;

location rewrite {
    # ^开始 $结束 以/rewrite/url*都会匹配到，匹配到后修改url为后面的
    # ip:端口/rewrite/url* 走这个
	rewrite ^/rewrite/url\w*$ https://www.baidu.com;
    # ip:端口/rewrite/test*，则重写 url 为 test
	rewrite ^/rewrite/(test)\w*$ /$1; # /rewrite/test 就走下面的/test
    # ip:端口/rewrite/demo*，则重写 url 为 demo
	rewrite ^/rewrite/(demo)\w*$ /$1;
}

location /test{ # 重写后的 url 如果为 test，触发 location
	default_type text/plain;
	return 200 test_success;
}
location /demo{ # 重写后的 url 如果为 demo，触发 location
	default_type text/plain;
	return 200 demo_success;
}
```

访问 `http://192.168.200.113/8081/rewrite/urlxxx`，跳转到 `https://www.baidu.com`。

访问 `http://192.168.200.113/8081/rewrite/testxxx`，返回 test_sucess。

访问 `http://192.168.200.113/8081/rewrite/demoxxx`，返回 demo_sucess。



flag：用来设置rewrite对URI的处理行为，可选值有如下：

- `last`：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行处理。该标志将重写后的URI重写在server块中执行，为重写后的URI提供了转入到其他location块的机会。**重写地址后访问其他的 location 块，浏览器地址栏 URL 地址不变**

```nginx
# ......
listen 8081;
location /rewrite {
    # 如果在后面加了 last，匹配成功后会使用新的uri在整个server块中找到对应的location来处理
    rewrite ^/rewrite/(test)\w*$ /$1 last;   # 如果是 /rewrite/testxxx，则重写 url 为 test
    rewrite ^/rewrite/(demo)\w*$ $1 last;    # 如果是 /rewrite/demoxxx，则重写 url 为 demo
}
location /test {   # 重写后的 url 如果为 test，触发 location
    default_type text/plain;
    return 200 test_sucess;
}
location /demo {   # 重写后的 url 如果为 demo，触发 location
    default_type text/plain;
    return 200 demo_sucess;
}
#这个last的意思是当前的正则匹配一次后改了uri，再用uri重新用当前正则再匹配，不断循环，不信试试~/^abc$ /abc last; 会循环到你报500
```

访问 `http://192.168.200.133:8081/rewrite/testabc`，能正确访问

![1589475653252](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1589475653252.png)

访问 `http://192.168.200.113/8081/rewrite/demoxxx`，返回 demo_sucess。

单次访问不明显，多次访问，last 只处理第一个。

- `break`：将此处重写的 URl 作为一个新的 URI，在本块中继续进行处理。该标志将重写后的地址在当前的 location 块中执行，不会将新的 URI 转向其他的 location 块。**仅仅重写地址，不会触发其他 location 块，浏览器地址栏 URL 地址不变**

```nginx
# ......
listen 8081;
location /rewrite {
    rewrite ^/rewrite/(test)\w*$ /$1 break;   # 如果是 /rewrite/testxxx，则重写 url 为 test
    rewrite ^/rewrite/(demo)\w*$ $1 break;    # 如果是 /rewrite/demoxxx，则重写 url 为 demo
    
    # /test 和 /demo 就在当前块进行处理，所以会在当前的 location 块找到如下 html 页面：
    # /usr/local/nginx/html/test/index.html
    # /usr/local/nginx/html/demo/index.html
}
location /test {   # 重写后的 url 如果为 test，触发 location
    default_type text/plain;
    return 200 test_sucess;
}
location /demo {   # 重写后的 url 如果为 demo，触发 location
    default_type text/plain;
    return 200 demo_sucess;
}
```

和 break 指令类似。假设访问的是 /test，则将 /test 放在当前的 location 块进行处理，哪怕第二个 location 块就是处理 /test 的，它也不会去找第二个 location 块，只在当前块进行处理。所以他会请求 `/usr/local/nginx/html/test/index.html`。

访问 `http://192.168.200.133:8081/rewrite/demoabc`，页面报404错误(因为没有html/test/index.html页面)

![1589475732042](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1589475732042.png)

- `redirect`：将重写后的 URI 返回给客户端，**状态码为 302，指明是临时重定向 URL**，主要用在 replacement 变量不是以『 http:// 』或者『 https:// 』开头的情况

```nginx
# ......
listen 8081;
location /rewrite {
    rewrite ^/rewrite/(test)\w*$ /$1 redirect;   # 如果是 /rewrite/testxxx，则重写 url 为 test
    rewrite ^/rewrite/(demo)\w*$ $1 redirect;    # 如果是 /rewrite/demoxxx，则重写 url 为 demo
}
location /test {   # 重写后的 url 如果为 test，触发 location
    default_type text/plain;
    return 200 test_sucess;
}
location /demo {   # 重写后的 url 如果为 demo，触发 location
    default_type text/plain;
    return 200 demo_sucess;
}
```

访问`http://192.168.200.133:8081/rewrite/testabc`请求会被临时重定向，浏览器地址也会发生改变

特点是重定向，就是浏览的地址栏会发送改变。如发送请求 `/testxxx`，它会重定向到 `/test`，触发第二个 location 块，浏览的地址栏也会由 `/testxxx` 变成 `/test`。

- `permanent`：将重写后的 URI 返回给客户端，**状态码为 301，指明是永久重定向 URL**，主要用在 replacement 变量不是以『 http:// 』或者『 https:// 』开头的情况

```nginx
# ......
listen 8081;
location /rewrite {
    rewrite ^/rewrite/(test)\w*$ /$1 permanent;   # 如果是 /rewrite/testxxx，则重写 url 为 test
    rewrite ^/rewrite/(demo)\w*$ $1 permanent;    # 如果是 /rewrite/demoxxx，则重写 url 为 demo
}
location /test {   # 重写后的 url 如果为 test，触发 location
    default_type text/plain;
    return 200 test_sucess;
}
location /demo {   # 重写后的 url 如果为 demo，触发 location
    default_type text/plain;
    return 200 demo_sucess;
}
```

访问`http://192.168.200.133:8081/rewrite/testabc`请求会被永久重定向，浏览器地址也会发生改变

和 `redirect` 的区别就是状态码为 301，并且是永久重定向。

> redirect和permanent与搜索引擎优化有关



##### flag 总结

| 标记符号  | 说明                                                 |
| --------- | ---------------------------------------------------- |
| last      | 本条规则匹配完成后继续向下匹配新的 location URI 规则 |
| break     | 本条规则匹配完成后终止，不在匹配任何规则             |
| redirect  | 返回 302 临时重定向                                  |
| permanent | 返回 301 永久重定向                                  |

- break 与 last 都停止处理后续重写规则，只不过 last 会重新发起新的请求并使用新的请求路由匹配location，但 break 不会。所以当请求 break 时，如匹配成功，则请求成功，返回 200；如果匹配失败，则返回 404
- 服务器配置好 redirect 和 permanent 之后，打开浏览器分别访问这两个请求地址，然后停止 Nginx 服务。这时再访问 redirect 请求会直接报出无法连接的错误。但是 permanent 请求是永久重定向，浏览器会忽略原始地址直接访问永久重定向之后的地址，所以请求仍然成功。（这个验证不能禁用浏览器的缓存，否则即使是 permanent 重定向，浏览器仍然会向原始地址发出请求验证之前的永久重定向是否有效）
- 对于搜索引擎来说，搜索引擎在抓取到 301 永久重定向请求响应内容的同时也会将原始的网址替换为重定向之后的网址，而对于 302 临时重定向请求则仍然会使用原始的网址并且可能会被搜索引擎认为有作弊的嫌疑。所以对于线上正式环境来讲，尽量避免使用 302 跳转
- 如果 replacement 以 「 http:// 」或「 https:// 」或「 $scheme 」开始，处理过程将终止，并将这个重定向直接返回给客户端





#### rewrite_log指令

该指令配置是否开启URL重写日志的输出功能，默认关闭。

| 语法   | rewrite_log on\|off;       |
| ------ | -------------------------- |
| 默认值 | rewrite_log off;           |
| 位置   | http、server、location、if |

开启后，URL重写的相关日志将以notice级别输出到error_log指令配置的日志文件汇总。

```nginx
location /rewrite_log {
    rewrite_log on;    # 开启重写日志
	error_log logs /error.log notice;   # 切换为 notice 模式，因为只支持这个模式
    return 200 '开启了重写日志';
}
```

> 开启这个rewrite_log，就可以方便监控整个rewrite的模块是怎么跳转，怎么匹配的。那个rewrite跳转到哪个地址



### Rewrite的案例

#### 域名跳转

》问题分析

先来看一个效果，如果我们想访问京东网站，大家都知道我们可以输入`www.jd.com`,但是同样的我们也可以输入`www.360buy.com`同样也都能访问到京东网站。这个其实是因为京东刚开始的时候域名就是www.360buy.com，后面由于各种原因把自己的域名换成了www.jd.com, 虽然说域名变量，但是对于以前只记住了www.360buy.com的用户来说，我们如何把这部分用户也迁移到我们新域名的访问上来，针对于这个问题，我们就可以使用Nginx中Rewrite的域名跳转来解决。

》环境准备

- 准备三个域名：

```sh
vim /etc/hosts
```

```http
127.0.0.1   www.itcast.cn
127.0.0.1   www.itheima.cn
127.0.0.1   www.itheima.com
  访问三个域名中的任意一个，都跳转到 www.itcast.cn
```

- 通过Nginx实现访问www.itcast.cn

```nginx
server {
	listen 80;
	server_name www.itcast.cn;
	location /{
		default_type text/html;
		return 200 '<h1>welcome to itcast</h1>';
	}
}
```

》通过Rewrite完成将www.ithema.com和www.itheima.cn的请求跳转到www.itcast.com

```nginx
server {
	listen 80;
	server_name www.itheima.com www.itheima.cn;
    # 如果能进入这个server块，且满足上面两个域名的要求，就跳转到
    # ^/ 以/开头的 都跳转到http://www.itcast.cn。注意http://不能省略
	rewrite ^/ http://www.itcast.cn;
}
```

问题描述：如何在域名跳转的过程中携带请求的URI？比如 `www.itheima.com?part=显示器` 变成 `www.itcast.cn?part=显示器`

修改配置信息

```nginx
server {
	listen 80;
	server_name www.itheima.com www.itheima.cn;
    # 匹配任意多个字符 由于加了()，所以可以直接通过$1来引用其值
	rewrite ^(.*) http://www.itcast.cn$1;
    #括号里是 www.itheima.com 后面出现 0 次或 多次不以 \n（换行）结尾的值，该值赋给 $1。
    #rewrite ^(.*) http://www.itcast.cn$1 permanent; # 永久重定向
}
```



#### 域名镜像

镜像网站指定是将一个完全相同的网站分别放置到几台服务器上，并分别使用独立的URL进行访问。其中一台服务器上的网站叫主站，其他的为镜像网站。镜像网站和主站没有太大的区别，**可以把镜像网站理解为主站的一个备份节点**。可以通过镜像网站提供网站在不同地区的响应速度。镜像网站可以平衡网站的流量负载、可以解决网络宽带限制、封锁等。

> 我们可以为每个镜像网站提供一个域名，这样假设某个域名被限制了，另外两台服务器还是可以正常访问

![1589560433192](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1589560433192.png)

而我们所说的域名镜像和网站镜像比较类似，上述案例中，**将www.itheima.com和 www.itheima.cn都能跳转到www.itcast.cn，那么www.itcast.cn我们就可以把它起名叫主域名，其他两个就是我们所说的镜像域名**，当然如果我们不想把整个网站做镜像，只想为其中某一个子目录下的资源做镜像，我们可以在location块中配置rewrite功能，比如：

```nginx
server {
    listen          80;
    server_name     www.itheima.cn www.itheima.com;
    # 来到这里，说明匹配到了上面的两个域名之一
    location /user { #这两个域名的user模块，我们都转发到http://www.itcast.cn，其他模块不进行跳转
    	# 正则表达式 ^开头 $结尾 以/user的所有请求都转发到http://www.itcast.cn
        rewrite ^/user(.*)$ http://www.itcast.cn$1;
    }
    location /emp{ #这两个域名的emp模块，我们直接展示，不进行域名跳转
        default_type text/html;
        return 200 '<h1>emp_success</h1>';
    }
}
```

比如用户可以跳到首页 Web下，而管理员跳转到后台 Web，我们可以在 location 块中配置 Rewrite 功能。

```nginx
server {
	listen 80;
	server_name rewrite.myweb.com;
	location ^~ /user {
		rewrite ^/user(.*) http://www.myweb.com/index$1 last;  # 用户跳到首页
	}
	location ^~ /manage {
		rewrite ^/manage(.*) http://www.myweb.com/manage$1 last;  # 管理员跳到后台
	}
}
```



#### 独立域名

一个完整的项目包含多个模块，比如购物网站有商品搜索模块、商品详情模块和购物车模块等，那么我们如何为每一个模块设置独立的域名。

需求：(由于我们是直接写入host文件，IP都是本机IP，所以只能根据端口区分一下。实际场景肯定IP不一致)

```http
http://search.itcast.com:81  访问商品搜索模块
http://item.itcast.com:82	  访问商品详情模块
http://cart.itcast.com:83	  访问商品购物车模块
```

```nginx
server{
	listen 81;
	server_name search.itcast.com;
	rewrite ^(.*) http://www.itcast.cn/search$1;
}
server{
	listen 82;
	server_name item.itcast.com;
	rewrite ^(.*) http://www.itcast.cn/item$1;
}
server{
	listen 83;
	server_name cart.itcast.com;
	rewrite ^(.*) http://www.itcast.cn/cart$1;
}
```



#### 目录自动添加"/"

问题描述：有时候访问的地址要求后面以 `/` 结尾，那么我们需要解决如果用户忘记输入 `/`，Nginx 就会自动加上 `/`。

通过一个例子来演示下问题：

```nginx
server {
	listen	80;
	server_name localhost;
	location / {
		root html;
		index index.html;
	}
}
```

要想访问上述资源，很简单，只需要通过 `http://192.168.200.133` 直接就能访问，地址后面不需要加 /，但是如果将上述的配置修改为如下内容

```nginx
server {
	listen	8082;
	server_name localhost;
	location /heima {
		root html;
		index index.html;
	}
}
```

这个时候，要想访问上述资源，按照上述的访问方式，我们可以通过 `http://192.168.200.133/heima/` 来访问，但是如果地址后面不加斜杠，如 `http://192.168.200.133/heima`。我们发现进行了两次请求，第一次请求对应状态码为301，301是永久重定向；第二次访问才是正常的200。也就是虽然页面正常显示，但这是第二次请求成功才展示的

通过`http://192.168.200.133:8082/heima`和通过`http://192.168.200.133:8082/heima/`访问的区别？

**如果不加斜杠，Nginx服务器内部会自动做一个301的重定向**，重定向的地址会有一个指令叫server_name_in_redirect on|off;来决定重定向的地址：

- 如果该指令为on
  - 重定向的地址为:  http://server_name:8082/目录名/;
    	http://localhost:8082/heima/
- 如果该指令为off
  - 重定向的地址为:  http://原URL中的域名:8082/目录名/;
    	http://192.168.200.133:8082/heima/

所以就拿刚才的地址来说，http://192.168.200.133:8082/heima如果不加斜杠，那么按照上述规则

- 如果指令server_name_in_redirect为on，则301重定向地址变为 http://localhost:8082/heima/
- 如果为off，则301重定向地址变为http://192.168.200.133:8082/heima/。后面这个是正常的，前面地址就有问题。

注意`server_name_in_redirect`指令在**Nginx的0.8.48版本之前默认都是on，之后改成了off**，所以现在我们这个版本不需要考虑这个问题，但是如果是0.8.48以前的版本并且server_name_in_redirect设置为on，我们如何通过rewrite来解决这个问题？



解决方案

我们可以使用rewrite功能为末尾没有斜杠的URL自动添加一个斜杠

```nginx
server {
	listen	80;
	server_name localhost;
	server_name_in_redirect on; # 如果这个按钮是开启的
    # 只有我们访问的是一个目录，我们才需要加/
	location /heima {
		if (-d $request_filename){ # 如果请求的资源目录存在，就是判断访问的是否为目录
            # 是目录，添加/。匹配 /任意多个字符 ([^/])判断不是以/结尾的
			rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent; # $2 获取第二个括号的值：/
		}
	}
    # $1 是第一个括号的值，$2 是第二个括号的值
}
```

> 注意：咱现在这个版本没必要这么麻烦了，已经可以解决/带来的问题；如果版本在0.8.48版本之前需要考虑这个问题



#### 合并目录

搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提高目的网站在有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含**URL的目录层级一般不要超过三层**，否则的话不利于搜索引擎的搜索也给客户端的输入带来了负担，但是将所有的文件放在一个目录下又会导致文件资源管理混乱并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用rewrite如何解决上述问题？

举例，网站中有一个资源文件的访问路径时 /server/11/22/33/44/20.html，也就是说20.html存在于第5级目录下，如果想要访问该资源文件，客户端的URL地址就要写成 `http://192.168.200.133/server/11/22/33/44/20.html`

```nginx
server {
	listen 8083;
	server_name localhost;
	location /server{
		root html;
        index index.html
	}
}
```

但是这个是非常不利于SEO搜索引擎优化的，同时客户端也不好记。使用rewrite我们可以进行如下配置:

```nginx
server {
	listen 8083;
	server_name localhost;
	location /server{
		rewrite ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /server/$1/$2/$3/$4/$5.html last;
	}
}
```

这样的话，客户端只需要输入http://www.web.name/server-11-22-33-44-20.html就可以访问到20.html页面了。这里也充分利用了rewrite指令支持正则表达式的特性。



#### 多级域名

当你配置了多级域名，如二级域名 `xxx.frxcat.fun`，并且静态资源目录恰好和二级域名的 `xxx` 可以匹配，则可以使用正则表达式进行匹配，日后，如果有多个 `xxx`，则再创建对应的该目录即可。

```nginx
server {
	listen 80;
	server_name ~^(.+)?.frxcat.fun$;
    index idnex.html;
    if ($host = frxcat.fun){
        rewrite ^(.*)$ https://www.frxcat.fun$2 permanent;
    }
    root /data/html/$1/;
}
```

这样访问 `docs.frxcat.fun`，自动去 `/data/html/docs/` 目录下找到 index.html，如果是 `bing.youngkbt.cn`，则会去 `/data/html/bing/` 目录下找到 idnex.html，以此类推。

if 语句的作用是将 `frxcat.fun` 重定向到 `www.frxcat.fun`，这样既解决了网站的主目录访问，又可以增加 SEO 中对 `www.frxcat.fun` 的域名权重。





#### 防盗链

防盗链之前我们已经介绍过了相关的知识，在rewrite中的防盗链和之前将的原理其实都是一样的，只不过通过rewrite可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用rewrite将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。下面我们就通过根据文件类型实现防盗链的一个配置实例：

```nginx
location /images {
    root html;
    valid_referers none blocked www.baidu.com;
    if ($invalid_referer){
        #return 403;
        rewrite ^/    /images/forbidden.png break;
        # 这里用last的话好像又会出现盗链
    }
}
```

下面有两个配置实例：

- 根据文件类型实现防盗链配置：

```nginx
server{
	listen 80;
	server_name www.web.com;
	locatin ~* ^.+\.(gif|jpg|png|swf|flv|rar|zip)$ {
		valid_referers none blocked server_names *.web.com; # server_names 后指定具体的域名或者 IP
		if ($invalid_referer){
			rewrite ^/ http://www.web.com/images/forbidden.png;  # 跳转到默认地址
		}
	}
}
```

- 根据目录实现防盗链配置：

```nginx
server{
	listen 80;
	server_name www.web.com;
	location /file {
		root /server/file;  # 资源在 server 目录下的 file 目录里
		valid_referers none blocked server_names *.web.com; # server_names 后指定具体的域名或者 IP
		if ($invalid_referer){
			rewrite ^/ http://www.web.com/images/forbidden.png;  # 跳转到 file 目录下的图片
		}
	}
}
```



#### [#](https://frxcat.fun/middleware/Nginx/NginxStatic_resource_access/#访问限流)访问限流

我们构建网站是为了让用户访问它们，我们希望用于合法访问。所以不得不采取一些措施限制滥用访问的用户。这种滥用指的是从同一 IP 每秒到服务器请求的连接数。因为这可能是在同一时间内，世界各地的多台机器上的爬虫机器人多次尝试爬取网站的内容。

```nginx
# 限制用户连接数来预防 DOS 攻击
limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;
# 限制同一客户端 ip 最大并发连接数
limit_conn perip 2;
# 限制同一server最大并发连接数
limit_conn perserver 20;
# 限制下载速度，根据自身服务器带宽配置
limit_rate 300k; 
```



#### [#](https://frxcat.fun/middleware/Nginx/NginxStatic_resource_access/#链接超时)链接超时

长时间占着连接资源不释放，最终会导致请求的堆积，Nginx 处理请求效率大大降低。所以我们对连接的控制都要注意设置超时时间，通过超时机制自动回收资源、避免资源浪费。

```nginx
# 客户端、服务端设置
server_names_hash_bucket_size 128;
server_names_hash_max_size 512;
# 长连接超时配置
keepalive_timeout  65;
client_header_timeout 15s;
client_body_timeout 15s;
send_timeout 60s;

# 代理设置
# 与后端服务器建立连接的超时时间。注意这个一般不能大于 75 秒
proxy_connect_timeout 30s;
proxy_send_timeout 120s;
# 从后端服务器读取响应的超时
proxy_read_timeout 120s;
```



#### [#](https://frxcat.fun/middleware/Nginx/NginxStatic_resource_access/#html引入)HTML引入

我们编写 .html 文件的时候，难免需要引入 css 和 js 文件，如果是在本地，那么引入非常简单，直接相对路径即可，但是部署到 Nginx 时，相对路径不再是相对 html 文件的目录，所以生产环境和开发环境的引入格式不一样。

在 Nginx 中的 .html 文件，引入 css 和 js，要加上 `/` 作为开头，`/` 代表 Nginx 的根目录，即配置文件 `location /` 的指定的 root 路径。

比如 Nginx 的配置文件内容如下：

```nginx
server {
	listen 80;
    server_name localhost;
    
    location / {
        root /usr/local/nginx/html; # 静态文件根目录
        index idnex.html;
    }
}
```

有一个 aa.html 在 `/usr/local/nginx/html/test` 目录下，并且 aa.html 引入了 aa.css 和 aa.js，两个静态文件在 aa.html 所在目录的 static 文件夹里。

```sh
/usr/local/nginx/html/test 目录
├── a.html
├── static
│	├── a.css
│	├── a.js
```

在本地环境，我们可以这样写：

```html
<link rel="stylesheet" href="static/aa.css" />
<script src="static/aa.js"></script>
```

但是部署到 Nginx 后，这样写会找不到这两个资源，因为 `/` 触发 `location /`，进入 `/usr/local/nginx/html` 目录，而这两个文件在 `/usr/local/nginx/html/test/static` 目录下，所以我们部署到 Nginx 后，需要修改为：

```html
<link rel="stylesheet" href="/test/static/aa.css" />
<script src="/test/static/aa.js"></script>
```









## Nginx反向代理

### Nginx反向代理概述

关于正向代理和反向代理，我们在前面的章节已经通过一张图给大家详细的介绍过了，简而言之就是**正向代理代理的对象是客户端，反向代理代理的是服务端**，这是两者之间最大的区别。

Nginx即可以实现正向代理，也可以实现反向代理。

我们先来通过一个小案例演示下Nginx正向代理的简单应用。

先提需求：

![](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1581846370052.png)

(1)服务端的设置：

```nginx
http {
  log_format main 'client send request=>clientIp=$remote_addr serverIp=>$host';
	server{
		listen 80;
		server_name	localhost;
		access_log logs/access.log main;
		location {
			root html;
			index index.html index.htm;
		}
	}
}
```

(2)使用客户端访问服务端：`http://192.168.200.133`，打开日志查看结果

![1589729000713](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1589729000713.png)

(3)代理服务器设置：

```nginx
server {
    listen  82;
    resolver 8.8.8.8;   # 设置 DNS 的 IP，用来解析 proxy_pass 中的域名
    location / {
        proxy_pass http://$host$request_uri;   # proxy_pass 实现正向代理
    }
}
```

`proxy_pass` 后面有讲解。

(4)查看代理服务器的IP(192.168.200.146)和Nginx配置监听的端口(82)

(5)在客户端配置代理服务器的 IP(192.168.200.146)和 Nginx 配置监听的端口(82)

![](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1581847577947.png)

(6)设置完成后，再次通过浏览器访问服务端

![1589729479920](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1589729479920.png)

通过对比，上下两次的日志记录，会发现虽然我们是客户端访问服务端，但是如何使用了代理，那么服务端能看到的只是代理发送过去的请求，这样的话，就使用Nginx实现了正向代理的设置。

但是Nginx正向代理，在实际的应用中不是特别多，所以我们简单了解下，接下来我们继续学习Nginx的反向代理，这是Nginx比较重要的一个功能。





### Nginx反向代理的配置语法

> 客户端、代理服务器(nginx)、服务器；现在采用反向代理，代理服务器服务的是服务端，所以会将服务端的访问地址配置在nginx，当用户从客户端发送请求nginx，nginx通过反向代理将请求分发到具体服务器

Nginx反向代理模块的指令是由`ngx_http_proxy_module`模块进行解析，该模块在安装Nginx的时候已经自己加装到Nginx中了，接下来我们把反向代理中的常用指令一一介绍下：

- proxy_pass
- proxy_set_header
- proxy_redirect

这里只介绍三个指令，关于反向代理的指令非常多，想要了解更多，请前往 [Nginx 反向代理文档](https://nginx.org/en/docs/stream/ngx_stream_proxy_module.html)



#### proxy_pass

> proxy_pass和rewrite有什么区别？rewrite是让客户端自己去请求，proxy_pass是代理替客户端去请求

**该指令用来设置被代理服务器地址**，可以是主机名称、IP地址加端口号形式。没有默认值。

| 语法   | proxy_pass URL; |
| ------ | --------------- |
| 默认值 | —               |
| 位置   | location        |

`URL`：为要设置的被代理服务器地址，包含传输协议(`http`、`https://`)、主机名称或 IP 地址加端口号、URI 等要素。

例如：

```nginx
#将用户请求分发到百度首页去
proxy_pass http://www.baidu.com;

# 例子
location /server {
    # 结尾不加斜杠
    proxy_pass http://192.168.200.146; #这个IP配置的是服务器的IP，将客户端发来的请求发送到了服务端。所以有什么问题也要去服务端的日志进行查看
    # 访问的是：http://192.168.200.146/server/index.html

    # 结尾加斜杠
    proxy_pass http://192.168.200.146/;
    # 访问的是：http://192.168.200.146/index.html
}
```

**实例**

准备两台服务器或者按照 Linux 系统的虚拟机，这里是 `192.168.200.133` 和 `192.168.200.146`，为了方便，我们称前者为服务器 A，后者为服务器 B。

1. 在服务器 A 的 Nginx 配置文件添加如下内容：

```nginx
http {
    # ......
    server {
        listen 8080;
        server_name localhost;
        location / {
            proxy_pass http://192.168.200.146;
        }
    }
    # ......
}
```

当客户端请求服务器 A `http://192.168.200.133`，它会转发给服务器 B，此时的服务器 A 就是一个代理的角色。

访问服务器 A，我们看到 Nginx 的欢迎界面其实是服务器 B 的 Nginx，可以在服务器 B 的 Nginx 欢迎页面添加新的内容：`I am 146`，再次访问服务器 A，效果如图：

![image](day03_反向代理.https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image4ai1u3uxs940.webp)

**大家在编写proxy_pass的时候，后面的值要不要加"/"**？这是看情况的。

接下来通过例子来说明刚才我们提到的问题：

```nginx
server {
	listen 80;
	server_name localhost;
	location /{
        # 下面两个地址加不加斜杠，效果都一样，因为 location 后的 / 会添加在代理地址后面
		proxy_pass http://192.168.200.146;
		proxy_pass http://192.168.200.146/;
	}
}
#当客户端访问 http://localhost/index.html,效果是一样的

server{
	listen 80;
	server_name localhost;
	location /server{
		# 下面两个地址必须加斜杠，因为 location 后的 /server 会添加在代理地址后面，第一个将没有/结尾
		#proxy_pass http://192.168.200.146;
		proxy_pass http://192.168.200.146/;
	}
}
# 当客户端访问 http://localhost/server/index.html
# 这个时候，第一个proxy_pass就变成了 http://localhost/server/index.html
# 第二个proxy_pass就变成了 http://localhost/index.html 效果就不一样了。
```

- 第一个 location（第 4 行代码）：当客户端访问 `http://localhost/index.html`，两个 `proxy_pass` 效果是一样的，因为 location 后的 `/` 会添加在代理地址后面，所以有没有 `/`，效果都一样。

- 第二个 location（第 14 行代码）：当客户端访问 `http://localhost/server/index.html`，这个时候，第一个 proxy_pass 就变成了 `http://192.168.200.146/server/index.html`，第二个 proxy_pass 就变成了 `http://192.168.200.146/index.html` 效果就不一样了

  如果不以 `/` 结尾，则 location 后的 `/server` 会添加在地址后面，所以第一个 proxy_pass 因为没有 `/` 结尾而被加上 `/server`，而第二个自带了 `/` ，所以不会添加 `/server`。

上面的例子仅仅针对：访问任意请求如 `/server` 时，想要代理到其他服务器的首页，则加 `/`，否则你如果真的想访问 `/server` 下的资源，那么不要加 `/`。

**所以加了 `/` 后，请求的是服务器根目录下的资源。**



#### proxy_set_header

该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器（就是传参请求头）。默认值是发送代理服务器的地址和 close。

![](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image4bt7qzhbz1i0.webp)

| 语法   | proxy_set_header field value;                                |
| ------ | ------------------------------------------------------------ |
| 默认值 | proxy_set_header Host $proxy_host;<br/>proxy_set_header Connection close; |
| 位置   | http、server、location                                       |

需要注意的是，如果想要看到结果，必须在被代理的服务器上来获取添加的头信息。

**实例**

被代理服务器：服务器 B `192.168.200.146` 的 Nginx 配置文件内容：

```nginx
server {
    listen  8080;
    server_name localhost;
    default_type text/plain;
    # 问题：这个username可以随意起还是内置变量。
    return 200 $http_username; # 获取代理服务器发送过来的 http 请求头的 username 值
}
```

代理服务器: 服务器 A `192.168.200.133` 的 Nginx 配置文件内容：

```nginx
server {
    listen  8080;
    server_name localhost;
    location /server {           # 访问 /server 触发代理
        proxy_pass http://192.168.200.146:8080/;  # 配置服务器 B 的地址
        #一般我们需要将客户端真实的IP+端口给服务器，不然服务器直接获取的IP是代理服务器的IP
        proxy_set_header username TOM;  # 发送 key 为 username，value 为 TOM 的请求头给服务器B
    }
}
```

访问测试：TOM

客户端访问的是服务器 A，服务器 A 会将请求转发给服务器 B，服务器 B 返回打印 TOM 的页面给服务器 A，服务器 A 最后返回给客户端。



#### proxy_redirect

该指令是用来重置头信息中的『 Location 』和『 Refresh 』的值，防止客户端可以看到被代理服务器的地址。

因为客户端看到的返回结果是『 Location 』和『 Refresh 』的值，所以在到达代理服务器的时，将两个值修改掉，防止客户端直接看到被代理服务器的地址。

| 语法   | proxy_redirect redirect replacement;<br/>proxy_redirect default;<br/>proxy_redirect off; |
| ------ | ------------------------------------------------------------ |
| 默认值 | proxy_redirect default;                                      |
| 位置   | http、server、location                                       |

》为什么要用该指令？

> 简单说就是客户端通过代理服务器访问真实服务器的资源(客户端url栏看到的是代理服务器IP)；如果客户端访问真实服务器资源不存在(代理服务器IP，同时报404)，然后重定向服务器的错误页面，但是这种操作会在url栏暴露真实服务器的IP，我们不希望让客户端看到真实服务器IP。所以需要使用proxy_redirect重写

首先说明一下思路：客户端通过代理服务器 A 访问服务器 B 的资源，但是服务器 B 不存在该资源，则会报错。此时我们不希望它直接返回报错页面给客户端，我们希望服务器 B 返回的是它的欢迎页面。那么如何做呢？

- 首先在服务器 B 进行判断是否存在资源，不存在则返回自己的欢迎页面，即重定向到自己的欢迎页面地址并返回，此时浏览器的地址将会发生改变
- 代理服务器 A 收到服务器 B 的欢迎页面和地址，但是我们不能直接返回给客户端，因为它会暴露服务器 B 的地址，这是重定向的原因

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/imagea4tptcx6lbk.webp)

- 此时用到 `proxy_redirect` 指令，重置服务器 B 返回过来的『 Location 』和『 Refresh 』值，将两个值改为代理服务器 A 的某个地址
- 因为改为了代理服务器 A 的某个地址，所以代理服务器 A 根据这个地址又去获取理服务器 B 的欢迎页面地址，返回给客户端

很绕，简单总结下：客户端通过 A 找 B 不存在的资源，B 不想返回报错页面，于是重定向到自己的欢迎页面地址并返回给 A，A 收到了页面和地址（正常情况不要接收地址，只接收页面），发现不能暴露 B 的地址，于是修改接收的 B 的地址为自己的某一个地址，这个地址会重新发送请求去获取 B 的欢迎页面地址，然后返回给客户端。

这里要明白 B 返回的是重定向后的欢迎页面，重定向后，浏览器地址栏会变成重定向的地址，所以 A 才会以自己的地址转发获取到 B 的地址，所以最后浏览器显示 A 的地址，看到的却是 B 的欢迎页面。



代码：

服务端B：[192.168.200.146]

```nginx
server {
    listen  8081;
    server_name localhost;
    if (!-f $request_filename){ # 判断请求的资源是否存在
    	return 302 http://192.168.200.146; #  2.如果请求的资源不存在，则重定向到服务器 B
    }
}
```

代理服务端A：[192.168.200.133]

```nginx
server {
	listen  8081;
	server_name localhost;
	location / {
		proxy_pass http://192.168.200.146:8081/; # 1.转发给服务器B
		proxy_redirect http://192.168.200.146 http://192.168.200.133; # 3.修改服务器B的地址
	} 
}

# 该 server 去请求服务器 B 的欢迎页面
server {
	listen  80;
	server_name 192.168.200.133;
	location / {
		proxy_pass http://192.168.200.146;  # 4.重新发送请求给服务器 B，获取欢迎页面
	}
}
```

第 6 行代码，当服务器 B 返回的是 `http://192.168.200.146`，为了不让它出现在浏览器的地址栏上，我们需要利用 `proxy_redirect` 将它修改为代理服务器 A 的地址，这个地址会以自己的地址重新访问服务器 B 的欢迎页面，最后返回给客户端。

**该指令的三组选项**

- `proxy_redirect redirect replacement;`

  - redirect：目标，被代理服务器返回的 Location 值
  - replacement：要替换 Location 的值

- `proxy_redirect default;`

  - default：相比较第一组选项，default 仅仅提供了 `redirect` 和 `replacement` 的默认值

    将本范围 location 块的 uri 变量作为 replacement。

    将 proxy_pass 变量作为 redirect

```nginx
server {
	listen  8081;
	server_name localhost;
	location /server { 
		proxy_pass http://192.168.200.146:8081/;
		proxy_redirect default;  # redirect 是 proxy_pass 的值：http://192.168.200.146:8081/
        						 # replacement 是 location 后的值：/server
        # 等价于：proxy_redirect http://192.168.200.146:8081/ /server
	}
}
```

- `proxy_redirect off;`
  - 关闭proxy_redirect的功能







### Nginx反向代理实战

![1581883378672](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1581883378672.png)

服务器 1，2，3 存在两种情况

- 第一种情况：三台服务器的内容不一样
  - 发到指定服务器
- 第二种情况：三台服务器的内容是一样
  - 交给随便一台服务器都行，负载均衡



1\. 如果服务器1、服务器2和服务器3的内容不一样，那我们可以根据用户请求来分发到不同的服务器。

服务器有限，只能以三个端口模拟三台服务器，实际上是一个 IP 对应一个服务器。

代理服务器配置文件内容：（跨域是浏览器的机制，服务器不存在跨域）

```nginx
# 代理服务器
server {
    listen          8082;
    server_name     localhost;
    location /server1 { #真实场景是根据IP来区分的
        proxy_pass http://192.168.200.146:9001/; # 代理 server1
    }
    location /server2 {
        proxy_pass http://192.168.200.146:9002/; # 代理 server1
    }
    location /server3 {
        proxy_pass http://192.168.200.146:9003/; # 代理 server1
    }
}
```

服务器配置文件内容：

```nginx
# 服务端
# server1
server {
    listen          9001;
    server_name     localhost;
    default_type text/html;
    return 200 '<h1>192.168.200.146:9001</h1>'
}
# server2
server {
    listen          9002;
    server_name     localhost;
    default_type text/html;
    return 200 '<h1>192.168.200.146:9002</h1>'
}
# server3
server {
    listen          9003;
    server_name     localhost;
    default_type text/html;
    return 200 '<h1>192.168.200.146:9003</h1>'
}
```

2\. 如果服务器1、服务器2和服务器3的内容是一样的，该如何处理？请看负载均衡的相关内容，里面将进行详细的介绍。



### 斜杠总结

这里将发送 `http://192.168.199.27/frx/xu` 请求。

**不带字符串情况**

| 案例 | localtion | proxy_pass             | 匹配    |
| ---- | --------- | ---------------------- | ------- |
| 1    | /frx      | http://192.168.199.27  | /frx/xu |
| 2    | /frx/     | http://192.168.199.27  | /frx/xu |
| 3    | /frx      | http://192.168.199.27/ | //xu    |
| 4    | /frx/     | http://192.168.199.27/ | /xu     |

若 Nginx 会将原请求路径原封不动地转交给其他地址，如案例 3 和 4。

`proxy_pass` 的 ip:port 后加了 `/`，代表去除掉请求和 location 的匹配的字符串，不加则追加全部请求到地址后面。

**带字符串情况**

| 案例 | localtion | proxy_pass                  | 匹配      |
| ---- | --------- | --------------------------- | --------- |
| 1    | /frx      | http://192.168.199.27/bing  | /bing/xu  |
| 2    | /frx/     | http://192.168.199.27/bing  | /bingxu   |
| 3    | /frx      | http://192.168.199.27/bing/ | /bing//xu |
| 4    | /frx/     | http://192.168.199.27/bing/ | /bing/xu  |

`proxy_pass` 的 ip:port 后加了字符串，Nginx 会将匹配 location 的请求从「原请求路径」中剔除，再不匹配的字符串拼接到 proxy_pass 后生成「新请求路径」，然后将「新请求路径」转交给其他地址。

案例 2 中，`proxy_pass` 的 ip:port 后接了字符串，因此将 location 的 `/frx/` 从原请求路径 `/frx/xu` 中剔除，变为 `xu`，然后将 `xu` 拼接到 `http://192.168.1.48/bing` 后生成了新请求，因此其他地址收到的请求就是 `/bingxu`。





### Nginx的安全控制

关于web服务器的安全是比较大的一个话题，里面所涉及的内容很多，Nginx反向代理是如何来提升web服务器的安全呢？答案是：安全隔离

#### 什么是安全隔离?

通过代理分开了客户端到应用程序服务器端的连接，实现了安全措施。**在反向代理之前设置防火墙，仅留一个入口供代理服务器访问。**

![1589908851340](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1589908851340.png)

> 分布式、微服务项目，会拆分成多个服务器提供服务，那么用户就可以直接进行访问，这样会有很大的安全隐患。如果每个服务上都设置和验证安全措施，这样安全成本、开发成本、后期维护成本都大大增加
>
> 此时，我们就可以在每个上开启防火墙，拒绝一切请求访问，只提供一个nginx反向代理服务器可以访问。这样我们就只需要维护nginx服务器上的安全措施就行了。这就是内网

#### 如何使用SSL对流量进行加密

翻译成大家能熟悉的说法就是将我们常用的http请求转变成https请求，那么这两个之间的区别简单的来说两个都是HTTP协议，只不过https是身披SSL外壳的http。

HTTPS是一种通过计算机网络进行安全通信的传输协议。它经由HTTP进行通信，利用SSL/TLS建立全通信，加密数据包，确保数据的安全性。

- SSL(Secure Sockets Layer)安全套接层

- TLS(Transport Layer Security)传输层安全

上述这两个是为网络通信提供安全及数据完整性的一种安全协议，TLS和SSL在传输层和应用层对网络连接进行加密。

总结来说为什么要使用https：http协议是明文传输数据，存在安全问题，而https是加密传输，相当于http+ssl，并且可以防止流量劫持。

> 流量劫持：正常情况下用户访问jd，发请求到jd，jd得到请求进行响应；劫持：来了个中间人，将用户的请求拦截下来，发送到它指定的web服务器。

Nginx 默认不支持 https 开头的协议，如果Nginx要想使用SSL，需要满足一个条件即需要添加一个模块`--with-http_ssl_module`，而该模块在编译的过程中又需要OpenSSL的支持，这个我们之前已经准备好了。



##### nginx添加SSL的支持

> openresty 自带的nginx已经安装了

完成 `--with-http_ssl_module`模块的增量添加

1\. 将原有 `/usr/local/nginx/sbin/nginx` 进行备份（如果出现什么问题可以进行恢复）

```sh
cd /usr/local/nginx/sbin
mv nginx nginx.backup
```

2\. 查看 `configure arguments` 的配置信息，拷贝出来

```sh
nginx -V

# 拷贝 configure arguments 后面的数据
```

3\. 进入 Nginx 的安装目录，执行 make clean 清空之前编译的内容

```nginx
cd /root/nginx/core/nginx-1.20.2

make clean
```

4\. 使用 configure 来配置参数，添加 `ngx_http_ssl_module` 模块，记得加上第（2）步拷贝的配置信息

```sh
./configure --with-http_ssl_module # 记得添加 configure arguments 后的数据
```

5\. 通过 make 模板进行编译

```sh
make
```

6\. 将 objs 下面的 nginx 可执行文件移动到 `/usr/local/nginx/sbin` 下

```sh
mv /opt/nginx/core/nginx-1.20.2/objs/nginx /usr/local/nginx/sbin
```

7\. 在源码目录（安装包目录）下执行 `make upgrade` 进行升级，这个可以实现不停机添加新模块的功能

```sh
cd /opt/nginx/core/nginx-1.20.2
make upgrade
```





##### Nginx的SSL相关指令

因为刚才我们介绍过该模块的指令都是通过`ngx_http_ssl_module`模块来解析的。

这里只介绍常用的几个指令，了解更多指令请前往 [ngx_http_ssl_module 模块文档 (opens new window)](http://nginx.org/en/docs/http/ngx_http_ssl_module.html)。

`ssl`：该指令用来在指定的服务器开启HTTPS，默认关闭。可以使用 listen 443 ssl，后面这种方式更通用些。(开启https的支持)

| 语法   | ssl on \| off; |
| ------ | -------------- |
| 默认值 | ssl off;       |
| 位置   | http、server   |

```nginx
server{ #使用多 效果与 ssl on 一样；https默认监听443端口，http默认监听80端口
	listen 443 ssl;
}
```

ssl 默认监听的是 443 端口，所以使用代码里的指令和 `ssl on` 效果一致，因为下面的指令能突出 SSL 的监听端口，所以建议使用它。



`ssl_certificate`为当前这个虚拟主机指定一个带有PEM格式证书的证书。

| 语法   | ssl_certificate file; |
| ------ | --------------------- |
| 默认值 | —                     |
| 位置   | http、server          |



`ssl_certificate_key`该指令用来指定PEM secret key文件的路径

| 语法   | ssl_ceritificate_key file; |
| ------ | -------------------------- |
| 默认值 | —                          |
| 位置   | http、server               |



`ssl_session_cache`该指令用来配置用于SSL会话的缓存

| 语法   | ssl_sesion_cache off\|none\|[builtin[:size]] [shared:name:size] |
| ------ | ------------------------------------------------------------ |
| 默认值 | ssl_session_cache none;                                      |
| 位置   | http、server                                                 |

选项介绍：

- `off`：严格禁止使用会话缓存：Nginx 明确告诉客户端不得重复使用会话

- `none`：禁止使用会话缓存，Nginx 告诉客户端会话可以被重复使用，但实际上并不在缓存中存储会话参数（任性，言语同意用，行为取消用）

- `builtin`：内置 OpenSSL 缓存，仅在一个工作进程中使用。缓存大小在会话中指定。如果未给出大小，则等于 20480 个会话。使用内置缓存可能会导致内存碎片

- `shared`：所有工作进程之间共享缓存，缓存的相关信息用 name 和 size 来指定，同 name 的缓存可用于多个虚拟服务器

  name 是允许缓存的数据名，size 是允许缓存的数据大小，以字节为单位

```nginx
ssl_session_cache builtin:1000 shared:SSL:10m;  
# 10m 的 m 是兆。
```



`ssl_session_timeout`：开启SSL会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间，默认值超时时间是 5 分钟，即5分钟内有效

| 语法   | ssl_session_timeout time; |
| ------ | ------------------------- |
| 默认值 | ssl_session_timeout 5m;   |
| 位置   | http、server              |



`ssl_ciphers`指出允许的密码，密码指定为OpenSSL支持的格式

| 语法   | ssl_ciphers ciphers;          |
| ------ | ----------------------------- |
| 默认值 | ssl_ciphers HIGH:!aNULL:!MD5; |
| 位置   | http、server                  |

可以直接在 Linux 系统上使用 `openssl ciphers` 查看 OpenSSl 支持的格式



`ssl_prefer_server_ciphers`：该指令指定是否服务器密码优先客户端密码，默认关闭，建议开启。

| 语法   | ssl_perfer_server_ciphers on\|off; |
| ------ | ---------------------------------- |
| 默认值 | ssl_perfer_server_ciphers off;     |
| 位置   | http、server                       |



##### SSL证书生成

**方式一：使用阿里云/腾讯云等第三方服务进行购买免费版** (有效期只有1年)

需要购买域名进行证书的绑定，否则证书无法使用。

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image5p2qyl61ozc0.webp)



![](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image5l7iqyudol00.webp)



![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image6ci6w9wu24g0.webp)



![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image4k9v2b9n6tm0.webp)

接着在右边弹窗进行域名绑定，填完写域名和个人信息，进入到验证信息

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image11wx9z7jit3k.webp)

点击验证，不成功则去自己的域名解析列表查看，如下，点击添加记录，进行配置，或者已经看到记录类型是 TXT，记录值和上图一样的，则说明成功。

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image6qcpqete8ic0.webp)

提交审核后，点击下载

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image28m5753glfy8.webp)

下载 Nginx 服务器的证书

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image6kmq7nhonys0.webp)

下载压缩包进行加压后，得到 .pem 证书和 .key 证书，把两个证书上传到 Linux，进行配置，往下看。



**方式二：使用 OpenSSL 生成证书**

> 这个方式适用于学习阶段(目前使用这个)，实际开发阶段使用方式一

1\.先要确认当前系统是否有安装openssl

```sh
openssl version
```

安装下面的命令进行生成（一步一步来）

```sh
mkdir /root/cert
cd /root/cert
openssl genrsa -des3 -out server.key 1024
openssl req -new -key server.key -out server.csr
cp server.key server.key.org
openssl rsa -in server.key.org -out server.key
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
```

**拆解成一步一步的：**

2\. 创建 `/root/cerr` 目录并进入

```sh
mkdir /root/cert

cd /root/cert
```

3\. 指定加密算法和加密方式，生成 `server.key`

```sh
# genrsa 是加密算法，des3 是加密方式，-out 代表输入长度为 2048 的 server.key
openssl genrsa -des3 -out server.key 2048

# 然后它会让你注册 server.key 的密码
# 输入密码 ......
```

4\. 根据你注册的 server.key 密码，生成 server.csr 文件，生成后它会让你注册你的基本信息，因为是个人的，所以信息随便填写（如果是方式一就需要仔细填写了）

```sh
openssl req -new -key server.key -out server.csr

# 这里注册你的基本信息，信息随便填写
```

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image2b4bgtawqb4.webp)

5\. 备份 server.key

```sh
cp server.key server.key.org
```

6\. 重新生成 server.key 文件，并输入刚才注册的密码

```sh
openssl rsa -in server.key.org -out server.key

# 会让你重新输入注册密码
```

7\. 生成 server.crt 文件

```sh
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
```

8\. 最后使用 `ll` 查看目录下是否生成相应的文件：

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/image3yl8ne2bkre0.webp)



**开启SSL实例(通用SSL实例模板)**

Nginx 的配置文件添加如下内容：

```nginx
server { #监听域名进行展示，但是默认不支持https
    listen       80;
    # ......
}

server { # 开启nginx对https的支持
    listen       443 ssl;		# 开启 SSL 功能
    server_name  localhost;     # 如果是购买的域名，这里加上该域名

    ssl_certificate      /root/cert/server.cert; # 生成的 cert 或者 pem 证书路径，根据需求修改
    ssl_certificate_key  /root/cert/server.key; # 生成的 key 证书路径，根据需求修改
    
    ssl_session_cache    shared:SSL:1m; #设置ssl会话缓存，shared表示所有工作进程共享缓存，SSL缓存名称，1m缓存大小
    ssl_session_timeout 5m; # 超时时间，5分钟
    
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; # 表示使用的加密套件的类型
    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;  # 表示使用的TLS协议的类型
    ssl_prefer_server_ciphers on; # 优先使用服务器密码

    location / {
        root   html;
        index  index.html index.htm;
    }
}
```

其实这个模板就是 Nginx 解压目录的 conf 目录下的 nginx.conf 内容。

> 建议：配置 SSL 证书时候，不要修改原来的 server 模块（`listen 80` 模块），应该新建一个 server 模块。
>
> 小技巧：vim一次性删除多行前缀字符(比如将注释全部删除)：进入命令模式 esc->ctrl+v->选中需要删除的所有注释(比如#)，再按d
>
> 测试：现在使用https进行访问时页面会展示`您的连接不是私密连接`，这是因为我们的ssl没有经过认证，证书没有经过验证，浏览器也认为是不安全的

**解决默认 http 问题。**

配置完 SSL 证书还远远不安全。如果直接输入 `www.frx.com`，会默认加上『 http:// 』 而不是『 https:// 』，如何修改为『 https:// 』呢，我们利用 Rewrite 功能

```nginx
server {
    listen 80;
    server_name www.frx.com;   # 如果是 www.frx.com 发送请求
    
    location / {
        # ......
        rewrite ^(.*)$ https://www.frx.com$1;  # 则改为 https 方式
        # ......
	}
    # ......
}
```





### 反向代理系统调优

反向代理值Buffer和Cache。Buffer翻译过来是"缓冲"，Cache翻译过来是"缓存"。

![1581879638569](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day03/1581879638569.png)

> 每次都是客户端请求代理服务器，然后代理服务器将请求转发给服务器
>
> 每次都这么走效率较低，我们可以将每次请求或服务响应的数据进行缓存，下次如果客户端继续请求代理服务时，就可以不需要请求服务器直接返回了

客户端通过代理服务器向被代理服务器获取数据后，代理服务器在获取的数据存储在缓存「瓶子」里，客户端再次获取相同资源时，直接从缓存「瓶子」里获取数据，不需要向被代理服务器获取数据，减轻压力。

相同点:

- 两种方式都是用来提供 IO 吞吐效率，都是用来提升 Nginx 代理的性能。

不同点:

- 缓冲主要用来解决不同设备之间数据传递速度不一致导致的性能低的问题，缓冲中的数据一旦此次操作完成后，就可以删除
  - 比如服务A的处理速度快，服务B的处理速度慢，此时如果A、B进行交互，那么两者加起来处理数据的速度是以B为准的。我们可以在A与B之间增加一个缓冲区，这样服务A只与缓冲区交互，服务B也是从缓冲区取数据。缓冲区是中和两者之间的性能
- 缓存主要是备份，将被代理服务器的数据缓存一份到代理服务器，这样的话，客户端再次获取相同数据的时候，就只需要从代理服务器上获取，效率较高，缓存中的数据可以重复使用，只有满足特定条件才会删除





#### Proxy Buffer相关指令

`proxy_buffering` 该指令用来开启或者关闭代理服务器的缓冲区，默认开启。

| 语法   | proxy_buffering on\|off; |
| ------ | ------------------------ |
| 默认值 | proxy_buffering on;      |
| 位置   | http、server、location   |



`proxy_buffers`该指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小。

| 语法   | proxy_buffers number size;                |
| ------ | ----------------------------------------- |
| 默认值 | proxy_buffers 8 4k \| 8K;(与系统平台有关) |
| 位置   | http、server、location                    |

- number：缓冲区的个数

- size：每个缓冲区的大小，缓冲区的总大小就是number*size



`proxy_buffer_size`该指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与proxy_buffers中的size一致即可，当然也可以更小。（默认就行）

| 语法   | proxy_buffer_size size;                     |
| ------ | ------------------------------------------- |
| 默认值 | proxy_buffer_size 4k \| 8k;(与系统平台有关) |
| 位置   | http、server、location                      |



`proxy_busy_buffers_size`：该指令用来限制同时处于BUSY状态的缓冲总大小。

| 语法   | proxy_busy_buffers_size size;    |
| ------ | -------------------------------- |
| 默认值 | proxy_busy_buffers_size 8k\|16K; |
| 位置   | http、server、location           |



`proxy_temp_path`当缓冲区存满后，仍未被Nginx服务器完全接受，响应数据就会被临时存放在磁盘文件上的该指令设置文件路径下

| 语法   | proxy_temp_path  path;      |
| ------ | --------------------------- |
| 默认值 | proxy_temp_path proxy_temp; |
| 位置   | http、server、location      |

注意path最多设置三层。  



`proxy_temp_file_write_size`：该指令用来设置磁盘上缓冲文件的大小。

| 语法   | proxy_temp_file_write_size size;    |
| ------ | ----------------------------------- |
| 默认值 | proxy_temp_file_write_size 8K\|16K; |
| 位置   | http、server、location              |



**通用网站的配置(讲师)**

```nginx
proxy_buffering on;
proxy_buffer_size 4 32k;
proxy_busy_buffers_size 64k;
proxy_temp_file_write_size 64k;
```



**[通用网站调优模板(网站)](https://frxcat.fun/middleware)**

```nginx
proxy_buffering on;
proxy_buffers 4 64k;
proxy_buffer_size 64k;
proxy_busy_buffers_size 128k;
proxy_temp_file_write_size 128k;
```

根据项目的具体内容进行相应的调节。





### [#](https://frxcat.fun/middleware/Nginx/Nginx_Reverse_proxy/#反向代理问题)反向代理问题

反向代理有一个严重的问题，那就是反向代理的网站需要的 css、js、png 等静态文件默认是从 Nginx 里获取，显然一个你的服务器的代理了如淘宝、京东等网站，那么淘宝、京东等网站的静态文件是从你的服务器里获取，但是服务器根本没有，那么我们如何让代理的网站以及网站需要的 css、js、png 等静态文件一同获取呢，添加如下配置：

```nginx
server {
    listen  80;
    server_name localhost;
    
    location ~ .* {							# 如果不是代理网站的根路径，请自行修改
        proxy_pass http://127.0.0.1:8081;   # 代理的网站地址
        # 将网站的静态文件也代理过来
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	}
}
```