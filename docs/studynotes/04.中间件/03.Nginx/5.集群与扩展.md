---
title: 集群与扩展
date: 2023-01-29 15:50:39
permalink: /pages/c5f5c6/
categories:
  - studynotes
  - 中间件
  - Nginx
tags:
  - Nginx
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---
# Nginx实现服务器端集群搭建

## Nginx与Tomcat部署

前面课程已经将Nginx的大部分内容进行了讲解，我们都知道了Nginx在高并发场景和处理静态资源是非常高性能的，但是在实际项目中除了静态资源还有就是后台业务代码模块，一般后台业务都会被部署在Tomcat，weblogic或者是websphere等web服务器上。那么如何使用Nginx接收用户的请求并把请求转发到后台web服务器？

![1604498725652](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604498725652.webp)

步骤分析:

- 在服务器 A 上准备 Tomcat 环境，并在 Tomcat 上部署一个 Web 项目。这步骤在 [环境准备(Tomcat)](https://frxcat.fun/middleware/Nginx/Nginx_Deployment_and_cluster/#环境准备-tomcat)
- 在服务器 B 上准备 Nginx 环境，使用 Nginx 接收请求，并把请求分发到 Tomcat 上。这步骤在 [环境准备(Nginx)](https://frxcat.fun/middleware/Nginx/Nginx_Deployment_and_cluster/#环境准备-nginx)



### 需求

浏览器访问:

```http
http://192.168.200.146:8080/demo/index.html
```

![1604421296014](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604421296014.webp)

获取动态资源的链接地址:

```http
http://192.168.200.146:8080/demo/getAddress
```



### 环境准备(Tomcat)

本次课程将采用Tomcat作为后台web服务器

（1）在服务器 A(Centos)上准备一个Tomcat（Tomcat 官网地址：[https://tomcat.apache.org/(opens new window)](https://tomcat.apache.org/)）

```sh
# 1.Tomcat官网地址:https://tomcat.apache.org/
# 2.下载tomcat,本次课程使用的是apache-tomcat-8.5.59.tar.gz
# 3.将tomcat进行解压缩
mkdir web_tomcat
tar -zxf apache-tomcat-8.5.59.tar.gz -C /web_tomcat
```

（2）准备一个web项目，将其打包为war

```sh
# 1.将资料中的demo.war上传到tomcat8目录下的webapps包下
# 2.将tomcat进行启动，进入tomcat8的bin目录下
./startup.sh
```

（3）启动tomcat进行访问测试。

```http
静态资源: http://192.168.200.146:8080/demo/index.html
动态资源: http://192.168.200.146:8080/demo/getAddress
```



浏览器访问：

- 静态资源：`http://192.168.200.146:8080/demo/index.html`

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604421296014.webp)

- 动态资源：`http://192.168.200.146:8080/demo/getAddress`

动态资源可以是端口号，此时的端口是 8080

![image](https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220806/image.31nc8e1cdee0.webp)

自此，服务器 A 的 Tomcat 部署已经实现。**demo.war 的内容有什么呢？**

其实你可以自己制作一个 war 包，这里说明一下，demo.war 里有两个图片，和一个 index.html。index.html 文件引用了两个图片：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/jquery.min.js"></script>
    <script>
        $(function(){
           $.get('http://192.168.200.133/demo/getAddress',function(data){
               $("#msg").html(data);
           });
        });
    </script>
</head>
<body>
    <img src="images/logo.webp"/>
    <h1>Nginx如何将请求转发到后端服务器</h1>
    <h3 id="msg"></h3>
    <img src="images/mv.webp"/>
</body>
</html>
```

可以看出，当访问 index.html 时，它会主动去请求 `/getAddress`，这个请求返回端口号，即把 8080 当作动态资源，显示到页面上，如果是 9090 端口访问，则返回 9090 显示页面上。你也可以直接访问 `/getAddress`，直接获取端口号。





### 环境准备(Nginx)

我们已经在 Tomcat 实现了两个效果，那么现在需要把 Tomcat 的地址放到 Nginx 里，由 Nginx 帮我们代理这个 Tomcat 地址，这样我们访问 Nginx，实际上就是访问 Tomcat。

（1）使用Nginx的反向代理，将请求转给Tomcat进行处理。

```nginx
upstream webservice {
	server 192.168.200.146:8080;
}
server{
    listen		80;
    server_name localhost;
    location /demo {
    	proxy_pass http://webservice;
    }
}
```

（2）启动访问服务器 B，测试是否代理到服务器 A 的 Tomcat，效果如图：

![1604421312486](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604421312486.webp)

学习到这，可能大家会有一个困惑，明明直接通过tomcat就能访问，为什么还需要多加一个nginx，这样不是反而是系统的复杂度变高了么?
那接下来我们从两个方便给大家分析下这个问题，

- 第一个使用Nginx实现动静分离

- 第二个使用Nginx搭建Tomcat的集群





## Nginx实现动静分离

> 前端就是直接部署在nginx上的，vue打包成dist，将dist包直接放在远程服务器nginx上即可

**什么是动静分离?**

- 动:后台应用程序的业务处理

- 静:网站的静态资源(html,javaScript,css,images等文件)

- 分离:将两者进行分开部署访问，提供用户进行访问。

**举例说明就是以后所有和静态资源相关的内容都交给Nginx来部署访问，非静态内容则交个类似于Tomcat的服务器来部署访问。**



**为什么要动静分离?**

前面我们介绍过Nginx在处理静态资源的时候，效率是非常高的，而且Nginx的并发访问量也是名列前茅，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。

动静分离以后，降低了动态资源和静态资源的耦合度。如动态资源宕机了也不影响静态资源的展示。



**如何实现动静分离?**

实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。本次课程只要使用Nginx+Tomcat来实现动静分离。



### 需求分析

如下图，因为 Nginx 处理静态资源性能高，所以我们把静态资源放在 Nginx 服务器上，然后把动态资源放到 Tomcat 服务器上。当访问 Nginx 的静态资源时，Nginx 会去访问 Tocmat 获取动态资源。实现动静分离。

![1604422564855](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604422564855.webp)



### 动静分离实现步骤

1.将demo.war项目中的静态资源（两个图片）都删除掉，重新打包生成一个war包，在资料中有提供。（这时候 War 包只留下动态资源，而静态资源要放到 Nginx 上。）

> 资料中的demo.war是有静态资源的；demo_simple.war没有静态资源



2.将war包部署到tomcat中，把之前部署的内容删除掉

- 进入到tomcat的webapps目录下，将之前的内容删除掉
- 将新的war包复制到webapps下
- 将tomcat启动



3.在Nginx所在服务器B创建如下目录，并将对应的静态资源放入指定的位置

![1604493947499](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604493947499.webp)

```sh
mkdir /usr/local/nginx/html/web/images
mkdir /usr/local/nginx/html/web/js

cp logo.webp /usr/local/nginx/html/web/images
cp mv.webp /usr/local/nginx/html/web/images
cp jquery.min.js /usr/local/nginx/html/web/js

vim /usr/local/nginx/html/web/index.html
```

其中index.html页面的内容如下:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/jquery.min.js"></script>
    <script>
        $(function(){
           $.get('http://192.168.200.133/demo/getAddress',function(data){
               $("#msg").html(data);
           });
        });
    </script>
</head>
<body>
    <img src="images/logo.webp"/>
    <h1>Nginx如何将请求转发到后端服务器</h1>
    <h3 id="msg"></h3>
    <img src="images/mv.webp"/>
</body>
</html>

```

第 9 行代码，它访问的这个地址是服务器 B 的 Nginx，通过这个地址让 Nginx 去获取服务器 A 的 Tomcat 动态资源。



4.配置Nginx的静态资源与动态资源的访问

```nginx
upstream webservice{
   server 192.168.200.146:8080; # 服务器 A 的 Tocmat
}
server {
        listen       80;
        server_name  localhost;

        # 动态资源从 Tomcat 获取
        location /demo { # index.html 第 9 行代码触发该 location
                proxy_pass http://webservice;
        }
        # 静态资源从自己身上获取
        location ~/.*\.(png|jpg|gif|js){
                root html/web;
                gzip on;
        }

        location / {
            root   html/web;
            index  index.html index.htm;
        }
}
```



5.启动测试，访问http://192.168.200.133/index.html

![1604494128097](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604494128097.webp)

假如某个时间点，由于某个原因导致Tomcat后的服务器宕机了，我们再次访问Nginx,会得到如下效果

![1604494156197](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604494156197.webp)

用户还是能看到页面，只是缺失了访问次数的统计，这就是前后端耦合度降低的效果，并且整个请求只和后的服务器交互了一次，js和images都直接从Nginx返回，提供了效率，降低了后的服务器的压力。





## Nginx实现Tomcat集群搭建

在使用Nginx和Tomcat部署项目的时候，我们使用的是一台Nginx服务器和一台Tomcat服务器，效果图如下:

![1604494256017](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604494256017.webp)

那么问题来了，如果Tomcat的真的宕机了，整个系统就会不完整，所以如何解决上述问题？一台服务器容易宕机，那就多搭建几台Tomcat服务器，这样的话就提升了后的服务器的可用性。这也就是我们常说的集群，搭建Tomcat的集群需要用到了Nginx的反向代理和负载均衡的知识，具体如何来实现?我们先来分析下原理

![1604494269848](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604494269848.webp)

> 用户请求到 Nginx，Nginx 使用负载均衡对三个 Tomcat 服务器进行访问，如果一个 Tomcat 服务器宕机了，那么还有两个 Tomcat 服务器可以使用。





### 环境准备：

(1)准备3台tomcat,使用端口进行区分[实际环境应该是三台服务器]，修改 Tomcat 的 server.xml，将端口修改分别修改为 8080、8180、8280

```sh
cp -r apache-tomcat-9.0.54 tomcat01
cp -r apache-tomcat-9.0.54 tomcat02
cp -r apache-tomcat-9.0.54 tomcat03
```

修改三个 Tocmat 配置文件的端口

```sh
vim tomcat01/conf/server.xml
vim tomcat02/conf/server.xml
vim tomcat03/conf/server.xml
```

修改的内容位置如下：

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image76l3jwkc3b40.webp)



(2)启动tomcat并访问测试，

```http
http://192.168.200.146:8080/demo/getAddress
```

![1604494822961](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604494822961.webp)

```http
http://192.168.200.146:8180/demo/getAddress
```

![1604494843886](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604494843886.webp)

```http
http://192.168.200.146:8280/demo/getAddress
```

![1604494860954](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604494860954.webp)



(3)在Nginx对应的配置文件中添加如下内容:

```nginx
upstream webservice{
    server 192.168.200.146:8080;     # tomcat01
    server 192.168.200.146:8180; 	 # tomcat02
    server 192.168.200.146:8280;	 # tomcat03
}
server{
    listen		80;
    server_name localhost;
    location /demo {
        proxy_pass http://webservice;
    }
}
```

好了，完成了上述环境的部署，我们已经解决了Tomcat的高可用性，一台服务器宕机，还有其他两条对外提供服务，同时也可以实现后台服务器的不间断更新。但是新问题出现了，上述环境中，如果是Nginx宕机了呢，那么整套系统都将服务对外提供服务了，这个如何解决？



## Nginx高可用解决方案

针对于上面提到的问题，我们来分析下要想解决上述问题，需要面临哪些问题?

![1604495169905](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604495169905.webp)

需要两台以上的Nginx服务器对外提供服务，这样的话就可以解决其中一台宕机了，另外一台还能对外提供服务，但是**如果是两台Nginx服务器的话，会有两个IP地址，用户该访问哪台服务器，用户怎么知道哪台是好的，哪台是宕机了的?**



### Keepalived

使用Keepalived来解决，Keepalived 软件由 C 编写的，最初是专为 LVS 负载均衡软件设计的，Keepalived 软件主要是通过 VRRP 协议实现高可用功能。

### VRRP介绍

VRRP（Virtual Route Redundancy Protocol）协议，翻译过来为**虚拟路由冗余协议**。VRRP协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器IP,而在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话就是MASTER,MASTER实现针对虚拟路由器IP的各种网络功能。其他设备不拥有该虚拟IP，状态为BACKUP,处了接收MASTER的VRRP状态通告信息以外，不执行对外的网络功能。当主机失效时，BACKUP将接管原先MASTER的网络功能。

看图分析：VRRP 把两个 Nginx 分成两个路由（VRRP 路由 1 和 VRRP 路由 2），并生成一个 Virtual 路由，用户访问的是 Virtual 路由，该路由会去访问两个 Nginx 生成的 VRRP 路由。那么到底访问谁呢？VRRP 会给两个路由分配角色，一个是 Master（老大），另一个是 Backup（备份），所以访问的是 Master 角色的路由，当 Master 角色路由宕机了，才会找到 Backup 备份路由。

![1604495824757](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604495824757.webp)

> VRRP 在两台真实存在的物理设备的基础上虚拟出来一个路由，这个虚拟出来的路由对外有一个自己的IP。这样的话用户请求访问这个虚拟IP，然后由VRRP发放给物理设备，这两台设备会进行竞争，优先级越高可以成为master节点。master会真实处理用户请求(也就是用户发到虚拟IP的请求交由master来处理)，然后定时对外发布自身的健康状况，由Backup接收master发出的状态。如果某个时间段，Backup没有接收到master发出的状态，它会认为master已宕机，自身升级为master。（如果有多台Backup还是会竞争看优先级）

从上面的介绍信息获取到的内容就是VRRP是一种协议，那这个协议是用来干什么的？

1.选择协议

```
VRRP可以把一个虚拟路由器的责任动态分配到局域网上的 VRRP 路由器中的一台。其中的虚拟路由即Virtual路由是由VRRP路由群组创建的一个不真实存在的路由，这个虚拟路由也是有对应的IP地址。而且VRRP路由1和VRRP路由2之间会有竞争选择，通过选择会产生一个Master路由和一个Backup路由。
# 就是在多台路由器节点中去选择一个master路由和多个Backup路由
```

2.路由容错协议

```
Master路由和Backup路由之间会有一个心跳检测，Master会定时告知Backup自己的状态，如果在指定的时间内，Backup没有接收到这个通知内容，Backup就会替代Master成为新的Master。Master路由有一个特权就是虚拟路由和后端服务器都是通过Master进行数据传递交互的，而备份节点则会直接丢弃这些请求和数据，不做处理，只是去监听Master的状态
```



用了Keepalived后，解决方案如下:

![1604495442179](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604495442179.webp)

看图分析：VIP 是虚拟路由，是专门给用户发送请求。一旦用户发送请求到 VIP，VIP 就会发送给 Master（主）的 Nginx，如果 Master（主）Nginx 宕机了，才会发送给 Backup（备份） Nginx 路由。



### 环境搭建

环境准备

| VIP             | IP              | 主机名      | 主/从  |
| --------------- | --------------- | ----------- | ------ |
|                 | 192.168.200.133 | keepalived1 | Master |
| 192.168.200.222 |                 |             |        |
|                 | 192.168.200.122 | keepalived2 | Backup |

**确保服务器 A 和服务器 B 的 Nginx 配置保持一致。**

keepalived 的安装步骤如下：

- 步骤1：从官方网站下载 keepalived，官网地址 [https://keepalived.org/](https://keepalived.org/)
- 步骤2：将下载的资源上传到服务器，这里是 `keepalived-2.0.20.tar.gz`
- 步骤3：在 `/opt` 目录下创建 keepalived 目录，方便管理资源

```sh
mkdir /opt/keepalived
```

- 步骤4：将压缩文件进行解压缩，解压缩到指定的目录

```sh
tar -zxf keepalived-2.0.20.tar.gz -C /opt/keepalived
```

- 步骤5：对 keepalived 进行配置，编译和安装

```sh
cd /opt/keepalived/keepalived-2.0.20

./configure --sysconf=/etc --prefix=/usr/local   # 安装到 /usr/local 目录下，可修改

make && make install
```

**两台 Nginx 服务器都要安装 keepalive。**



安装完成后，有两个文件需要我们认识下：

- `/etc/keepalived/keepalived.conf`：keepalived 的系统配置文件，我们主要操作的就是该文件

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image5hd9zg18lp80.webp)

- `/usr/local/sbin` 目录下的 `keepalived`：这是系统配置脚本，用来启动和关闭 keepalived

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image54vzhzf4avw0.webp)





### Keepalived配置文件介绍

打开keepalived.conf配置文件

这里面会分三部：

- 第一部分是 global 全局配置
- 第二部分是 vrrp 相关配置
- 第三部分是 LVS 相关配置。

本次课程主要是使用keepalived实现高可用部署，没有用到LVS，所以我们重点关注的是前两部分

打开 keepalived.conf 文件

```sh
vim /etc/keepalived/keepalived.conf
```

文件内容部分介绍如下：

```nginx
# global全局部分：
global_defs {
   #  # 通知邮件，当 keepalived 切换 Master 和 Backup 时需要发 email 给具体的邮箱地址
   notification_email {
     tom@itcast.cn
     jerry@itcast.cn
   }
   #设置发件人的邮箱信息 从哪个邮箱发出去的
   notification_email_from zhaomin@itcast.cn
   #指定smpt服务地址
   smtp_server 192.168.200.1
   #指定smpt服务连接超时时间
   smtp_connect_timeout 30
   #运行keepalived服务器的一个标识，可以用作发送邮件的主题信息。可以随意 只要不重复就行，一般使用主机名
   router_id LVS_DEVEL
   
   #默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查)
   vrrp_skip_check_adv_addr
   #严格遵守VRRP协议。
   vrrp_strict
   #在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0
   vrrp_garp_interval 0
   #在一个网卡上每组na消息之间的延迟时间，默认为0
   vrrp_gna_interval 0
}
```

这里需要修改的是 5、6、8 行代码。

VRRP 部分可以包含以下四个子模块：

1. vrrp_script
2. vrrp_sync_group
3. garp_group
4. vrrp_instance

我们会用到第一个（[vrrp_script](https://frxcat.fun/middleware/Nginx/Nginx_Deployment_and_cluster/#vrrp-script)）和第四个（[vrrp_instance](https://frxcat.fun/middleware/Nginx/Nginx_Deployment_and_cluster/#vrrp-instance)）。



#### vrrp_instance

`vrrp_instance` 模块内容：

```nginx
#设置keepalived实例的相关信息，VI_1为VRRP实例名称
vrrp_instance VI_1 {
    state MASTER  		#有两个值可选MASTER主 BACKUP备
    interface ens33		#vrrp实例绑定的接口，用于发送VRRP包[当前服务器使用的网卡名称]
    virtual_router_id 51 #指定VRRP实例ID，范围是0-255
    priority 100		#指定优先级，优先级高的将成为MASTER
    advert_int 1		#指定发送VRRP通告的间隔，单位是秒。这里是心跳检查的时间
    authentication {	#vrrp之间通信的认证信息
        auth_type PASS	#指定认证方式。PASS简单密码认证(推荐)
        auth_pass 1111	#指定认证使用的密码，最多8位
    }
    virtual_ipaddress { #虚拟IP地址设置虚拟IP地址，供用户访问使用，可设置多个，一行一个
        192.168.200.222 #就是VIP
    }
}
```

`vrrp_instance` 模块中我们修改的是第 3、5、6、7、13 行代码。

第 3 行代码是说明当前 Nginx 服务器的角色是 Master 还是 Backup。分别在服务器 A 和 B 进行角色配置。

第 5 行代码是 VIP 的 ID，如果使用相同的虚拟路由 VIP，请保持 ID 一致。

第 6 行代码是优先级，请让 Master 服务器的优先级大于 Backup 服务器的优先级。如 100 > 90。

第 7 行代码是 Master 和 Backup 之间通信的间隔时间，如果无法通信，说明 Master 已经宕机，则切换为 Backup。

第 13 行代码是用户访问的虚拟 IP 地址，即 VIP，它会发送给 Nginx 服务器。

> 这种配置文件，都建议备份一份之后再进行修改



#### 服务器配置

Keepalived 的具体配置内容如下：

服务器1

```nginx
global_defs {
   notification_email {
        tom@itcast.cn
        jerry@itcast.cn
   }
   notification_email_from zhaomin@itcast.cn
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id keepalived1 #nginx1所在的服务器
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}

vrrp_instance VI_1 {
    state MASTER #作为主节点
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress { #指定VIP
        192.168.200.222
    }
}
```

服务器2

```nginx
! Configuration File for keepalived

global_defs {
   notification_email {
        tom@itcast.cn
        jerry@itcast.cn
   }
   notification_email_from zhaomin@itcast.cn
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id keepalived2 #nginx2所在的服务器
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}

vrrp_instance VI_1 {
    state BACKUP #作为备用节点
    interface ens33
    virtual_router_id 51
    priority 90
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress { #指定VIP
        192.168.200.222
    }
}
```

> 主备先看state，如果都是BACKUP，就进行优先级priority竞争



### 访问测试

1. 启动keepalived之前，咱们先使用命令 `ip a`,查看`192.168.200.133`和`192.168.200.122`这两台服务器的IP情况。

![1604599529242](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604599529242.webp)

> 可以看到现在没有VIP



2. 分别启动两台服务器的keepalived

```sh
cd /usr/local/sbin
./keepalived
```

再次通过 `ip a`查看ip

![1604599616821](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604599616821.webp)

此时发现服务器 A 多出了 `192.168.200.222`，正是配置的虚拟路由 VIP，而服务器 B 并没有，说明服务器 A 是 Master，优先级高于服务器 B。



3. 当把`192.168.200.133`服务器上的keepalived关闭后，再次查看ip

![1604599709822](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604599709822.webp)

说明当 Master 服务器 A 宕机后，服务器 B 由 Backup 晋升为 Master。

通过上述的测试，我们会发现，虚拟IP(VIP)会在MASTER节点上，当MASTER节点上的keepalived出问题以后，因为BACKUP无法收到MASTER发出的VRRP状态通过信息，就会直接升为MASTER。VIP也会"漂移"到新的MASTER。

> 两个都有的,关闭防火墙和selinux



**上面测试和Nginx有什么关系?**

我们把`192.168.200.133`服务器1的keepalived再次启动下，由于它的优先级高于服务器`192.168.200.122`的，所以它会再次成为MASTER，VIP也会"漂移"过去，然后我们再次通过浏览器访问:

```http
http://192.168.200.222/
```

![1604600079149](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604600079149.webp)

如果把`192.168.200.133`服务器的keepalived关闭掉

```sh
ps -ef | grep keepalived
kill -9 运行中的keepalived的pid
```

再次访问相同的地址，效果如图：

![1604600145318](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604600145318.webp)

虽然效果成功实现了，但是此时是我们手动把服务器上的 keepalived 关闭，才让 VIP 进行切换。

**而什么时候关闭 keepalived 呢？**

应该是在keepalived所在服务器的nginx出现问题后，把keepalived关闭掉，就可以让VIP执行另外一台服务器，**但是现在这所有的操作都是通过手动来完成的**，我们如何能让系统自动判断当前服务器的nginx是否正确启动，如果没有，要能让VIP自动进行"漂移"，这个问题该如何解决?往下看。



### keepalived之vrrp_script

**keepalived只能做到对网络故障和keepalived本身的监控，即当出现网络故障或者keepalived本身出现问题时，进行切换**。但是这些还不够，我们还需要监控keepalived所在服务器上的其他业务，比如Nginx，如果Nginx出现异常了，仅仅keepalived保持正常，是无法完成系统的正常工作的，因此需要根据业务进程的运行状态决定是否需要进行主备切换，这个时候，我们可以通过编写脚本对业务进程进行检测监控。

**实现步骤:**

1. 首先我们要知道 keepalived 的 vrrp_script 的配置模板：(在keepalived配置文件中添加对应的配置像)

```nginx
vrrp_script 脚本名称
{
    script "脚本位置"
    interval 3 # 执行时间间隔
    weight -20 # 动态调整 vrrp_instance 的优先级
}
```



2. 编写脚本，这里的脚本名是 `ck_nginx.sh`，位置在 `/etc/keepalived` 路径下

```sh
#!/bin/bash
# --no-header 是去掉展示的头信息
# `` 将里面包含的命令的执行结果作为属性值 传递给前面的变量
num=`ps -C nginx --no-header | wc -l`  # 查询 Nginx 的进程数

if [ $num -eq 0 ];then       	       # 如果 Nginx 的进程数等于 0，为0说明nginx没启动
 /usr/local/nginx/sbin/nginx			   # 则可执行文件 nginx，启动 Nginx 服务

 sleep 2								   # 阻塞 2 秒 

 if [ `ps -C nginx --no-header | wc -l` -eq 0 ]; then  # 再次查询 Nginx 的进程数
  killall keepalived		# 如果 Nginx 的进程数还是等于 0，说明nginx启动没成功，则杀死 keepalived 进程。让备份keepalived成为master提供服务
 fi
fi
```

- Linux的 ps 命令用于显示当前进程 (process) 的状态。
- -C(command)：指定命令的所有进程
- --no-header：排除标题

命令的效果如图：

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image1ypeqh0nut8g.webp)

代表目前的 num = 3。

这个脚本其实就是判断 Nginx 是否启动还是宕机了，如果没有启动，则重新启动。重新启动后再次查看 Nginx 是否启动成功，如果没有启动，说明 Nginx 宕机了，则杀死 keepalived 进程，这样，另一台服务器的 Nginx 就晋升为 Master。



3. 为脚本文件设置权限，让其可被执行

```sh
chmod 755 ck_nginx.sh
```

4. 将脚本添加到 Master 服务器1 的 keepalived 的配置文件里

```sh
vim /etc/keepalived/keepalived.conf
```

添加如下内容：

```nginx
# 提供sh脚本操作nginx
vrrp_script ck_nginx {
   script "/etc/keepalived/ck_nginx.sh" #执行脚本的位置
   interval 2		#执行脚本的周期，秒为单位
   weight -20		#权重的计算方式，与优先级有关系，会影响最终哪个节点成为master，哪个节点成为backup。这里就是，如果这个脚本文件执行了一次，说明当前keepalived可能要挂了，所以要降低优先级
}
vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 10
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.200.111
    }
    track_script { #启用脚本
      ck_nginx
    }
}
```

5. 如果效果没有出来，可以使用 `tail -f /var/log/messages`查看日志信息，找对应的错误信息。
6. 测试。两个 Nginx 启动后，关闭 Master 的 Nginx，通过 `ip a` 查看 Backup 的 Nginx 的IP，是否晋升为 Master



### 问题思考:

通常如果master服务死掉后backup会变成master，但是当master服务又好了的时候 master此时会抢占VIP，这样就会发生两次切换对业务繁忙的网站来说是不好的。所以我们要在配置文件加入 nopreempt 非抢占，但是这个参数只能用于 Backup 的服务器，故我们在用HA的时候最好master 和backup的state都设置成backup。让它们只能通过 priority 优先级来竞争。

> 也就是：133设定是主，它挂了，然后切换到122；然后133修好之后，又切换到了133。既然122依然可以对外提供服务，这样频繁的切换不太好
>
> 我们将所有keepalived设置非抢占，都是Backup，此时如果想让133是master 只需要提高它的优先级。但是当我们去通过脚本检测master出现了问题之后，我们需要将其停止，让122成为master；但是133再次启动时，优先级还是比122高，所以我们每次执行脚本时都对weight-20。这样133再次启动之后优先级就会比122低，从而不会再去与122进行竞争和切换操作了







# Nginx制作下载站点

首先我们先要清楚什么是下载站点?

我们先来看一个网站`http://nginx.org/download/`。这个我们刚开始学习Nginx的时候给大家看过这样的网站，该网站主要就是用来提供用户来下载相关资源的网站，就叫做下载网站。

![1583825943945](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image17v6jxd79kao.webp)

如何制作一个下载站点:

- nginx使用的是模块`ngx_http_autoindex_module`来实现的（自带），该模块处理以斜杠("/")结尾的请求，并生成目录列表。

- nginx编译的时候会自动加载该模块，但是该模块默认是关闭的，我们需要使用下来指令来完成对应的配置



（1）`autoindex`:启用或禁用目录列表输出

| 语法   | autoindex on\|off;     |
| ------ | ---------------------- |
| 默认值 | autoindex off;         |
| 位置   | http、server、location |



（2）`autoindex_exact_size`:对应HTLM格式，指定是否在目录列表展示文件的详细大小

- 默认为on，显示出文件的确切大小，单位是bytes。
- 改为off后，显示出文件的大概大小，单位是kB或者MB或者GB

| 语法   | autoindex_exact_size  on\|off; |
| ------ | ------------------------------ |
| 默认值 | autoindex_exact_size  on;      |
| 位置   | http、server、location         |



（3）`autoindex_format`：设置目录列表的格式

| 语法   | autoindex_format html\|xml\|json\|jsonp; |
| ------ | ---------------------------------------- |
| 默认值 | autoindex_format html;                   |
| 位置   | http、server、location                   |

只有当 `autoindex_format` 指令设置为 html 时候，上方的 `autoindex_exact_size` 指令才会起作用。

> 注意:该指令在1.7.9及以后版本中出现



（4）`autoindex_localtime`:对应HTML格式，是否在目录列表上显示时间。

- 默认为off，显示的文件时间为GMT时间。
- 改为on后，显示的文件时间为文件的服务器时间

| 语法   | autoindex_localtime on \| off; |
| ------ | ------------------------------ |
| 默认值 | autoindex_localtime off;       |
| 位置   | http、server、location         |



### 实现案例

自行准备几个文件或者压缩包，我这里准备了 4 个用过的压缩包。

1.创建一个目录，将压缩包放入其中，我这里创建的路径是 `/opt/download`

```sh
mkdir /opt/download
```



2.然后把压缩包都放到该目录下

效果如下:

```sh
[root@master download]# pwd
/opt/download
[root@master download]# ll
总用量 545504
-rw-r--r--. 1 root root 408587111 3月  12 22:02 hadoop-2.10.1.tar.gz
-rw-r--r--. 1 root root 145520298 3月  12 21:29 jdk-8u301-linux-x64.tar.gz
-rw-r--r--  1 root root     25680 4月  27 2017 mysql57-community-release-el7-11.noarch.rpm
-rw-r--r--  1 root root   4456335 5月   9 19:40 mysql-connector-java-5.1.48.tar.gz
```



3.打开 Nginx 的配置文件

```sh
vim /usr/local/nginx/conf/nginx.conf
```



4.添加配置如下内容：

```nginx
# 下载站点的相关配置
location /download {
    # root /usr/local;
    root /opt;                # 下载目录所在的路径，location 后面的 /download 拼接到 /opt 后面
    # 以这些后缀的文件点击后为下载，注释掉则 txt 等文件是在网页打开并查看内容
    if ($request_filename ~* ^.*?\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|conf)$){
			  add_header Content-Disposition 'attachment;';
		  }
    autoindex on;			  # 启用目录列表的输出
    autoindex_exact_size off;  # 在目录列表展示文件的详细大小
    autoindex_format html;	  # 设置目录列表的格式为 html，默认就是html
    autoindex_localtime on;   # 目录列表上显示系统时间
}
```

> 注意：root 指令后面必须是下载路径，因为我的下载路径是 `/opt/download`，所以这里填写 `/opt`，而 location 的 `/download` 会自动拼接到后面，形成完整的下载路径。



5.访问 `192.168.91.200/download`

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image3gmq4emy84w0.webp)

- JSON和XML格式(一般不用这两种格式)

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image6n5evv8oo5k0.webp)



![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/imagekvsekaaiu40.webp)









# Nginx的用户认证模块

对应系统资源的访问，我们往往需要限制谁能访问，谁不能访问。这块就是我们通常所说的认证部分，认证需要做的就是根据用户输入的用户名和密码来判定用户是否为合法用户，如果是则放行访问，如果不是则拒绝访问。

Nginx对应用户认证这块是通过`ngx_http_auth_basic_module`模块来实现的，它允许通过使用"HTTP基本身份验证"协议验证用户名和密码来限制对资源的访问。默认情况下nginx是已经安装了该模块，如果不需要则使用`--without-http_auth_basic_module`。

该模块的指令比较简单，

（1）`auth_basic`:使用“ HTTP基本认证”协议启用用户名和密码的验证。默认关闭。

| 语法   | auth_basic string\|off;           |
| ------ | --------------------------------- |
| 默认值 | auth_basic off;                   |
| 位置   | http,server,location,limit_except |

开启后，服务端会返回401，指定的字符串会返回到客户端，给用户以提示信息，但是不同的浏览器对内容的展示不一致。展示登录框让用户输入用户/密码进行验证访问



（2）`auth_basic_user_file`:指定用户名和密码所在文件，包括所在的路径。

| 语法   | auth_basic_user_file file;        |
| ------ | --------------------------------- |
| 默认值 | —                                 |
| 位置   | http,server,location,limit_except |

指定文件路径，该文件中的用户名和密码的设置，密码需要进行加密。可以采用工具自动生成



### 实现案例

1.在配置文件nginx.conf添加如下内容

```nginx
# 下载站点配置
location /download{
    # root /usr/local;
    root /opt;                # 下载目录所在的路径，location 后面的 /download 拼接到 /opt 后面
    autoindex on;			  # 启用目录列表的输出
    autoindex_exact_size on;  # 在目录列表展示文件的详细大小
    autoindex_format html;	  # 设置目录列表的格式为 html
    autoindex_localtime on;   # 目录列表上显示系统时间

    # 认证模块知识
    auth_basic 'please input your auth';   # 启用户名和密码的验证，并在请求头插入数据
    auth_basic_user_file htpasswd;    # 存用户名和密码的文件路径
}
```



2.我们需要使用`htpasswd`工具生成包含用户名和密码的文件

```sh
yum install -y httpd-tools
```

该工具基本操作指令如下：

```sh
# 注意：这个生成用户密码的目录 就是上面我们在nginx中指定用户密码的存放目录
htpasswd -c /usr/local/nginx/conf/htpasswd username #创建一个新文件记录用户名和密码，密码后面弹出输入
htpasswd -b /usr/local/nginx/conf/htpasswd username password # 在指定文件新增一个用户名和密码
htpasswd -D /usr/local/nginx/conf/htpasswd username #从指定文件删除一个用户信息
htpasswd -v /usr/local/nginx/conf/htpasswd username #验证用户名和密码是否正确
```

根据需求指定生成路径的位置。



3.我们创建一个 frx 的用户名，密码是 123456

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image5uqgyc41uuc0.webp)

可以查看生成的文件内容

```sh
[root@master conf]# cat /usr/local/nginx/conf/htpasswd
frx:$apr1$wDXdSh0O$yR66Agylnta9zupO7cD3k.
```



4.浏览器访问 `192.168.91.200/download`![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image1j6bwl4jr2g0.webp)

上述方式虽然能实现用户名和密码的验证，但是大家也看到了，所有的用户名和密码信息都记录在文件里面，如果用户量过大的话，这种方式就显得有点麻烦了，这时候我们就得通过后台业务代码来进行用户权限的校验了。







# Nginx的扩展模块

Nginx是可扩展的，可用于处理各种使用场景。本节中，我们将探讨使用Lua扩展Nginx的功能。

## Lua

### 概念

Lua是一种轻量、小巧的脚本语言，用标准C语言编写并以源代码形式开发。设计的目的是为了嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。



### 特性

跟其他语言进行比较，Lua有其自身的特点：

（1）轻量级：Lua用标准C语言编写并以源代码形式开发，编译后仅仅一百余千字节，可以很方便的嵌入到其他程序中。

（2）可扩展：Lua提供非常丰富易于使用的扩展接口和机制，由宿主语言(通常是C或C++)提供功能，Lua可以使用它们，就像内置的功能一样。

（3）支持面向过程编程和函数式编程



### 应用场景

Lua在不同的系统中得到大量应用，场景的应用场景如下:

游戏开发、独立应用脚本、web应用脚本、扩展和数据库插件、系统安全上。（写外挂）



### Lua的安装

在linux上安装Lua非常简单，只需要下载源码包并在终端解压、编译即可使用。

Lua的官网地址为:`https://www.lua.org`

![1604649954522](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604649954522.webp)

点击download可以找到对应版本的下载地址，我们本次课程采用的是lua-5.3.5,其对应的资源链接地址为https://www.lua.org/ftp/lua-5.4.1.tar.gz,也可以在liunx使用wget命令直接下载:

```sh
wget https://www.lua.org/ftp/lua-5.4.1.tar.gz
```

我这里下载在 `/opt/lua`

```sh
mkdir /opt/lua
cd /opt/lua
wget https://www.lua.org/ftp/lua-5.4.4.tar.gz
```

解压

```sh
tar -zxvf lua-5.4.4.tar.gz
```

检测是否满足 Lua 需要的环境

```sh
cd /opt/lua/lua-5.4.4
make linux test
```

如果在执行`make linux test`失败，报如下错误(如果没有,则编译安装):

![1604650028960](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604650028960.webp)

说明当前系统缺少`libreadline-dev`依赖包，需要通过命令来进行安装

```sh
yum install -y readline-devel
```

编译安装

```sh
make install
```

验证是否安装成功

```sh
[root@master lua-5.4.4]# lua -v
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
```



### Lua的语法

Lua和C/C++语法非常相似，整体上比较清晰，简洁。条件语句、循环语句、函数调用都与C/C++基本一致。如果对C/C++不太熟悉的同学来说，也没关系，因为天下语言是一家，基本上理解起来都不会太困难。我们一点点来讲。

#### 第一个Lua程序

大家需要知道的是，Lua有两种交互方式，分别是:交互式和脚本式，这两者的区别，下面我们分别来讲解下：

##### 交互式

交互式是指可以在命令行输入程序，然后回车就可以看到运行的效果。

Lua交互式编程模式可以通过命令`lua -i`或`lua`来启用:

```lua
lua -i
-- 或者
lua
```

![1604650075000](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604650075000.webp)

在命令行中key输入如下命令，并按回车,会有输出在控制台：

```lua
print("Hello world")
```

![1604650092413](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604650092413.webp)

CTRL + C 关闭交互式终端。



##### 脚本式

脚本式是将代码保存到一个以lua为扩展名的文件中并执行的方式。

**方式一:**

我们需要一个文件名为 hello.lua,在文件中添加要执行的代码，然后通过命令`lua hello.lua`来执行，会在控制台输出对应的结果。

创建 hello.lua 文件

```sh
mkdir lua_demo
cd lua_demo
vim hello.lua
```

hello.lua 文件内容

```lua
print("Hello World!!")
```

执行 hello.lua 文件：

```sh
lua hello.lua
```

![1604650118205](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604650118205.webp)

**不想每次都是用 lua hello.lua 来执行该文件，可不可以直接执行 hello.lua 文件？**



**方式二:**

将hello.lua做如下修改

```lua
#!/usr/local/bin/lua --使用此目录下的可执行文件 来执行本脚本
print("Hello World!!!")
```

第一行用来指定Lua解释器所在位置为`/usr/local/bin/lua`，加上#号标记解释器会忽略它。一般情况下`#!`就是用来指定用哪个程序来运行本文件。但是hello.lua并不是一个可执行文件，需要通过chmod来设置可执行权限，最简单的方式为:

```sh
chmod 755 hello.lua
```

然后执行该文件 

```sh
./hello.lua
```

![1604650152287](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604650152287.webp)

补充一点，如果想在交互式中运行脚本式的hello.lua中的内容，我们可以使用一个dofile函数，如：

```sh
dofile("lua_demo/hello.lua")
```

```sh
[root@master lua_demo]# lua
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
> dofile("hello.lua")
Hello World!!!
```

> 注意:在Lua语言中，连续语句之间的分隔符并不是必须的，也就是说后面不需要加分号，当然加上也不会报错，



在Lua语言中，表达式之间的换行也起不到任何作用。如以下四个写法，其实都是等效的

```lua
# 写法一：换行，不加分号
a=1
b=a+2

# 写法二：换行，加分号
a=1;
b=a+2;

# 写法三：不换行，加分号
a=1; b=a+2;

# 写法四：不换行，不加分号
a=1 b=a+2
```

不建议使用第四种方式，可读性太差。



#### Lua的注释

关于Lua的注释要分两种，第一种是单行注释，第二种是多行注释。

单行注释的语法为：

```lua
--注释内容
```

多行注释的语法为:

```lua
--[[
	注释内容
	注释内容
--]]
```

如果想取消多行注释，只需要在第一个--之前在加一个-即可，如：

```lua
---[[
	注释内容
	注释内容
--]]
```



#### 标识符

换句话说标识符就是我们的变量名，Lua定义变量名以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。这块**建议大家最好不要使用下划线加大写字母的标识符，如 _VERSION，因为Lua的保留字也是这样定义的，容易发生冲突**。注意Lua是区分大小写字母的。



#### 关键字

下列是Lua的关键字，大家在定义常量、变量或其他用户自定义标识符都要避免使用以下这些关键字：

| and      | break | do    | else   |
| -------- | ----- | ----- | ------ |
| elseif   | end   | false | for    |
| function | if    | in    | local  |
| nil      | not   | or    | repeat |
| return   | then  | true  | until  |
| while    | goto  |       |        |

一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。这个也是上面我们不建议这么定义标识符的原因。



#### 运算符

Lua中支持的运算符有算术运算符、关系运算符、逻辑运算符、其他运算符。

##### 算术运算符

| 符号 | 作用 | 例子            |
| ---- | ---- | --------------- |
| +    | 加法 | 10 + 20 --> 30  |
| -    | 减法 | 20 - 10 --> 10  |
| *    | 乘法 | 10 * 20 --> 200 |
| /    | 除法 | 20 / 10 --> 2   |
| %    | 取余 | 3 % 2 --> 1     |
| ^    | 乘幂 | 10 ^ 2 --> 100  |
| -    | 符号 | -10 --> -10     |



##### [#](#关系运算符)关系运算符

| 符号 | 作用     | 例子                |
| ---- | -------- | ------------------- |
| ==   | 等于     | 10 == 10 --> true   |
| ~=   | 不等于   | 10 ~= 10 --> false  |
| >    | 大于     | 20 > 10 --> true    |
| <    | 小于     | 20 < 10 --> false   |
| \>=  | 大于等于 | 20 \>= 10 --> true  |
| \<=  | 小于等于 | 20 \<= 10 --> false |



##### [#](#关系运算符)逻辑运算符

| 符号 | 作用   | 例子                                        |
| ---- | ------ | ------------------------------------------- |
| and  | 逻辑与 | A and B（等价于 Java 的 a && b）            |
| or   | 逻辑或 | A or B（等价于 Java 的 a \|\| b）           |
| not  | 逻辑非 | not A（取反，如果 A 为 true，则返回 false） |

逻辑运算符可以作为 if 的判断条件，返回的结果如下:

```lua
A = true
B = true

A and B	-->true
A or  B -->true
not A 	-->false

A = true
B = false

A and B	-->false
A or  B -->true
not A 	-->false

A = false
B = true

A and B	-->false
A or  B -->true
not A 	-->true
```



##### [其他运算符](#其他运算符)

| 符号 | 作用                             | 例子                              |
| ---- | -------------------------------- | --------------------------------- |
| ..   | 连接两个字符串                   | "HELLO ".."WORLD" --> HELLO WORLD |
| #    | 一元预算法，返回字符串或表的长度 | #"HELLO" --> 5                    |

例如:

```lua
[root@master lua_demo]# lua
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
> "Hello".."World"
HelloWorld
> #"HelloWorld"
10
```



#### 全局变量&局部变量

在Lua语言中，全局变量无须声明即可使用。**在默认情况下，变量总是认为是全局的，如果未提前赋值，默认为nil**:

```lua
[root@master lua_demo]# lua
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
> print(b)
nil
> b=100
> print(b)
100
> b=nil
> print(b)
nil
```

![1604650220670](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604650220670.webp)

要想声明一个局部变量，需要使用local来声明

```lua
[root@master lua_demo]# lua
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
> local a=100 --局部变量
> print(a)
nil
> local a=100 print(a) --会认为这两个是局部的 同时执行的一条命令
100
```

![1604650235860](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604650235860.webp)

如上所示，终端交互式的 local 声明的变量在同一行使用，换行了则离开了该变量的作用域。如果使用了 function 之类的结构或者在文件里使用 local，则可以换行，具体往下看。



#### Lua数据类型

Lua有8个数据类型

| 数据类型名 | 作用                |
| ---------- | ------------------- |
| nil        | 空，无效值          |
| boolean    | 布尔，true \| false |
| number     | 数值                |
| string     | 字符串              |
| function   | 函数                |
| table      | 表                  |
| thread     | 线程                |
| userdata   | 用户数据            |

可以使用type函数测试给定变量或者的类型：

```lua
print(type(nil))				-->nil
print(type(true))               --> boolean
print(type(1.1*1.1))             --> number
print(type("Hello world"))      --> string
print(type(io.stdin))			-->userdata
print(type(print))              --> function
print(type(type))               -->function
print(type{})					-->table
print(type(type(X)))            --> string
```



##### nil

nil是一种只有一个nil值的类型，它的作用可以用来与其他所有值进行区分，也可以当想要移除一个变量时，只需要将该变量名赋值为nil,垃圾回收就会会释放该变量所占用的内存。与Java中的null很类似



##### boolean

boolean类型具有两个值，true和false。boolean类型一般被用来做条件判断的真与假。**在Lua语言中，只会将false和nil视为假，其他的都视为真，特别是在条件检测中0和空字符串都会认为是真**，这个和我们熟悉的大多数语言不太一样。



##### number

在Lua5.3版本开始，Lua语言为数值格式提供了两种选择:integer(整型)和float(双精度浮点型)[和其他语言不太一样，float不代表单精度类型]。

数值常量的表示方式:

```lua
[root@master lua_demo]# lua
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
> 4			-->4
4
> 0.4		-->0.4
0.4
> 4.75e-3	-->0.00475
0.00475
> 4.75e33		-->4750
4750.0
```

不管是整型还是双精度浮点型，使用type()函数来取其类型，都会返回的是number

```lua
[root@master lua_demo]# lua
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
> type(3)
number
> type(3.3)
number
```

所以它们之间是可以相互转换的，同时，**具有相同算术值的整型值和浮点型值在Lua语言中是相等的**



##### string

Lua语言中的字符串即可以表示单个字符，也可以表示一整本书籍。在Lua语言中，操作100K或者1M个字母组成的字符串的程序很常见。

可以使用单引号或双引号来声明字符串

```lua
[root@master lua_demo]# lua
Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio
> a = "Hello"
> b = "World"
> print(a)
Hello
> print(b)
World
```

如果声明的字符串比较长或者有多行，则可以使用如下方式进行声明

```lua
html = [[
<html>
<head>
<title>Lua-string</title>
</head>
<body>
<a href="http://www.lua.org">Lua</a>
</body>
</html>
]]
```



##### table

​	table是Lua语言中最主要和强大的数据结构。使用table表时，Lua语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结构。 Lua语言中的表本质上是一种辅助数组。这种数组比Java中的数组更加灵活，**可以使用数值做索引，也可以使用字符串或其他任意类型的值作索引(除nil外)。**

创建表的最简单方式:

```lua
-- 注意：前面的 > 代表这是直接在交互模式使用lua
> a = {}
> print(type(a))
table
```



**创建数组方式一**:

我们都知道数组就是相同数据类型的元素按照一定顺序排列的集合，那么使用table如何创建一个数组呢?

```lua
>arr = {"TOM","JERRY","ROSE"}
```

要想获取数组中的值，我们可以通过如下内容来获取:

```lua
print(arr[0])		nil
print(arr[1])		TOM
print(arr[2])		JERRY
print(arr[3])		ROSE
```

从上面的结果可以看出来，**数组的下标默认是从1开始的**。



**创建数组方式二**:

上述创建数组，也可以通过如下方式来创建：

```lua
>arr = {}
>arr[1] = "TOM"
>arr[2] = "JERRY"
>arr[3] = "ROSE"
```



**创建数组方式三**:

表的索引即可以是数字，也可以是字符串等其他的内容，所以我们也可以将索引更改为字符串来创建

```lua
>arr = {}
>arr["X"] = 10
>arr["Y"] = 20
>arr["Z"] = 30
```

当然，如果想要获取这些数组中的值，可以使用下面的方式

```lua
> arr[1] -- 拿到的是nil

--方式一
>print(arr["X"])
>print(arr["Y"])
>print(arr["Z"])

--方式二
>print(arr.X)
>print(arr.Y)
>print(arr.Z)
```



**创建数组方式四**:

当前table的灵活不进于此，还有更灵活的声明方式

```lua
>arr = {"TOM",X=10,"JERRY",Y=20,"ROSE",Z=30}
```

如何获取上面的值?

```lua
arr[1]       -- TOM
arr["X"]	 -- 10
arr.X   	 -- 10
arr[2]		 -- JERRY
arr["Y"]	 -- 20
arr.Y		 --20
arr[3]		 -- ROSE
```



##### function

在 Lua语言中，函数（ Function ）是对语句和表达式进行抽象的主要方式。

定义函数的语法为:

```lua
function functionName(params)

end
```

**函数被调用的时候，传入的参数个数与定义函数时使用的参数个数不一致的时候，Lua 语言会通过抛弃多余参数和将不足的参数设为 nil 的方式来调整参数的个数**。

```lua
-- 函数
function  f(a,b)
	print(a,b)
end

-- 调用函数
f()		--> nil  nil
f(2)	--> 2 nil
f(2,6)	--> 2 6
f(2.6.8)	--> 2 6 (8被丢弃)
```

可变长参数函数

```lua
-- 函数
function add(...)
    a,b,c=...    -- 按顺序令 a,b,c 等于多个参数的前三个
    print(a)
    print(b)
    print(c)
end

-- 调用函数
add(1,2,3)  --> 1 2 3
```

函数返回值可以有多个，这点和Java不太一样

```lua
-- 函数
function f(a,b)
    return a,b
end

-- 调用函数
x,y = f(11,22)	--> x=11,y=22	
```



##### thread

thread翻译过来是线程的意思，在Lua中，thread用来表示执行的独立线路，用来执行协同程序。



##### userdata

userdata是一种用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型。





#### Lua控制结构

Lua 语言提供了一组精简且常用的控制结构，包括用于条件执行的证 以及用于循环的 while、 repeat 和 for。 所有的控制结构语法上都有一个显式的终结符： end 用于终结 if、 for 及 while 结构， until 用于终结 repeat 结构。

##### if 判断

if语句先测试其条件，并根据条件是否满足执行相应的 then 部分或 else 部分。 else 部分是可选的。

```lua
function testif(a)
 if a>0 then
 	print("a是正数")
 end
end

function testif(a)
 if a>0 then
 	print("a是正数")
 else
 	print("a是负数")
 end
end
```

如果要编写嵌套的 if 语句，可以使用 elseif。 它类似于在 else 后面紧跟一个if。根据传入的年龄返回不同的结果，如

```lua
function show(age)
    if age<=18 then
        return "青少年"
    elseif age>18 and age<=45 then
        return "青年"
    elseif age>45 and age<=60 then
        return "中年人"
    elseif age>60 then
        return "老年人"
    end
end
```



##### while循环

顾名思义，当条件为真时 while 循环会重复执行其循环体。 Lua 语言先测试 while 语句 的条件，若条件为假则循环结束；否则， Lua 会执行循环体并不断地重复这个过程。

语法：

```lua
while 条件 do
  循环体
end
```

例子:实现数组的循环

```lua
function testWhile()
    local i = 1
    while i<=10 do
        print(i)
        i=i+1
    end
end
```



##### repeat循环(类似do...while)

顾名思义， repeat-until语句会重复执行其循环体直到条件为真时结束。 由于条件测试在循环体之后执行，所以循环体至少会执行一次。

语法

```lua
repeat
	循环体
until 条件
```

例子

```lua
function testRepeat()
    local i = 10
    repeat
        print(i)
        i = i - 1
    until i < 1
end
```



##### for循环

数值型for循环

语法

```lua
-- 从exp1开始循环，循环到exp2终止，每次循环的步长exp3
for param = exp1,exp2,exp3 do
	循环体
end
```

param的值从exp1变化到exp2之前的每次循环会执行循环体，并在每次循环结束后将步长(step)exp3增加到param上。exp3可选，如果不设置默认为1

```lua
for i = 1,100,10 do
    print(i)
end
```



**泛型for循环**

泛型for循环通过一个迭代器函数来遍历所有值，类似于java中的foreach语句。

语法

```lua
for i,v in ipairs(x) do
	循环体
end
```

i是数组索引值，v是对应索引的数组元素值，ipairs是Lua提供的一个迭代器函数，用来迭代数组，x是要遍历的数组。

例如:

```lua
arr = {"TOME","JERRY","ROWS","LUCY"}

for i,v in ipairs(arr) do
	print(i,v)
end
```

上述实例输出的结果为

```lua
1	TOM
2	JERRY
3	ROWS
4	LUCY
```

但是如果将arr的值进行修改为

```lua
arr = {"TOME","JERRY","ROWS",x="JACK","LUCY"}
```

同样的代码在执行的时候，就只能看到和之前一样的结果，而其中的x为JACK就无法遍历出来，缺失了数据，如果解决呢?

我们可以将迭代器函数由 `ipairs` 变成 `pairs`，如

```lua
for i,v in pairs(arr) do
	print(i,v)
end
```

上述实例就输出的结果为

```lua
1	TOM
2	JERRY
3	ROWS
4	LUCY
x	JACK
```







## ngx_lua模块概念

淘宝开发的`ngx_lua`模块通过将lua解释器集成进Nginx，可以采用lua脚本实现业务逻辑，由于lua的紧凑、快速以及内建协程，所以在保证高并发服务能力的同时极大地降低了业务逻辑实现成本。

## ngx_lua模块环境准备

下载 `ngx-lua-module` 模块有两个方式。

- 方式一安装比较繁琐，需要手动下载其他依赖
- 方式二安装简单快捷，集成了依赖，不需要手动下载依赖，建议方式二

不论方式一还是方式二安装，**首先确保你为它安装好了环境，否则会安装报错**。环境分别为：`GCC`、`PCRE`、`zlib`、`OpenSSL`。[环境安装传送门](https://frxcat.fun/middleware/Nginx/Nginx_install/#nginx环境安装)。



### 方式一:lua-nginx-module

1. 下载第三方模块 `lua-nginx-module`，前，需要先下载 `LuaJIT` 解析器。LuaJIT是采用C语言编写的Lua代表的解释器。

官网地址为:<http://luajit.org/>

在官网上找到对应的下载地址:http://luajit.org/download/LuaJIT-2.0.5.tar.gz

在centos上使用wget来下载: `wget http://luajit.org/download/LuaJIT-2.0.5.tar.gz`

将下载的资源进行解压: `tar -zxf LuaJIT-2.0.5.tar.gz`

进入解压的目录: `cd LuaJIT-2.0.5`

执行编译和安装: `make && make install`

![1604636335626](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604636335626.webp)

2. 下载lua-nginx-module

下载地址:<https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz>

在centos上使用wget来下载: wget https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz

将下载的资源进行解压: `tar -zxf lua-nginx-module-0.10.16rc4.tar.gz`

更改目录名:`mv lua-nginx-module-0.10.16rc4 lua-nginx-module`

导入环境变量，告诉Nginx去哪里找luajit

```sh
export LUAJIT_LIB=/usr/local/lib
export LUAJIT_INC=/usr/local/include/luajit-2.0
```

进入Nginx的目录执行如下命令:

```sh
./configure --prefix=/usr/local/nginx --add-module=../lua-nginx-module
make && make install
```

注意事项:

（1）如果启动Nginx出现如下错误:

![1604636421045](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604636421045.webp)

解决方案:

设置软链接，使用如下命令

```sh
 ln -s /usr/local/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2
```

（2）如果启动Nginx出现以下错误信息

![1604636405241](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604636405241.webp)

分析原因:因为`lua-nginx-module`是来自openrestry,错误中提示的`resty.core`是openrestry的核心模块，对其下的很多函数进行了优化等工作。以前的版本默认不会把该模块编译进去，所以需要使用的话，我们得手动安装，或者禁用就可以。但是最新的`lua-nginx-module`模块已经强制性安装了该模块，所以此处因为缺少resty模块导致的报错信息。

解决方案有两个:一种是下载对应的模块，另一种则是禁用掉restry模块，禁用的方式为:

```nginx
http{
	lua_load_resty_core off;
}
```

3. 测试

在nginx.conf下配置如下内容:

```nginx
location /lua{
    default_type 'text/html';
    content_by_lua 'ngx.say("<h1>HELLO,LUA</h1>")';
}
```

配置成功后，启动nginx,通过浏览器进行访问，如果获取到如下结果，则证明安装成功。

![1604636592232](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604636592232.webp)



### 方式二:OpenRestry

方式二使用 OpenRestry 进行安装。OpenRestry 就是我们上面说到的 Nginx 的 Spring 之一。

#### 概述

​	前面我们提到过，OpenResty是由淘宝工程师开发的，所以其官方网站(<http://openresty.org/>)我们读起来是非常的方便。OpenResty是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。所以本身OpenResty内部就已经集成了Nginx和Lua，所以我们使用起来会更加方便。

#### 安装

下载地址：[http://openresty.org/cn/download.html](http://openresty.org/cn/download.html)。这里下载 1.19.9.1 版本。

- 可以在 Windows 下载 OpenResty：[https://openresty.org/download/openresty-1.19.9.1.tar.gz](https://openresty.org/download/openresty-1.19.9.1.tar.gz)，然后上传到 Linux

  或者直接在 Linux 使用 wget 下载: `wget https://openresty.org/download/openresty-1.19.9.1.tar.gz`

```sh
cd /opt/openresty    # 没有就创建：mkdir /opt/openresty

wget https://openresty.org/download/openresty-1.19.9.1.tar.gz
```

- 解压缩

```sh
tar -zxvf openresty-1.19.9.1.tar.gz
```

- 进入 OpenResty 目录

```sh
cd openresty-1.19.9.1
```

- 执行命令

```sh
./configure
```

- 执行命令进行编译和安装

```sh
make && make install
# 或者
gmake && gmake install
```

默认安装在 `/usr/local/` 下。

- 进入 OpenResty 的目录，找到 nginx

```sh
cd /usr/local/openresty/nginx
```

- 在 conf 目录下的 nginx.conf 添加如下内容：

```sh
vim conf/nginx.conf
```

```nginx
location /lua {
    default_type 'text/html';
    content_by_lua 'ngx.say("<h1>HELLO,OpenRestry</h1>")';
}
```

重启 Nginx 配置文件

```sh
nginx -s reload
```

- 先把 Nginx 停止运行

```sh
systemctl stop Nginx
```

然后在 sbin 目录下启动可执行文件 nginx

```nginx
./sbin/nginx
```

- 通过浏览器访问测试`192.168.91.200`

![1604636706604](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604636706604.webp)

- 通过浏览器访问测试`192.168.91.200/lua`

![1604636719140](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604636719140.webp)

### OpenResty卸载

卸载非常简单粗暴，相信我，这样卸载是对的，没什么问题。

1. 停止 Nginx 服务

```sh
# 查看 Nginx 是否停止，没有则去停止
ps -ef | grep nginx 

# 进入 sbin 目录
cd /usr/local/openresty/nginx/sbin
./nginx -s stop
```

2. 输入以下指令全局查找 OpenResty 相关的文件

```sh
find / -name openresty
```

3. find / -name openresty

```sh
rm -rf  此处跟查找出来的 Openresty 文件
```





## ngx_lua的使用

**使用Lua编写Nginx脚本的基本构建块是指令**。指令用于指定何时运行用户Lua代码以及如何使用结果。下图显示了执行指令的顺序。

![1604717983815](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604717983815.webp)

先来解释下*的作用

```
*：无 ， 即 xxx_by_lua ,指令后面跟的是 lua指令(直接编写lua指令)
*:_file，即 xxx_by_lua_file 指令后面跟的是 lua文件（不推荐使用）
*:_block,即 xxx_by_lua_block 在0.9.17版后替换init_by_lua_file（替换上面那个）
```

如上图所示，OpenResty 的执行阶段分为：

- `init_by_lua*`：该指令在每次Nginx重新加载配置时执行，可以用来完成一些耗时模块的加载，或者初始化一些全局配置。
- `init_worker_by_lua*`：该指令用于启动一些定时任务，如心跳检查、定时拉取服务器配置等。
- `set_by_lua*` : 流程分支处理判断变量初始化。该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给Nginx中指定的变量。
- `rewrite_by_lua*` : 转发、重定向、缓存等功能(例如特定请求代理到外网)。该指令用于执行内部URL重写或者外部重定向，典型的如伪静态化URL重写，本阶段在rewrite处理阶段的最后默认执行。
- `access_by_lua*` : IP 准入、接口权限等情况集中处理(例如配合 iptable 完成简单防火墙)。该指令用于访问控制。例如，如果只允许内网IP访问。
- `content_by_lua*` : 内容生成。**该指令是应用最多的指令，大部分任务是在这个阶段完成的**，其他的过程往往为这个阶段准备数据，正式处理基本都在本阶段。
- `header_filter_by_lua*` : 响应头部过滤处理(例如添加头部信息)。该指令用于设置应答消息的头部信息。
- `body_filter_by_lua*` : 响应体过滤处理(例如完成应答内容统一成大写)。该指令是对响应数据进行过滤，如截断、替换。
- `log_by_lua*` : 会话完成后本地异步完成日志记录(日志可以记录在本地，还可以同步到其他机器)。该指令用于在log请求处理阶段，用Lua代码处理日志，但并不替换原有log处理。

- `balancer_by_lua*`: 该指令主要的作用是用来实现上游服务器的负载均衡器算法
- `ssl_certificate_by_*`: 该指令作用在Nginx和下游服务开始一个SSL握手操作时将允许本配置项的Lua代码。





### 语法API

#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-say)ngx.say

返回结果给客户端。

语法：`ngx.say("")`。

```nginx
location / {
    default_type 'text/plain';
    content_by_lua_block {
        ngx.say("Hello World")
    }
}
```

你会在网页上看到 Hello World。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-print)ngx.print

将输入参数合并发送给 HTTP 客户端 (作为 HTTP 响应体)。如果此时还没有发送响应头信息，本函数将先发送 HTTP 响应头，再输出响应体。

语法：`ok, err = ngx.print(...)`

```lua
local table = {
     "hello, ",
     {"world: ", true, " or ", false,
         {": ", nil}}
 }
ok, err = ngx.print(table)
```

将输出：

```lua
 hello, world: true or false: nil
```

其中 ok 存储着输出的内容，如果输出失败，err 存储失败的原因。

本函数为异步调用，将立即返回，不会等待所有数据被写入系统发送缓冲区。要以同步模式运行，请在调用 `ngx.print` 之后调用 `ngx.flush`。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-flush)ngx.flush

向客户端刷新响应输出。

语法：`ok, err = ngx.flush(wait)`

`ngx.flush` 接受一个布尔型可选参数 `wait` (默认值 `false`)。当通过默认参数（`false`）调用时，本函数发起一个异步调用。当把 `wait` 参数设置为 `true` 时，本函数将以同步模式执行。

- 异步调用下，直接将数据返回，不等待输出数据被写入系统发送缓冲区。
- 同步模式下，本函数不会立即返回，一直到所有输出数据被写入系统输出缓冲区，或到达发送超时 send_timeout 时间。

这个要和上方的 ngx.print 进行配合使用，开启同步模式，可以优化返回客户端多条数据的速度。

```lua
local table = {
     "hello, ",
     {"world: ", true, " or ", false,
         {": ", nil}}
 }
ok, err = ngx.print(table)
ngx.flush(true) 		-- 开启同步模式
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-arg)ngx.arg

获取定义的变量。

语法：`ngx.arg[n]`。

```nginx
 location /foo {
     set $a 32;
     set $b 56;
     sum = ngx.arg[1] + ngx.arg[2]  # 等价于 $a + $b
     echo $sum;  
 }
```

将输出 88，是 32 和 56 的和。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-var)ngx.var

读写 Nginx 变量值。

语法：`ngx.var.xxx`。

```nginx
location /foo {
    set $my_var '';  # 创建 $my_var 变量
    content_by_lua '
        ngx.var.my_var = 123;  # 使用 $my_var 变量
    ';
}
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-log)ngx.log

输出到日志中。格式：`ngx.log(ngx.level,...)`

可指定多个日志常量 ngx.level。

ngx.level有：

```lua
ngx.STDERR    -- 例如 ngx.log(ngx.STDERR)
ngx.EMERG
ngx.ALERT
ngx.CRIT
ngx.ERR
ngx.WARN
ngx.NOTICE
ngx.INFO
ngx.DEBUG
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#http-方法常量)HTTP 方法常量

```nginx
ngx.HTTP_GET
ngx.HTTP_HEAD
ngx.HTTP_PUT
ngx.HTTP_POST
ngx.HTTP_DELETE
ngx.HTTP_OPTIONS   (v0.5.0rc24 版本加入)
ngx.HTTP_MKCOL     (v0.8.2 版本加入)
ngx.HTTP_COPY      (v0.8.2 版本加入)
ngx.HTTP_MOVE      (v0.8.2 版本加入)
ngx.HTTP_PROPFIND  (v0.8.2 版本加入)
ngx.HTTP_PROPPATCH (v0.8.2 版本加入)
ngx.HTTP_LOCK      (v0.8.2 版本加入)
ngx.HTTP_UNLOCK    (v0.8.2 版本加入)
ngx.HTTP_PATCH     (v0.8.2 版本加入)
ngx.HTTP_TRACE     (v0.8.2 版本加入)
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#http-状态常量)HTTP 状态常量

```nginx
value = ngx.HTTP_OK 					(等于 200)
value = ngx.HTTP_CREATED 				(等于 201)
value = ngx.HTTP_SPECIAL_RESPONSE 		(等于 300)
value = ngx.HTTP_MOVED_PERMANENTLY 		(等于 301)
value = ngx.HTTP_MOVED_TEMPORARILY 		(等于 302)
value = ngx.HTTP_SEE_OTHER 				(等于 303)
value = ngx.HTTP_NOT_MODIFIED 			(等于 304)
value = ngx.HTTP_BAD_REQUEST 			(等于 400)
value = ngx.HTTP_UNAUTHORIZED 			(等于 401)
value = ngx.HTTP_FORBIDDEN 				(等于 403)
value = ngx.HTTP_NOT_FOUND 				(等于 404)
value = ngx.HTTP_NOT_ALLOWED 			(等于 405)
value = ngx.HTTP_GONE 					(等于 410)
value = ngx.HTTP_INTERNAL_SERVER_ERROR 	(等于 500)
value = ngx.HTTP_METHOD_NOT_IMPLEMENTED (等于 501)
value = ngx.HTTP_SERVICE_UNAVAILABLE 	(等于 503)
value = ngx.HTTP_GATEWAY_TIMEOUT 		(等于 504) (v0.3.1rc38 版本加入)
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#print)print

将参数值以 `ngx.NOTICE` 日志级别写入 Nginx 的 `error.log` 文件。

语法：`print(...)`。

```lua
print("Hello")
```

等价于

```lua
ngx.log(ngx.NOTICE, "Hello")
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-ctx)ngx.ctx

一个 location 模块里的全局环境变量，存储基于请求的 Lua 环境数据。

语法：`ngx.ctx.xxx`。

```nginx
location /sub {
    content_by_lua '
        ngx.say("sub pre: ", ngx.ctx.blah)
        ngx.ctx.blah = 32
        ngx.say("sub post: ", ngx.ctx.blah)
    ';
}

location /main {
    content_by_lua '
        ngx.ctx.blah = 73
        ngx.say("main pre: ", ngx.ctx.blah)
        local res = ngx.location.capture("/sub")
        ngx.print(res.body)
        ngx.say("main post: ", ngx.ctx.blah)
    ';
}
```

访问 `GET /main` 输出：

```lua
main pre: 73
sub pre: nil
sub post: 32
main post: 73
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-exit)ngx.exit

退出某个阶段，如处理请求阶段、重定向阶段等。

语法：`ngx.exit(status)`。

`status` 参数可以是 `ngx.OK`，`ngx.ERROR` 等等 [HTTP 状态常量](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#http-状态常量)

```lua
ngx.status = ngx.HTTP_GONE
ngx.say("This is our own content")

-- 退出整个请求而不是当前处理阶段
ngx.exit(ngx.HTTP_OK)
```

可以直接使用数字作为参数，例如：

```lua
 ngx.exit(501)
```

> 注意: 数字作为参数仅支持 `NGX_OK` 和 `NGX_ERROR` 的数字。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-sleep)ngx.sleep

无阻塞地休眠特定秒。时间可以精确到 0.001 秒 (毫秒)。

语法：`ngx.sleep(seconds)`。

```lua
ngx.sleep(1000)
```



### 请求API

#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-req-get-uri-args)ngx.req.get_uri_args

返回一个 Lua table，包含当前请求的所有 URL 查询参数。

语法：`args = ngx.req.get_uri_args([max_args])`

```nginx
location = /test {
     content_by_lua '
         local args = ngx.req.get_uri_args()
         for key, val in pairs(args) do
             if type(val) == "table" then
                 ngx.say(key, ": ", table.concat(val, ", "))
             else
                 ngx.say(key, ": ", val)
             end
         end
     ';
 }
```

访问 `GET /test?foo=bar&bar=baz&bar=blah` 将输出：

```lua
 foo: bar
 bar: baz, blah
```

多次出现同一个参数 key 时，将生成一个 Lua table，按顺序保存其所有 value。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-req-set-uri-args)ngx.req.set_uri_args

用 `args` 参数重写当前请求的 URI 请求参数。

语法：`ngx.req.set_uri_args(args)`。

```lua
ngx.req.set_uri_args("a=3&b=hello%20world")

ngx.req.set_uri_args({ a = 3, b = "hello world" })

ngx.req.set_uri_args({ a = 3, b = {5, 6} })
```

在第二种情况下，本方法将根据 URI 转义规则转义参数的 key 和 value。

在第三种情况下，请求参数字符串为 `a=3&b=5&b=6`。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-header-header)ngx.header.HEADER

修改、添加、或清除当前请求待发送的 `HEADER` 响应头信息。

语法：`ngx.header.HEADER = VALUE`。

`HEADER` 响应头信息不是自定义的，是请求头带有的。

```lua
 -- 与 ngx.header["Content-Type"] = 'text/plain' 相同
 ngx.header.content_type = 'text/plain';

 ngx.header["X-My-Header"] = 'blah blah'
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-req-get-method)ngx.req.get_method

获取当前请求的 HTTP 请求方法名称。结果为类似 `"GET"` 和 `"POST"` 的字符串。

语法：`ngx.req.get_method`。

```lua
value = ngx.req.get_method
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-req-set-method)ngx.req.set_method

用 `method_id` 参数的值改写当前请求的 HTTP 请求方法。当前仅支持 [HTTP 请求方法](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#http-方法常量) 中定义的数值常量。

语法：`ngx.req.set_method(method_id)`。

```lua
ngx.req.set_method(method_id)

ngx.req.set_method(ngx.HTTP_GET)
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-req-read-body)ngx.req.read_body

同步读取客户端请求体，不阻塞 Nginx 事件循环。

语法：`ngx.req.read_body()`。

```lua
ngx.req.read_body()
local args = ngx.req.get_post_args()
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-req-get-post-args)ngx.req.get_post_args

返回一个 Lua table，包含当前请求的所有 POST 查询参数。

语法：`args, err = ngx.req.get_post_args(max_args?)`

> 注意：使用 `ngx.req.get_post_args` 获取参数前，必须使用 `ngx.req.read_body` 读取请求体。

```lua
 location = /test {
     content_by_lua '
         ngx.req.read_body()
         local args, err = ngx.req.get_post_args()
         if not args then
             ngx.say("failed to get post args: ", err)
             return
         end
         for key, val in pairs(args) do
             if type(val) == "table" then
                 ngx.say(key, ": ", table.concat(val, ", "))
             else
                 ngx.say(key, ": ", val)
             end
         end
     ';
 }
```

请求

```sh
 # Post request with the body 'foo=bar&bar=baz&bar=blah'
 $ curl --data 'foo=bar&bar=baz&bar=blah' localhost/test
```

将输出：

```lua
 foo: bar
 bar: baz, blah
```

多次出现同一个参数 key 时，将生成一个 Lua table，按顺序保存其所有 value。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-redirect)ngx.redirect

发出一个 HTTP `301` 或 `302` 重定向到 `uri`。

可选项 `status` 参数指定 `301` 或 `302` 哪个被使用。 默认使用 `302`。

语法：`ngx.redirect(uri, [status])`。

```lua
return ngx.redirect("/foo")

-- 等价于
return ngx.redirect("/foo", 301)

-- 等价于
return ngx.redirect("/foo", ngx.HTTP_MOVED_TEMPORARILY)
```

重定向到任意外部 URL 也是支持的，例如：

```lua
return ngx.redirect("http://www.baidu.com")
```



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-exec)ngx.exec

使用 `uri`、`args` 参数执行一个内部跳转。内部指的是 Nginx 的某个 location 模块。

语法：`ngx.exec(uri, [args])`

```nginx
location /foo {
     content_by_lua '
         ngx.exec("/bar", "a=goodbye");
     ';
 }

 location /bar {
     content_by_lua '
         local args = ngx.req.get_uri_args()
         for key, val in pairs(args) do
             if key == "a" then
                 ngx.say(val)
             end
         end
     ';
 }
```

访问 `GET /foo/file.php?a=hello`，将返回 『 hello 』 ，而不是 『 goodbye 』

> 注意: `ngx.exec` 方法与 [ngx.redirect](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module#nginx-redirect) 是完全不同的，前者是个纯粹的内部跳转并且没有引入任何额外 HTTP 信号。
>
> 此方法的调用终止当前请求的处理。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-location-capture)ngx.location.capture

向 `uri` 发起一个同步非阻塞 Nginx 子请求。

语法：`ngx.location.capture(uri,[options])`。

> 注意: 它会请求 Nginx 的其他 location 模块，location 模块可以是其他文件目录的配置文件中，或任何其他 Nginx 模块。

```lua
res = ngx.location.capture(uri,[options])
```

`res` 是返回的结果，它是一个「对象」，将包含四个元素的 Lua 表 (`res.status`, `res.header`, `res.body`, 和 `res.truncated`)。

- `res.status` (状态) 保存子请求的响应状态码。
- `res.header` (头) 用一个标准 Lua 表储子请求响应的所有头信息。如果是“多值”响应头，这些值将使用 Lua (数组) 表顺序存储。

如果子请求响应头包含下面的行：

```lua
 Set-Cookie: a=3
 Set-Cookie: foo=bar
 Set-Cookie: baz=blah
```

则 `res.header["Set-Cookie"]` 将存储 Lua 表 `{"a=3", "foo=bar", "baz=blah"}`。

**options 选项**

| 选项                | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| method              | 指定子请求的请求方法, 只接受类似 `ngx.HTTP_POST` 的常量      |
| body                | 指定子请求的请求体 (仅接受字符串值)                          |
| args                | 指定子请求的 URI 请求参数 (可以是字符串或者 Lua 表)          |
| ctx                 | 指定一个 Lua 表作为子请求的 ngx.ctx 表，可以是当前请求的 ngx.ctx 表 |
| vars                | 用一个 Lua 表设置子请求中的 Nginx 变量值                     |
| copy_all_vars       | 设置是否复制所有当前请求的 Nginx 变量值到子请求中，修改子请求的 nginx 变量值不影响当前 (父) 请求 |
| share_all_vars      | 设置是否共享所有当前 (父) 请求的 Nginx 变量值到子请求中，修改子请求的 nginx 变量值将影响当前 (父) 请求 |
| always_forward_body | 当设置为 true 时，如果没有设置 `body` 选项，当前 (父) 请求的请求体将被转发给子请求 |

例如，发送一个 POST 子请求，可以这样做：

```nginx
 res = ngx.location.capture(
     '/foo/bar',
     { method = ngx.HTTP_POST, args = { a = 1,b = 3}, body = 'Hello，World' }
 )
```

等价于：

```lua
res = ngx.location.capture('/foo/bar?a=1&b=3')
```

`method` 选项默认值是 `ngx.HTTP_GET`。

其他内容具体看中文文档，开头有转送门。

> ngx.exec 和 ngx.location.capture 区别
>
> - `ngx.exec` 只会访问同一个配置文件的 location 模块。
> - `ngx.location.capture` 不仅如此，还可以访问其他配置文件的 location 模块。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ngx-req-set-uri)ngx.req.set_uri

语法：`ngx.req.set_uri(uri, jump?)`

通过参数 uri 重写当前请求的 uri；参数 jump，表明是否进行 locations 的重新匹配。当 jump 为 true 时，调用 `ngx.req.set_uri` 后，Nginx 将会根据修改后的 uri，重新匹配新的 locations；如果 jump 为 false，将不会进行 locations 的重新匹配，而仅仅是修改了当前请求的 URI 而已。jump 的默认值为 false。

- jump 为 true，等价于 rewrite...last
- jump 为 false，等价于 rewrite...break

例如：

```lua
ngx.req.set_uri("/foo", true)  === rewrite ^ /foo last;

ngx.req.set_uri("/foo", false)  ===  rewrite ^ /foo break;
```



### 指令API

#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#init-by-lua)init_by_lua

该指令在每次 Nginx 重新加载配置时执行，可以用来完成一些耗时模块的加载，或者初始化一些全局配置。

这是一个公共模块，把所有都用到的代码放到这个模块里，避免重复使用相同的代码。

比如每个模块都需要 MySQL 和 Redis，则在这个公共模块进行引用。

```nginx
init_by_lua_block{
    mysql = require "resty.mysql"
	redis = require "resty.redis"
}
# 下方直接使用 MySQL 和 Redis 的 API
```

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `init_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#init-worker-by-lua)init_worker_by_lua

该指令用于启动一些定时任务，如心跳检查、定时拉取服务器配置等。

例如：

```lua
 init_worker_by_lua '
     local delay = 3  -- in seconds
     local new_timer = ngx.timer.at
     local log = ngx.log
     local ERR = ngx.ERR
     local check

     check = function(premature)
         if not premature then
             -- do the health check or other routine work
             local ok, err = new_timer(delay, check)
             if not ok then
                 log(ERR, "failed to create timer: ", err)
                 return
             end
         end
     end

     local ok, err = new_timer(delay, check)
     if not ok then
         log(ERR, "failed to create timer: ", err)
         return
     end
 ';
```

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `init_worker_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#set-by-lua)set_by_lua

该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给 Nginx 中指定的变量。

| 语法                      | 说明                                      |
| ------------------------- | ----------------------------------------- |
| set_by_lua* \<key> \<value> | key要加上 $ 符号，value 是 Lua 语言的格式 |

例如：

```lua
set_by_lua $name "
		local uri_args = ngx.req.get_uri_args()   -- 获取请求 ? 后的参数
		name = uri_args['name']   -- 获取 key 为 name 的参数
		return name..'先生'   -- 在 name 后面加上 先生，作为 $name 的 value 返回给客户端
	";
```

此时 key 为 `$name` 的 value 值是 URL 的参数 name 加上「先生」。

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `set_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#rewrite-by-lua)rewrite_by_lua

该指令用于执行内部 URL 重写或者外部重定向，典型的如伪静态化 URL 重写，本阶段在 Rewrite 处理阶段的最后默认执行。

例如：

```nginx
location /foo {
    set $a 12; # 创建变量 $a
    set $b ""; # 创建变量 $b
    rewrite_by_lua '
         ngx.var.b = tonumber(ngx.var.a) + 1  # 此时 b = 13
         if tonumber(ngx.var.b) == 13 then
             return ngx.redirect("/bar");   # 重定向到 /bar
         end
     ';
    echo "res = $b";  # res = 13
}
```

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `rewrite_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#access-by-lua)access_by_lua

该指令用于访问控制。例如，如果只允许内网 IP 访问。

```nginx
location / {
    access_by_lua '
        local res = ngx.location.capture("/auth")

        if res.status == ngx.HTTP_OK then
        return
        end

        if res.status == ngx.HTTP_FORBIDDEN then
        ngx.exit(res.status)
        end

        ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
        ';

        # proxy_pass/fastcgi_pass/postgres_pass/...
}
```

注意，在 access_by_lua 处理内部，当调用 `ngx.exit(ngx.OK)` 时，nginx 请求将继续下一阶段的内容处理。要在 access_by_lua 处理中终结当前请求，调用 ngx.exit ，成功的请求设定 status >= 200 (`ngx.HTTP_OK`) 并 status < 300 (`ngx.HTTP_SPECIAL_RESPONSE`)，失败的请求设定`ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)` (或其他相关的)。

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `access_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#content-by-lua)content_by_lua

**该指令是应用最多的指令**，大部分任务是在这个阶段完成的，其他的过程往往为这个阶段准备数据，正式处理基本都在本阶段。

这个指令就相当于 Java 的一个方法，所有的代码都需要一个方法体作为环境。

例如：

```lua
content_by_lua_block {
    set_by_lua $name "
        local uri_args = ngx.req.get_uri_args()   -- 获取请求 ? 后的参数
        name = uri_args['name']   -- 获取 key 为 name 的参数
        return name..'先生'   -- 在 name 后面加上 先生，作为 $name 的 value 返回给客户端
    ";
}
```

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `content_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#header-filter-by-lua)header_filter_by_lua

该指令用于设置应答消息的头部信息。

例如：

```nginx
location / {
	 proxy_pass http://mybackend;
	 header_filter_by_lua 'ngx.header.username = "frx"';
 }
```

你会在请求头看到 name 为 frx

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `header_filter_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#body-filter-by-lua)body_filter_by_lua

该指令是对响应数据进行过滤，如截断、替换。

例如，在输出体转换所有的小写字母，我们可以这样用：

```sh
 location / {
     proxy_pass http://mybackend;
     body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';  # 转小写
 }
```

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `body_filter_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#log-by-lua)log_by_lua

该指令用于在 log 请求处理阶段，用 Lua 代码处理日志，但并不替换原有 log 处理。

例如：

```nginx
server {
    location / {
        proxy_pass http://mybackend;

        log_by_lua '
            local log_dict = ngx.shared.log_dict
            local upstream_time = tonumber(ngx.var.upstream_response_time)

            local sum = log_dict:get("upstream_time-sum") or 0
            sum = sum + upstream_time
            log_dict:set("upstream_time-sum", sum)

            local newval, err = log_dict:incr("upstream_time-nb", 1)
            if not newval and err == "not found" then
            log_dict:add("upstream_time-nb", 0)
            log_dict:incr("upstream_time-nb", 1)
            end
            ';
    }
}
```

如果不喜欢直接写 Lua 语法，把 Lua 语法 放到 Lua 文件里，使用 `log_by_lua_file` 引用 Lua 文件。



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#balancer-by-lua)balancer_by_lua

该指令主要的作用是用来实现上游服务器的负载均衡器算法



#### [#](https://frxcat.fun/middleware/Nginx/Nginx_Lua_Expansion_module/#ssl-certificate-by)ssl_certificate_by

该指令作用在 Nginx 和下游服务开始一个 SSL 握手操作时将允许本配置项的 Lua 代码。



### 简单案例

#### 需求:

发送请求：`http://192.168.91.200?name=张三&gender=1`

Nginx 接收到请求后，根据 gender 传入的值进行判断，如果 gender 传入的是 1，则在页面上展示张三先生,如果 gender 传入的是 0，则在页面上展示张三女士，如果未传或者传入的不是 1 和 2，则在页面上展示张三。

#### 实现

在配置文件进行如下配置：

```nginx
location /getByGender {
	default_type 'text/html';
    
    # set_by_lua 流程分支处理判断变量初始化。该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给Nginx中指定的变量。
    # 由于_lua的后面没有任何内容，所以可以直接在后面编写lua指令
	set_by_lua $name " -- 这里是lua脚本代码了
        -- 获取请求url上的参数对应值 
		local uri_args = ngx.req.get_uri_args()
		gender = uri_args['gender']
		name = uri_args['name']
        -- 条件判断
		if gender=='1' then
			return name..'先生'
		elseif gender=='0' then
			return name..'女士'
		else
			return name
		end
	";
      
    # 指定响应编码
	charset utf-8;
        
	header_filter_by_lua "
		ngx.header.aaa='bbb'
	";
        
	return 200 $name;
}
```

访问测试：`http://192.168.91.200/getByGender?name=冯荣旭&gender=1`

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image43wr3kwp3ag0.webp)

访问测试：`http://192.168.91.200/getByGender?name=冯荣旭`

![image](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/image44pzvk2lzlk0.webp)







## ngx_lua操作Redis

Redis在系统中经常作为数据缓存、内存数据库使用，在大型系统中扮演着非常重要的作用。

在Nginx核心系统中，Redis是常备组件。Nginx支持3种方法访问Redis,分别是`HttpRedis`模块、`HttpRedis2Module`、`lua-resty-redis`库。

这三种方式中HttpRedis模块提供的指令少，功能单一，适合做简单缓存，HttpRedis2Module模块比HttpRedis模块操作更灵活，功能更强大。而**Lua-resty-redis库是OpenResty提供的一个操作Redis的接口库**，可根据自己的业务情况做一些逻辑处理，适合做复杂的业务逻辑。所以本次课程将主要以Lua-resty-redis来进行讲解。



### lua-resty-redis环境准备

步骤一:准备一个Redis环境

```sh
# 连接地址
host= 192.168.200.111
port=6379
```

![1604726959698](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604726959698.webp)



步骤二:准备对应的API

`lua-resty-redis` 提供了访问 Redis 的详细 API，包括创建对接、连接、操作、数据处理等。这些 API 基本上与 Redis 的操作一一对应。

| API                                             | 作用                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| redis = require "resty.redis"                   | 引入 Redis 模块，类似于 Java 的 import。                     |
| redis,err = redis:new()                         | 创建一个 Redis 对象给 redis，err 记录创建失败的原因。        |
| ok,err=redis:connect(host,port[,options_table]) | 设置连接 Redis 的连接信息。 ok：连接成功返回 1，连接失败返回 nil。 err：返回对应的错误信息。 |
| redis:set_timeout(time)                         | 设置请求操作 Redis 的超时时间，单位毫秒。                    |
| ok,err = redis:close()                          | 关闭当前连接。 ok：连接成功返回 1，连接失败返回 nil。 err：返回对应的错误信息。 |
| 原生 Redis 命令如 get、set、lpush 等            | 所有的 Redis 命令都有自己的方法，方法名字和命令名字相同，只是全部为小写。 |



步骤三:效果实现

```lua
location /redis {
    default_type "text/html";
    
    content_by_lua_block {
        local redis = require "resty.redis" -- 引入Redis
        local redisObj = redis:new()  --创建Redis对象
        redisObj:set_timeout(1000) --设置超时数据为1s
        
        local ok,err = redisObj:connect("192.168.200.1",6379) --设置redis连接信息
        if not ok then --判断是否连接成功,如果连接失败返回nil nil属于false
             ngx.say("failed to connection redis",err)
             return
        end
        
        ok,err = redisObj:set("username","TOM")--存入数据
        if not ok then --判断是否存入成功
             ngx.say("failed to set username",err)
             return
        end
        
        -- 注意：调用都是用的冒号
        local res,err = redisObj:get("username") --从redis中获取数据
        ngx.say(res)	--将数据写会消息体中
        redisObj:close()
    }
}
```

步骤四:运行测试效果

![1604727475883](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604727475883.webp)

![1604727483869](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/Nginx/day05/1604727483869.webp)











## ngx_lua操作Mysql

MySQL是一个使用广泛的关系型数据库。在ngx_lua中，MySQL有两种访问模式,分别是使

（1）用`ngx_lua`模块和`lua-resty-mysql`模块：这两个模块是安装OpenResty时默认安装的。

（2）使用`drizzle_nginx_module`(HttpDrizzleModule)模块：需要单独安装，这个库现不在OpenResty中。



### lua-resty-mysql

lua-resty-mysql是OpenResty开发的模块，使用灵活、功能强大，适合复杂的业务场景，同时支持存储过程的访问。

#### 使用lua-resty-mysql实现数据库的查询

步骤一:准备MYSQL，确保能正常连接

```sh
host: 192.168.200.111
port: 3306
username:root
password:123456
```

创建一个数据库表及表中的数据。

```sql
create database nginx_db;

use nginx_db;

create table users(
   id int primary key auto_increment,
   username varchar(30),
   birthday date,
   salary double
);

insert into users(id,username,birthday,salary) values(null,"TOM","1988-11-11",10000.0);
insert into users(id,username,birthday,salary) values(null,"JERRY","1989-11-11",20000.0);
insert into users(id,username,birthday,salary) values(null,"ROWS","1990-11-11",30000.0);
insert into users(id,username,birthday,salary) values(null,"LUCY","1991-11-11",40000.0);
insert into users(id,username,birthday,salary) values(null,"JACK","1992-11-11",50000.0);
```

数据库连接四要素:

```properties
driverClass=com.mysql.jdbc.Driver
url=jdbc:mysql://192.168.200.111:3306/nginx_db
username=root
password=123456
```



步骤二:API学习

- `mysql = require "resty.mysql"`

  引入 MySQL 模块，类似于 Java 的 import。

- `db,err = mysql:new()`

  创建一个 MySQL 连接对象给 db，连接对象遇到错误时，db 为nil，err 为错误描述信息。

- `ok,err = db:connect(Options)`

  尝试连接到一个MySQL服务器。Options 是一个参数的 Lua 表结构，里面包含数据库连接的相关信息。

  Options 选项：

```sql
host：服务器主机名或IP地址
port：服务器监听端口，默认为3306
user：登录的用户名
password：登录密码
database：使用的数据库名
```

- `db:set_timeout(time)`

  设置子请求的超时时间，单位毫秒。

- `ok,err = db:close()`

  关闭当前 MySQL 连接并返回状态。如果成功，则返回1；如果出现任何错误，则将返回nil和错误描述。

```lua
ok：如果成功，则返回 1；如果出现任何错误，则将返回 nil。
err：如果出现任何错误，返回错误描述。
```

- `bytes,err=db:send_query(sql)`

  异步向远程 MySQL 发送一个查询。

  如果成功则返回成功发送的字节数；如果错误，则返回 nil 和错误描述。

- `res, err, errcode, sqlstate = db:read_result([rows])`

  从 MySQL 服务器返回结果中读取一行数据。

  `rows` 指定返回结果集的最大值，默认为 4，可不写。

返回值：

```lua
res：操作的结果集，返回一个描述 OK 包或结果集包的 Lua 表
err：错误信息
errcode：MySQL 的错误码，比如 1064
sqlstate：返回由 5 个字符组成的标准 SQL 错误码，比如 42000
```

如果是查询，则返回一个容纳多行的数组。每行是一个数据列的key-value对，如下:

```json
{
    {id=1,username="TOM",birthday="1988-11-11",salary=10000.0},
	{id=2,username="JERRY",birthday="1989-11-11",salary=20000.0}
}
```

如果是增删改，则返回类上如下数据

```json
{
    insert_id = 0,
    server_status=2,
    warning_count=1,
    affected_rows=2,
    message=nil
}
```

```
（7）read_result
	从MySQL服务器返回结果中读取一行数据。res返回一个描述OK包或结果集包的Lua表,语法:
	res, err, errcode, sqlstate = db:read_result() 
	res, err, errcode, sqlstate = db:read_result(rows) :rows指定返回结果集的最大值，默认为4
	如果是查询，则返回一个容纳多行的数组。每行是一个数据列的key-value对，如

    {
      {id=1,username="TOM",birthday="1988-11-11",salary=10000.0},
      {id=2,username="JERRY",birthday="1989-11-11",salary=20000.0}
    }
	如果是增删改，则返回类上如下数据
    {
    	insert_id = 0,
    	server_status=2,
    	warning_count=1,
    	affected_rows=2,
    	message=nil
    }
	返回值:
		res:操作的结果集
		err:错误信息
		errcode:MySQL的错误码，比如1064
		sqlstate:返回由5个字符组成的标准SQL错误码，比如42000

```



步骤三:效果实现

```lua
location /testMysql {
    default_type "text/html";
    
    content_by_lua_block{
        local mysql = require "resty.mysql"
        local db, err = mysql:new()  			-- 创建实例  
        if not db then  
            ngx.say("new mysql error : ", err)  
            return  
        end
        -- 建立连接 传入数据库连接的相关信息
        local ok,err = db:connect{
            host="192.168.200.111",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db"
        }
        db:set_timeout(1000)	-- 设置超时时间(毫秒)  

        -- 查询语句
        db:send_query("select * from users where id =1")
        local res,err,errcode,sqlstate = db:read_result()
            
	    -- 返回数据 .. 代表拼接   注意：lua的table结构索引从1开始
        ngx.say(res[1].id..","..res[1].username..","..res[1].birthday..","..res[1].salary)
    	db:close()
    }

}
```





**问题:**

上面返回的是需要我们指定返回的数据，但是我们根本不知道查询的数据有多少条，长什么样子。

- 如何获取返回数据的内容
- 如何实现查询多条数据
- 如何实现数据库的增删改操作





#### 使用lua-cjson处理查询结果

通过上述的案例学习，read_result()得到的结果res都是table类型，要想在页面上展示，就必须知道table的具体数据结构才能进行遍历获取。处理起来比较麻烦，接下来我们介绍一种简单方式cjson，使用它就可以将table类型的数据转换成json字符串，把json字符串展示在页面上即可。具体如何使用?

步骤一：引入cjson

```lua
local cjson = require "cjson"
```

步骤二：调用cjson的encode方法进行类型转换

```lua
cjson.encode(res) 
```

步骤三:使用

```lua
location /testMysql {
    default_type "text/html";
    
    content_by_lua_block{

        local mysql = require "resty.mysql"
        local cjson = require "cjson"

        local db = mysql:new()

        local ok,err = db:connect{
            host="192.168.200.111",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db"
        }
        db:set_timeout(1000)

        --db:send_query("select * from users where id = 2")
        db:send_query("select * from users")
        local res,err,errcode,sqlstate = db:read_result()
        
        ngx.say(cjson.encode(res))	-- 转为 JSON 字符串格式
        
        for i,v in ipairs(res) do -- 循环来返回数据
       		ngx.say(v.id..","..v.username..","..v.birthday..","..v.salary)
        end
        
    	db:close()
    }
}
```





#### lua-resty-mysql实现数据库的增删改

优化 `send_query` 和 `read_result`，两个可以变成一体`query`。

本方法是 `send_query` 和 `read_result` 组合的快捷方法。

语法:

```lua
res, err, errcode, sqlstate = db:query(sql[,rows])
```

有了该API，上面的代码我们就可以进行对应的优化，如下:

```lua
location /testMysql {
    default_type "text/html";
    
    content_by_lua_block{

        local mysql = require "resty.mysql"

        local db = mysql:new()

        local ok,err = db:connect{
            host="192.168.200.1",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db",
            max_packet_size=1024,
            compact_arrays=false
        }
        
        db:set_timeout(1000)
        
        -- 查询
        local res,err,errcode,sqlstate = db:query("select * from users")
        -- 新增一条数据
        --local res,err,errcode,sqlstate = db:query("insert into users(id,username,birthday,salary) values(null,'zhangsan','2020-11-11',32222.0)")
        -- 更新数据库
        --local res,err,errcode,sqlstate = db:query("update users set username='lisi' where id = 6")
        -- 删除
        --local res,err,errcode,sqlstate = db:query("delete from users where id = 6")
        db:close()
    }
}
```









### 综合小案例

使用 ngx_lua 模块完成查询 MySQL 数据，然后在 Redis 缓存预热。

> 缓存预热：第一次请求数据时，redis中肯定没有数据，需要去查数据库，此时给用户的体验差。后台的压力也会增加

分析: 

（1）先得有一张表(users)

（2）浏览器输入如下地址

```http
http://191.168.200.133?username=TOM
```

（3）从表中查询出符合条件的记录，此时获取的结果为table类型

（4）使用cjson将table数据转换成json字符串

（5）将查询的结果数据存入Redis中

这里利用到 `init_by_lua_block` 指令，该指令上面介绍过，用于初始化全局变量。这里用于初始化 MySQL、Redis、cjson 模块。

还是使用了 `quote_sql_str` 指令，防止「拼」SQL，导致 SQL 注入。

```lua
# 初始化全局变量
init_by_lua_block{
    redis = require "resty.redis"
    mysql = require "resty.mysql"
    cjson = require "cjson"
}

location / {
    default_type "text/html";
    
    content_by_lua_block{
        --获取请求的参数username
        local param = ngx.req.get_uri_args()["username"]
        
        --建立mysql数据库的连接
        local db = mysql:new()
        local ok,err = db:connect{
            host="192.168.200.111",
            port=3306,
            user="root",
            password="123456",
            database="nginx_db"
        }
        if not ok then
            ngx.say("failed connect to mysql:",err)
            return
        end
        
        --设置连接超时时间
        db:set_timeout(1000)
        
        --查询数据
        local sql = "";
        if not param then --没有uri 查询所有
            sql="select * from users"
        else
            --sql="select * from users where username=" .. "'" .. param .. "'" -- sql 注入 ，不建议
            sql="select * from users where username=" .. ngx.quote_sql_str(ch_param) -- 防止 sql 注入
        end
        local res,err,errcode,sqlstate=db:query(sql)
        if not res then
            ngx.say("failed to query from mysql:",err)
            return
        end
        
        --连接redis
        local rd = redis:new()
        ok,err = rd:connect("192.168.200.111",6379)
        if not ok then
            ngx.say("failed to connect to redis:",err)
            return
        end
        rd:set_timeout(1000)
        
        --循环遍历数据
        for i,v in ipairs(res) do
            --  key, value
            rd:set("user_"..v.username, cjson.encode(v))
        end
        
        ngx.say("success")
        -- 关闭 MySQL 和 Rdis 的连接
        rd:close()
        db:close()
    }

}
```

