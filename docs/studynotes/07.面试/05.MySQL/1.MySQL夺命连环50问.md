---
title: MySQL夺命连环50问
date: 2023-01-29 13:46:53
permalink: /pages/329723/
categories:
  - studynotes
  - 面试
  - MySQL
tags:
  - MySQL
author: 
  name: Xuan
  link: https://github.com/Sidney-Su
---
### 1、B树和B+树之间的区别是什么？

B树

- 非叶子与叶子节点都存储了数据

B+树

- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。
  - 即：叶子节点存储所有数据
  - 而非叶子节点是冗余的数据
- 所有的数据都会出现在叶子节点
- 所有叶子节点形成了一个单向链表
  - MySQL中的叶子节点形成了一个双向链表



### 2、Innodb中的B+树有什么特点？

常用索引数据结构：

- 二叉树

  - 顺序插入时，会形成一个单向链表，查询性能大大降低。
    - 此时与全表扫没区别了，且增加了索引的存储空间
  - 大数据量情况下，层级较深，检索速度慢。

- 红黑树

  - 自平衡二叉树，顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树
  - 大数据量情况下，层级较深，检索速度慢

- hash表

  - **只能进行精准匹配，满足 "="  "in"，无法进行范围查找**
  - 存储时是没顺序的
  - 对索引的key进行一次hash计算就可以定位出数据存储的位置
    - 很多时候Hash索引要比B+树索引更高效
  - 如果出现hash冲突，检索效率降低

- B-Tree

  - 叶子节点具有相同的深度(减小了树的高度)，叶子节点的指针为空
  - 所有索引元素不重复
  - 节点中的数据索引从左到右递增排序

- **B+Tree(MySQL)**
- 非叶子节点不存储data，只存储索引（冗余），可以放更多的索引
  - 叶子节点包含所有索引字段
  - **叶子节点用指针连接，提高区间访问的性能**
    - 叶子节点形成一个单向链表(双向链表)
  
- 支持精准匹配与范围查找
  - 节点中的数据索引从左到右递增排序
    - MySQL8 可以指定B树的节点顺序



### 3、什么是Innodb中的page？

MySQL中 一页=16k

内存从磁盘加载数据是一页一页的存取(存储/读取)的，所以一张表中的数据，也是直接载入了一页到内存中。
用页减少了对磁盘的读写频率。



### 4、Innodb中的B+树是怎么产生的？(内部链表的优化采用页目录进行优化)

```sql
insert into t1 values(4,3,1,1,'d');
insert into t1 values(1,1,1,1,'a');
insert into t1 values(8,8,8,8,'h');
insert into t1 values(2,2,2,2,'b');
insert into t1 values(5,5,5,5,'e');
insert into t1 values(3,3,3,3,'c');
```

一条一条的来：

首先MySQL插入数据的时候就已经排好了序(最好是顺序插入不会造成页分裂之类的)，这样的话，如果执行 select * from t1 where a=3，一条一条遍历时匹配到 a>3 的记录就不会继续执行了(因为顺序)。

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/数据库/MySQL夺命连环50问/image-20220424104221640.webp" alt="image-20220424104221640" style="zoom:50%;" />

但是如果想查询 select * from t1 where a=3000，可以看到这是一个链表，查询还是比较耗时的，解决办法：页目录(对每页数据进行分组)，页目录中需要存储 每一页的起始序号与页起始地址。这样的话，它的查询顺序为：先去页目录中查找起始位置对应的页区域，然后再具体的定位到记录。

> select * from t1 where a=3000，先取出页目录中的数据载入内存，定位到a=3000在页目录中的哪一组

最终数据在页中的存储结构如下：

![image-20220424104747038](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/数据库/MySQL夺命连环50问/image-20220424104747038.webp)

如果执行：select * from t1 where a=6，会先加载第1页到内存然后遍历页目录。页目录中没找到继续加载第二页然后遍历页目录。(且这一页一页的都是从磁盘中进行加载的)
问题：如果执行 select * from t1 where a=3000 怎么办？最终还是组成了一个链表

> 内部链表的优化采用页目录进行优化

新开一页，作为一个大的页目录，比如这个里面存了4个页。那么实际存放为：每一页中记录的最小索引。这样每次载入内存时，先载入这一个大的页目录，然后具体匹配。最终这就形成了如图的高度为2的B+树结构

![image-20220424110728605](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/数据库/MySQL夺命连环50问/image-20220424110728605.webp)



### 5、高度为3的B+树能存多少条数据？

假设：一页中一行记录为1K，则一页中一共可以存16行。InnoDB的指针占用6个字节的空间，如果一列大小为bigint(8字节)

当高度为2时：n\*8(列所占字节数) + (n+1)\*6(索引指针所占字节数 比key大1) = 16\*1024(一页总数)
=> n≈1170，则一行可存1170个主键，则指针有1171个。
1170*16 = 18736 也就是说，如果树的高度为2，则可以存储 18000 多条记录。

高度为3：1171 * 1171 * 16 = 21939856
也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。

> 建议为2-3层的B+树最好。一般B+树到了4层那就比较麻烦了，因为每一页都是从磁盘载入内存的



### 6、什么是聚簇索引？

聚集索引：数据存储与索引放到了一块
如果存在主键，主键索引就是聚集索引。



### 7、Innodb是如何支持范围查找能走索引的？

```sql
-- 如：给age加了索引，然后执行
select age from stu where age>6;
select age from stu where age<6;
```

会先执行 select age from stu where age=6，从而快速定位到此记录，然后 直接返回 >6 或 <6 的所有记录(由于是双向链表，所以可以直接返回)

但是 select * from stu where age>6; 的话，如果走索引先根据 select age from stu where age=6 找到所有>6的记录，然后将这些记录一一进行回表返回 * 。
然后MySQL根据优化决策，速度觉得还不如全表扫。



### 8、什么是联合索引？对应的B+树是如何生成的？

联合索引：对多个列创建同一个索引，在查询时需要满足最左前缀法则。

首先：创建一个索引就需要构建一颗B+树

![image-20220411151327873](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/数据库/MySQL夺命连环50问/image-20220411151327873.webp)

> 叶子节点挂的是主键id



### 9、什么是最左前缀原则？

查询时需要依赖于构建联合索引的字段的顺序，即：构建联合索引的字段顺序是怎样的，查询的顺序就得怎样且联合索引的第一个字段必不可少

> where 不在乎顺序，只要第一个索引字段出现就行。但是order by与group by必须在乎顺序



### 10、为什么要遵守最左前缀原则才能利用到索引？

因为联合索引按不同字段创建时，会按照不同的字段进行排序。
创建联合索引：xyz 的顺序

查找时：*11 这样的话就会全表，因为可能存在多个 11，且只有第一个索引是绝对的有序，二、三索引相对有序，所以如果缺少了第一个索引的匹配，就必须得定位出所有的字段

\*11 无法走索引；1\*1、11\* 可以走索引。我超 这也是最左前缀法则引出来的
即 \*11 无法确定范围，只能全表；1\*1、11\* 可以确定范围，无需全表

先根据条件先基于索引进行一层过滤，再去拿id值去主键索引中进行值匹配



### 11、什么是覆盖索引？

查询的字段刚好存在于B+树中，无需回表




### 12、有哪些情况会导致索引失效？

1.对索引进行操作 索引失效

2.字符串不加引号 

- 因为MySQL会尝试遍历B+树转换字符串类型为数值类型。

3.模糊查询时，进行头模糊。即：'*11'

4.or两端条件中没有索引列

5.MySQL自动评估，走索引快还是走全表扫描快



1.没有符合最左前缀原则

2.字段进行了隐私数据类型转化

3.走索引没有全表扫描效率高



### 13、为什么建议InnoDB表必须建主键，并且推荐使用<font color="red">整型的自增</font>主键？

为了维护B+树的数据结构

- 如果存在主键，主键索引就是聚集索引。
- 如果不存在主键，将使用第一个定义的非空唯一（UNIQUE）索引作为聚集索引。
- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

所以建议自己建主键的目的：不要让MySQL浪费性能了



**整型主键**

- 在内存中通过折半比较大小，用整型比较大小比用字符串比较大小快
- 相对来说，整型比字符串节省空间
  - 整型无需按编码排序；但是字符串可能需要按照制定的编码进行排序



**自增主键**

- 自增的是顺序的，不会造成页分裂
- 主键不是顺序添加的话，会产生页分裂



为什么非主键索引结构叶子节点存储的是主键值？（一致性和节省存储空间）



### 14、MyISAM和InnoDB的区别是什么？

**1.InnoDB支持事务，MyISAM不支持事务。**
这是MySQL将默认存储引擎从MyISAM变成InnoDB的重要原因之一；

**2.InnoDB支持外键，而MyISAM不支持。**
对一个包含外键的InnoDB表转为MYISAM会失败；

**3.InnoDB 是聚集索引，MyISAM 是非聚集索引。**
聚簇索引的文件存放在主键索引的叶子节点上，因此InnoDB必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

**4.InnoDB不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；**

**5.InnoDB 最小的锁粒度是行锁，MyISAM最小的锁粒度是表锁。**
一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从MylSAM变成InnoDB的重要原因之一；



**MyISAM：**

- 不支持事务，但是每次查询都是原子的；
- 支持表级锁，即每次操作是对整个表加锁；
- 存储表的总行数；
- 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；
- 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。

**InnoDb：**

- 支持ACID的事务，支持事务的四种隔离级别；
- 支持行级锁及外键约束：因此可以支持写并发；
- 不存储总行数；
- 一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；

- 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。



### 15、数据库表设计时，字段你会如何选择？

#### 1. 字段类型优先级

整型 > date, time > enum char > varchar >  blob,text
选用字段长度最小、优先使用定长型、数值型字段中避免使用 “ZEROFILL”。
time：定长运算快，节省时间，考虑时区，写sql不方便
enum：能约束值的目的，内部用整形来储存，但与char联查时，内部要经历串与值的转化
char：定长，考虑字符集和校对集
varchar：不定长，要考虑字符集的转换与排序时的校对集，速度慢
text,blob：无法使用内存临时表（排序操作只能在磁盘上进行）

> 注意：date，time 的选择可以直接选择使用时间截，enum(“男”，“女”) //内部转成数字来储存，多了一个转换的过程，可以使用tinyint代替最好使用tinyint。

#### 2. 可以选整型就不选字符串

**整型是定长的，没有国家/地区之分，没有字符集差异**。例如：tinyint 和 char(1) 从空间上看都是一字节，但是order by 排序 tinyint 快。原因是后者需要考虑字符集与校对集（就是排序优先集）

#### 3. 够用就行不要慷慨

大的字段影响内存影响速度。以年龄为例：tinyint unsigned not  null；可以储存255岁，足够了，用 int 浪费3个字节。以varchar(10)，varchar(300) 储存的内容相同，但在表中查询时，varchar(300) 要花用更多内存。

#### 4. 尽量避免使用NULL

Null不利于索引，也不利于查询。=null 或者 !=null 都查询不到值，只有使用 is null 或者 is  not null 才可以。因此可以在创建字段时候使用 not null default "" 的形式。

#### 5. char与varchar选择

char 长度固定，处理速度要比 varchar 快很多，但是相对较费存储空间；所以对存储空间要求不大，但在速度上有要求的可以使用 char 类型，反之可以用 varchar 类型。



### 16、Mysql中varchar(M)最多能存储多少数据？

对于 varchar(M) 类型的列最多可以定义65535个字节。其中的M代表该类型最多存储的字符数量，但在实际存储时并不能放这么多。

MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。



### 17、请说下事务的基本特性

事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。

- 原子性指的是一个事务中的操作要么全部成功，要么全部失败。
- 一致性指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块，因为事务没有提交，修改也就不会保存到数据库。

- 隔离性指的是一个事务的修改在最终提交前，对其他事务是不可见的。

- 持久性指的是一旦事务提交，所做的修改就会永久保存到数据库中。



**事务的隔离级别**：SHOW VARIABLES like‘transaction%‘

设置隔离级别：set transaction level xxx 设置下次事务的隔离级别。

set session transaction level xxx 设置当前会话的事务隔离级别

set global transaction level  xxx 设置全局事务隔离级别

**MySQL当中有五种隔离级别**

- NONE：不使用事务。

- READ UNCOMMITED：允许脏读

- READ COMMITED：防止脏读，最常用的隔离级别
- REPEATABLE  READ：防止脏读和不可重复读。MYSQL默认
- SERIALIZABLE：事务串行，可以防止脏读、幻读，不可重复读。

五种隔离级别，级别越高，事务的安全性是更高的，但是，事务的并性能也就会越低。



### 18、事务并发时能引发什么问题？如何处理

#### 1. 脏读

事务读取另一个事务未提交的数据。

#### 2. 不可重复读

事务读取到另一个事务已提交的数据。
比如：事务A读取id=1的数据；同时事务B对id=1的数据进行了修改并提交事务；当事务A再次读取id=1的数据时发现与之前读取的id=1的数据不一致。

#### 3. 幻读

事务读不到另一个事务已提交的数据。
比如：事务A读取id=1的数据，读不到。当A读完后，B新插了一条id=1的数据到数据库并提交事务。此时A新增一条id=1的数据，发现数据库中已存在这条记录。当A再次读取id=1的数据时还是读不到(这是解决了不可重复读引起的)

#### 4. 处理

处理的方式有很多种：加锁、事务隔离、MVCC

##### 加锁：

1、脏读：在修改时加排他锁，直到事务提交才释放。读取时加共享锁，读完释放锁。

> 锁必然会导致性能的损失；多个事务并发时，并不能完全避免脏读

2、不可重复读：读数据时加共享锁，写数据时加排他锁。

3、幻读：加范围锁。



### 19、简单描述下MySQL各种索引？

MySQL索引按字段特性分类可分为：主键索引、唯一索引、普通索引、前缀索引

#### 1. 主键索引

建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。

#### 2. 唯一索引

建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。

> 唯一与主键的唯一区别：主键不允许重复不允许为空；唯一不允许重复允许为空

#### 3. 普通索引

建立在普通字段上的索引被称为普通索引。

#### 4. 前缀索引

**前缀索引**是指对字符类型字段的**前几个字符**或对二进制类型字段的前几个bytes**建立的索引**，而不是在整个字段上建索引。前缀索引可以建立在类型为 char, varchar, binary, varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。

前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：**<font color="red">mysql无法使用前缀索引做 order by 和 group  by 。</font>**



### 20、什么是三星索引？

对于一个查询而言，一个三星索引，可能是其最好的索引。

如果查询使用三星索引，一次查询通常只需要进行一次磁盘随机读以及一次窄索引片的扫描，因此其相应时间通常比使用一个普通索引的响应时间少几个数量级。

- **一个查询相关的索引行是相邻的或者至少相距足够靠近的则获得一星；**

- **如果索引中的数据顺序和查找中的排列顺序一致则获得二星；**
- **如果索引中的列包含了查询中需要的全部列则获得三星。**

三星索引在实际的业务中如果无法同时达到，一般我们认为第三颗星最重要，第一和第二颗星重要性差不多，根据业务情况调整这两颗星的优先度。



### 21、如何提高insert的性能？

#### 1、合并多条insert为一条

```sql
insert into t values(a,bc), (a,b,c)...
```

原因分析：主要原因是多条insert合并后日志量（MySQL的binlog和innodb的事务日志）减少了，降低日志刷盘的数据量和频率，从而提高效率。通过合并SQL语句，同时也能减少SQL语句解析的次数，减少网络传输的IO。

#### 2、修改参数 bulk_insert_buffer_size，调大批量插入的缓存；

bulk_insert_buffer_size：批量插入时的缓存

#### 3、设置 innodb_flush_log_at_trx_commit = 0

相对于innodb_flush_log_at_trx_commit =  1可以十分明显的提升导入速度；

innodb_flush_log_at_trx_commit 参数解释如下：

- 0：log buffer 中的数据将以每秒一次的频率写入到 log  file 中，且同时会进行文件系统到磁盘的同步操作，但是每个事务的 commit 并不会触发任何 log buffer 到 log  file 的刷新或者文件系统到磁盘的刷新操作；

- 1：在每次事务提交的时候将 log buffer 中的数据都会写入到 log  file ，同时也会触发文件系统到磁盘的同步；

- 2：事务提交会触发 log buffer 到 log file 的刷新，但并不会触发磁盘文件系统到磁盘的同步。此外，每秒会有一次文件系统到磁盘同步操作。

#### 4、手动使用事务

因为mysql默认是 autocommit 的，这样每插入一条数据，都会进行一次 commit; 所以，为了减少创建事务的消耗，我们可用手工使用事务

```sql
START  TRANSACTION;
insert ... ,
insert ... ,
...
commit;
```

**即执行多个insert后再一起提交；一般1000条insert提交一次。**



### 22、什么是全局锁、共享锁、排它锁？

**全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份。**这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。

**共享锁又称读锁（read  lock），是读取操作创建的锁。**其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。

**排他锁 exclusive lock（也叫 writer lock）又称写锁。**

若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取，不能进行写操作，需等待其释放。排它锁是悲观锁的一种实现。

若事务1对数据对象A加上X锁，事务1可以读A也可以修改A，其他事务不能再对A加任何锁，直到 事物1释放A上的锁。这保证了其他事务在事物1释放A上的锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁。



### 23、谈一下MySQL中的死锁

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。

**如何查看死锁？**

使用命令 show engine innodb status 查看最近的一次死锁。

InnoDB Lock Monitor 打开锁监控，每15s输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。

**对待死锁常见的两种策略：**

通过 innodblockwait_timeout 来设置超时时间，一直等待直到超时；

发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。



### 24、MySQL集群如何搭建？Mysq如何实现读写分离？

![image-20220424152938287](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/数据库/MySQL夺命连环50问/image-20220424152938287.webp)

> MySQL的读写分离依赖于 binlog，对MySQL的任何增删改，都会记录到此文件中。
>
> 当搭建了读写分离的服务器集群，主库中会启动一个异步线程，这个异步线程会将binlog复制到从库中，从库收到数据后，会写入relay log中继日志中，然后从库启动一个sql线程去执行中继日志中的insert与update
>
> 即主库插入一条数据，从库也会插入一条记录

缺点：这个过程是异步的，非常极端的情况下：主库宕机，binlog还没来得及进行复制，他就会导致数据的丢失。最终造成从库中的数据不一致



MySQL通过将主节点的Binlog同步给从节点完成主从之间的数据同步。

**MySQL的主从集群只会将binlog从主节点同步到从节点，而不会反过来同步。由此也就引申出了读写分离的问题。**
因为要保证主从之间的数据一致，写数据的操作只能在主节点完成，而读数据的操作，可以在主节点或从节点上完成。



MySQL主从集群默认采用的是一种异步复制的机制。主服务在执行用户提交的事务后，写入binlog日志，然后就给客户端返回一个成功的响应了。而binlog会由一个dump线程异步发送给Slave从服务。

![image-20220425093933997](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/数据库/MySQL夺命连环50问/image-20220425093933997.webp)

由于这个发送binlog的过程是异步的。主服务在向客户端反馈执行结果时，是不知道binlog是否同步成功了的。这时候如果主服务宕机了，而从服务还没有备份到新执行的binlog，那就有可能会丢数据。（只管发，其他就不管了）

那怎么解决这个问题呢，这就要靠MySQL的半同步复制机制来保证数据安全。

![image-20220425094118158](https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/数据库/MySQL夺命连环50问/image-20220425094118158.webp)

> 由于Binlog记录了每次增删改的操作，所以不仅主从同步时可作用，还能作用于同步到redis，同步到kafaka



### 25、Mysq如何实现分库分表

什么是分库分表？就是当表中的数据量过大时，整个查询效率就会降低得非常明显。这时为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表当中。



**数据分片的方式有垂直分片和水平分片。**
垂直分片就是从业务角度将不同的表拆分到不同的库中，能够解决数据库数据文件过大的问题，但是不能从根本上解决查询问题。
水平分片就是从数据角度将一个表中的数据拆分到不同的库或表中，这样可以从根本上解决数据量过大造成的查询效率低的问题。

垂直分片

- 如将一个库中的user表与order表，拆分成user库的user表与order库的order表

- 解决了数据分布问题，但没解决查询效率问题

水平分片

- 将一张表的数据拆分成两张表
  - 可对数据进行拆分
  - 可对列进行拆分

> 平常说的分库分表就是指水平分片

常用的分片策略有：

取余取模：优点 均匀存放数据，缺点 扩容非常麻烦
按照范围分片：比较好扩容，数据分布不够均匀
按照时间分片：比较容易将热点数据区分出来。
按照枚举值分片：例如按地区分片
按照目标字段前缀指定进行分区：自定义业务规则分片



阿里提供的开发手册当中，建议：一个表的数据量超过500W或者数据文件超过2G，就要考虑分库分表了。

> 分库分表是在开始设计之前就需要提前预估的。阿里建议：3年内业务量能达到500w就需要进行分库分表了

<img src="https://cdn.staticaly.com/gh/Sidney-Su/cartographic-bed@main/计算机/数据库/MySQL夺命连环50问/image-20220425100320839.webp" alt="image-20220425100320839" style="zoom:50%;" />

分库分表最容易被问到的不是原理，而是问题如何解决？如何去查询？
比如：一个user表，按照userid进行了分片，然后我需要按照sex字段去查，这要怎么查？强制指定只查一个数据库，要怎么做？查询结果按照userid来排序，要怎么排？

**缺点**

- 事务一致性问题

原本单机数据库有很好的事务机制能够帮我们保证数据一致性。但是分库分表后，由于数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题。

- 跨节点关联查询问题

在没有分库时，我们可以进行很容易的进行跨表的关联查询。但是在分库后，表被分散到了不同的数据库，就无法进行关联查询了。

这时就需要将关联查询拆分成多次查询，然后将获得的结果进行拼装。

- 跨节点分页、排序函数

跨节点多库进行查询时，limit分页、order  by排序等问题，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序。

这时非常容易出现内存崩溃的问题。

- 主键避重问题

在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。

- 公共表处理

实际的应用场景中，参数表、数据字典表等都是数据量较小，变动少，而且属于高频联合查询的依赖表。这一类表一般就需要在每个数据库中都保存一份，并且所有对公共表的操作都要分发到所有的分库去执行。



### 26、索引的基本原理

索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。

索引的原理：就是把无序的数据变成有序的查询

1. 把创建了索引的列的内容进行排序
2. 对排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据



### 27、mysql 聚簇和非聚簇索引的区别

都是B+树的数据结构。

聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的

非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，这个就有点类似一本树的目录，比如我们要找第三章第一节，那我们先在这个目录里面找，找到对应的页码后再去对应的页码看文章。

```properties
优势：
1、查询通过聚簇索引可以直接获取数据，相比非聚族索引需要第二次查询（非覆盖索引的情况下）效率要高
2、聚族索引对于范围查询的效率很高，因为其数据是按照大小排列的
3、聚簇索引适合用在排序的场合，非聚族索引不适合劣势：

劣势：
1、维护索引很昂贵，特别是插入新行或者主键被更新导至要分页（page split）的时候，建议在大量插入新行后，选在负载较低的时间段，通过 optimize table 优化表，因为必须被移动的行数据可能造成碎片，使用独享表空间可以弱化碎片
2、表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚族索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键
3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间
```

InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏id来当作主键索引。

MyISM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。

如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。



### 28、mysql 索引结构，各自的优劣

见：Innodb中的B+树有什么特点？



### 29 、索引的设计原则

查询更快、占用空间更小

1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
2. 基数较小的表，索引效果较差，没有必要在此列建立索引
3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。

4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至，重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。

5. 定义有外键的数据列一定要建立索引。

6. 更新频繁字段不适合创建索引
7. 若是不能有效区分数据的列不适合做索引列（如性别，男女未知，最多也就三种，区分度实在太低）
8. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
   - 即尽量使用联合索引

9. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

10. 对于定义为text，image和bit的数据类型的列不要建立索引。



### 30、mysql 锁的类型有哪些

基于锁的属性分类：共享锁、排他锁。

基于锁的粒度分类：行级锁（INNODB）、表级锁（INNODB，MYISAM）、页级锁（BDB引擎）、记录锁、间隙锁、临键锁。

基于锁的状态分类：意向共享锁、意向排它锁。

- 共享锁（Share  Lock）

```properties
共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。

共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。
```

- 排他锁（eXclusive  Lock）

```properties
排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。

避免了出现脏数据和脏读的问题。
```

- 表锁

```properties
表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；

特点：粒度大，加锁简单，容易冲突；
```

- 行锁(可能锁多行)

```properties
行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；

特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；
```

- 记录锁（只锁一行）

```properties
记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。

精准条件命中，并且命中的条件字段是唯一索引
加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。
```

- 页锁

```properties
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。
所以取了折衷的页级，一次锁定相邻的一组记录。

特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
```

- 间隙锁（Gap  Lock）

```properties
属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。

范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在 repeatable_read(RR重复读)的事务级别中。

触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两
次查询出的结果会不一样。
比如表里面的数据ID为1，4，5，7，10，那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间（-n代表负无穷大，n代表正无穷大）
```

- 临键锁

```properties
也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住

触发条件：范围查询并命中，查询命中了索引。

结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。
```



如果事务A加了行锁，而事务B向加表锁，就会一行一行遍历是否加了行锁产生冲突。

而意向锁就是，如果事务A加了行锁，会自动加一个意向锁。如果事务B想加表锁，就会判断意向锁这个标识。从而避免了对整个索引树的每个节点扫描是否加锁。

- 意向共享锁

```properties
当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁。
```

- 意向排他锁

```properties
当一个事务试图对整个表进行加排它锁之前，首先需要获得这个表的意向排它锁。
```



### 31、mysql 执行计划怎么看

执行计划就是sql的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数

```sql
explain select * from A where X=? and Y=?
```

1. id：是一个有顺序的编号，是查询的顺序号，**有几个select  就显示几行**。id的顺序是按select出现的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为NULL最后执行。

2. selectType 表示查询中每个select了句的类型。

- SIMPLE：表示此查询不包含UNION查询或子查询。

- PRIMARY：表示此查询是最外层的查询（包含子查询）。

- SUBQUERY：子查询中的第一个 SELECT。

- UNION：表示此查询是UNION 的第二或随后的查询
- DEPENDENT UNION：UNION 中的第二个或后面的查询语句，取决于外面的查询。

- UNION RESULT：UNION 的结果。

- DEPENDENT SUBQUERY：子查询中的第一个 SELECT，取决于外面的查询。即子查询依赖于外层查询的结果。

- DERIVED：衍生，表示导出表的SELECT（FROM子句的子查询）

3. table：表示该语句查询的表
4. **type：优化sql的重要字段，也是我们判断sql性能和优化程度重要指标。**他的取值类型范围：

- const：通过索引**一次命中**，匹配一行数据。

- system：表中只有一行记录，相当于系统表；
  - 一次命中

- eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。
  - 可能回表

- ref：非唯一性索引扫描，返回匹配某个值的所有
  - 可能回表
- range：只检索给定范围的行，使用一个索引来选择行，一般用于between、<、>；。

- index：只遍历索引树；
  - 所有的索引都会遍历

- ALL：表示全表扫描，这个类型的查询是性能最差的查询之一。那么基本就是随着表的数量增多，执行效率越

> 执行效率：
> **<font color="red">ALL < index < range< ref < eq_ref < const <  system。最好是避免ALL和index</font>**

5. possible_keys：它表示Mysql在执行该sql语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。

6. key：此字段是mysql 在当前查询时所真正使用到的索引。他是possible_keys的子集

7. key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化sql时，评估索引的重要指标
8. rows：mysql查询优化器根据统计信息，估算该sql返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大
9. filtered：返回结果的行占需要读到的行（rows列的值）的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少
10. extra

- using  filesort：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有using  filesort都建议优化去掉，因为这样的查询cpu资源消耗大，延时大。

- using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能错。

- using temporary：查询有使用临时表，一般出现于排序，分组和多表join的情况，查询效率不高，建议优
- using  where：sql使用了where过滤，效率较高。



### 32、怎么处理慢查询

在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

慢查询的优化首先要搞明白慢的原因是什么？是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？

所以优化也是针对这三个方向来的

- 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。

- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。

- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。



1.检查是否走了索引，如果没有则优化SQL利用索引
2.检查所利用的索引，是否是最优索引
3.检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据
4.检查表中数据是否过多，是否应该进行分库分表了
5.检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源



### 33、ACID靠什么保证的

A 原子性 由undo  log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

C 一致性 由其他三大特性保证、程序代码要保证业务上的一致性

I 隔离性 由MVCC+锁来保证

D 持久性 由 内存+redo  log 来保证，mysql修改数据同时在内存和 redo log 记录这次操作，宕机的时候可以从 redo log 恢复

```properties
InnoDB redo 1og 写盘，InnoDB 事务进入 prepare 状态。
如果前面prepare成功，bin1og写盘，再继续将事务日志持久化到binlog，如果持久化成功，那么InnoDB 事务则进入commit状态（在redo 1og里面写一个commit记录）
# 怎样判断提交成功，看redo 1og中有无commit记录
```

redolog的刷盘会在系统空闲时进行



### 34、什么是MVCC

**多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据，版本链**

MVCC 只在 read_committed(RC) 和 repeatable_read(RR) 两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为 read_uncommitted 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 serializable 则会对所有读取的行都加锁。

> RC与RR下，MySQL才会启动MVCC机制

聚簇索引记录中有两个必要的隐藏列：

**trx_id**：用来存储每次对某条聚簇索引记录进行修改的时候的事务id。

**roll_pointer**：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。**（注意插入操作的undo日志没有这个属性，因为它没有老版本）**

**已提交读 和 可重复读 的区别就在于它们生成ReadView的策略不同。**



开始事务时创建 readview，readView 维护当前活动的事务id，即未提交的事务id，排序生成一个数组

访问数据，获取数据中的事务id（获取的是事务id最大的记录），对比readview：

- 如果在readview的左边（比readview都小），可以访问（在左边意味着该事务已经提交）
- 如果在readview的右边（比readview都大）或者就在readview中，不可以访问，获取roll_pointer，取上一版本重新对比（在右边意味着，该事务在readview生成之后出现，在readview中意味着该事务还未提交）



已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView，而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

这就是Mysql的MVCC，通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。



### 35、mysql主从同步原理

mysql主从同步的过程：

Mysql的主从复制中主要有三个线程：`master(binlog dump thread)、slave(I/O thread、SQLthread)`。Master 条线程和Slave中的两条线程。

- 主节点binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。

- 主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。

- 从节点I/O线程接收binlog内容，并将其写入到 relay log 文件中。

- 从节点的SQL线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。

注：主从节点使用 binglog文件 + position偏移量 来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从position的位置发起同步。



由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。

#### 全同步复制

主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

#### 半同步复制

和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。



### 36、 简述mysql中索引类型及对数据库的性能

- 普通索引：允许被索引的数据列包含重复的值。

- 唯一索引：可以保证数据记录的唯一性。

- 主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字primary key 来创建。

- 联合索引：索引可以覆盖多个数据列，如像 index(columnA，columnB) 索引。

- 全文索引：通过建立**倒排索引**，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过 alter table table_name ADD FULLTEXT(column); 创建全文索引

索引可以极大的提高数据的查询速度。

- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

- 但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件

- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。





### 37、MySQL的锁有哪些？

#### 从锁的粒度来区分

1、行锁：加锁粒度小，但是加锁资源开销比较大.InnDB支持。

共享锁：读锁。多个事务可以对同一个数据共享同一把锁。持有锁的事务都可以访问数据，但是只能读不能修改。select xxx LOCK IN SHARE  MODE。

排他锁：写锁。只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。InnoDB会对 update/delete/linsert 语句自动添加排他锁。SELECT  xxx FOR UPDATE。

自增销：通常是针对MySQL当中的自增字段。(每次insert一条数据，都会加个自增锁)如果有事务回滚这种情况，数据会回滚，但是自增序列不会回滚。



2、表锁：加锁粒度大，加锁资源开销比较小.MyISAM和InnoDB都支持。

表共享读锁表

排他写锁

意向锁：是InnoDB自动添加的一种锁，不需要用户干预。



3、全局锁：Flush tables with read lock，加锁之后整个数据库实例都处于只读状态。所有的数据变更操作都会被挂起。一般用于全库备份的时候。

常见的锁算法：user：userid(1,4,9) 
执行 update user set xxx where userid=5；会不会加锁呢？看隔离级别，如果是RR级别就会加
RR级别加间隙锁 锁住(5,9)

如果为 userid(1,4,9) 则会划分几个区间：(-无穷,1)、(1,4)、(4,9)、(9,+无穷)

- 1、记录锁：锁一条具体的数据。
- 2、间隙锁：RR隔离级别下，会加间隙锁。锁一定的范围，而不锁具体的记录。是为了防止产生幻读。
- 3、Next-key(应该就是临键锁)：间隙锁+右记录锁。(-无穷,1]、(1,4]、(4,9]、(9,+无穷)



### 38、MySQL的索引结构是什么样的？

二叉树 -》AVL树-》红黑树-》B-树-》B+树

- 二叉树：每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。

- AVL树：树中任意节点的两个子树的高度差最大为1
- 红黑树：1、每个节点都是红色或者黑色。2、根节点是黑色。3、每个叶子节点都是黑色的空节点。4、红色节点的父子节点都必须是黑色。5、从任一节点到其每个叶子节点的所有路径都包含相同的黑色节点。

- B-树：1、B-树的每个非叶子节点的子节点个数都不会超过D（这个D就是B-树的阶）2、所有的叶子节点都在同一层。3、所有节点关键字都是按照递增顺序排列。

- B+树：1、非叶子节点不存储数据，只进行数据索引。2、所有数据都存储在叶子节点当中。3、每个叶子节点都存有相邻叶子节点的指针。4、叶子节点按照本身关键字从小到大排序。



聚簇索引就是数据和索引是在一起的。

- MyISAM使用的是非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址。InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。

- 聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。

InnoDB中，如果表定义了PK，那PK就是聚簇索引。如果没有PK，就会找第一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。



MySQL的覆盖索引和回表

- 如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查询，这样查询速度就可以更快。

- 实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。



### 39、什么是倒排索引

索引：从ID到内容
倒排索引：从内容到ID。好处：比较适合做关键字检索；可以控制数据的总量；提高查询效率

文章 -》排序 term dictionary -》term index -》Posting List -》文章ID，[在文章中出现的偏移量]，权重(TFIDF)
将文章拆分成 词，然后记录下包含这些词的文章id
按 term dictionary的前缀维护一个term index



面试题：搜索引擎为什么比MySQL查询快？

- MySQL也能走索引，且倒排索引与MySQL底层都是用的B+树

- term dictionary 挺大的，无法全部加载到内存。于是维护了一个 term index()

